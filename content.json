[{"title":"PageHelper分页插件的整合与项目应用","date":"2020-07-22T11:31:56.000Z","path":"2020/07/22/PageHelper分页插件的整合与项目应用/","text":"MyBatis 分页插件 PageHelper链接: PageHelper官网.分页插件支持任何复杂的单表、多表分页； 分页结果（结合了一点BootStrap）： My Environment IDEA2018.3 JDK1.8 SpringBoot2.3.0 360浏览器 Springboot整合PageHelper插件1. pom.xml引入PageHelper依赖123456&lt;!--引入pagehelper分页插件--&gt; &lt;dependency&gt; &lt;groupId&gt;com.github.pagehelper&lt;/groupId&gt; &lt;artifactId&gt;pagehelper-spring-boot-starter&lt;/artifactId&gt; &lt;version&gt;1.2.10&lt;/version&gt; &lt;/dependency&gt; 2. 配置application.properties/application.ymlapplication.properties: 12345# pagehelper分页插件配置pagehelper.helperDialect=mysqlpagehelper.reasonable=truepagehelper.supportMethodsArguments=truepagehelper.params=count=countSql application.yml: 123456# pagehelper分页插件配置pagehelper: helperDialect: mysql reasonable: true supportMethodsArguments: true pageSizeZero: false #pageSize=0 有关分页插件的基本配置就完成了（当然其他必要的基本配置也需要提前配置好）;也可以直接参考官网链接: 使用文档. SpringBoot结合Thymeleaf实现分页首先我们需要写一个查询数据库然后展示到前端界面的各层代码：Entity类： 12345678910111213141516171819202122232425package com.cjw.entity;import lombok.AllArgsConstructor;import lombok.NoArgsConstructor;import lombok.ToString;import lombok.Data;import lombok.experimental.Accessors;import java.util.Date;@Data@ToString@AllArgsConstructor@NoArgsConstructor@Accessors(chain = true) //链式调用public class Emp &#123; private String id; private String name; private Double salary; private Integer age; private Date bir;&#125; Dao层接口： 12345678910111213package com.cjw.dao;import com.cjw.entity.Emp;import org.springframework.stereotype.Repository;import java.util.List;@Repositorypublic interface EmpDao &#123; List&lt;Emp&gt; findAll();&#125; 数据库Mapper.xml文件： 1234567891011&lt;?xml version=\"1.0\" encoding=\"UTF-8\" ?&gt;&lt;!DOCTYPE mapper PUBLIC \"-//mybatis.org//DTD Mapper 3.0//EN\" \"http://mybatis.org/dtd/mybatis-3-mapper.dtd\"&gt;&lt;mapper namespace=\"com.cjw.dao.EmpDao\"&gt; &lt;!--查询所有--&gt; &lt;select id=\"findAll\" resultType=\"Emp\"&gt; select id,name,salary,age,bir from t_emp &lt;/select&gt;&lt;/mapper&gt; 服务层及其实现层： 123456789package com.cjw.service;import com.cjw.entity.Emp;import java.util.List;public interface EmpService &#123; List&lt;Emp&gt; findAll();&#125; 1234567891011121314151617181920212223package com.cjw.service.Impl;import com.cjw.dao.EmpDao;import com.cjw.entity.Emp;import com.cjw.service.EmpService;import org.springframework.beans.factory.annotation.Autowired;import org.springframework.stereotype.Service;import java.util.List;import java.util.UUID;@Servicepublic class EmpServiceImpl implements EmpService &#123; @Autowired private EmpDao empDao; @Override public List&lt;Emp&gt; findAll() &#123; return empDao.findAll(); &#125;&#125; 然后只需要在控制层中使用分页插件进行替换，并用model返回至前端：控制层： 12345678910111213141516171819@Controllerpublic class EmpController &#123; @Autowired private EmpService empService; @GetMapping(\"emp/findAll\") public String findAll(@RequestParam(defaultValue = \"1\") int pageNum, @RequestParam(defaultValue = \"5\") int pageSize, Model model)&#123; PageHelper.startPage(pageNum,pageSize);//关键 PageInfo&lt;Emp&gt; pageInfo = new PageInfo&lt;&gt;(empService.findAll()); model.addAttribute(\"pageInfo\",pageInfo);// List&lt;Emp&gt; emps = empService.findAll();// model.addAttribute(\"emps\",emps); return \"ems/emplist\"; &#125; 前端Html: 123456789101112131415161718192021222324252627282930313233343536373839404142434445&lt;table class=\"table\"&gt; &lt;tr class=\"table_header\"&gt; &lt;td&gt; ID &lt;/td&gt; &lt;td&gt; 用户名 &lt;/td&gt; &lt;td&gt; 收入 &lt;/td&gt; &lt;td&gt; 年龄 &lt;/td&gt; &lt;td&gt; 生日 &lt;/td&gt; &lt;td&gt; 操作 &lt;/td&gt; &lt;/tr&gt;&lt;tr th:class=\"$&#123;rowstate.odd&#125;?'row1':'row2'\" th:each=\"emp,rowstate:$&#123;pageInfo.list&#125;\" &gt; &lt;td&gt; &lt;span th:text=\"$&#123;emp.id&#125;\"&gt;&lt;/span&gt; &lt;/td&gt; &lt;td&gt; &lt;span th:text=\"$&#123;emp.name&#125;\"&gt;&lt;/span&gt; &lt;/td&gt; &lt;td&gt; &lt;span th:text=\"$&#123;emp.salary&#125;\"&gt;&lt;/span&gt; &lt;/td&gt; &lt;td&gt; &lt;span th:text=\"$&#123;emp.age&#125;\"&gt;&lt;/span&gt; &lt;/td&gt; &lt;td&gt; &lt;span th:text=\"$&#123;#dates.format(emp.bir,'yyyy-MM-dd')&#125;\"&gt;&lt;/span&gt; &lt;/td&gt; &lt;td&gt; &lt;!--&lt;a th:href=\"@&#123;/toSave&#125;\"&gt;新增&lt;/a&gt;&amp;nbsp;--&gt; &lt;a th:href=\"@&#123;/emp/update(id=$&#123;emp.id&#125;)&#125;\"&gt;更改&lt;/a&gt;&amp;nbsp; &lt;a th:href=\"@&#123;/emp/delete(id=$&#123;emp.id&#125;)&#125;\"&gt;删除&lt;/a&gt; &lt;/td&gt; &lt;/tr&gt; &lt;/table&gt; 分页部分： 12345678910111213&lt;div class=\"modal-footer no-margin-top\"&gt; &lt;ul class=\"pagination pagination-lg\"&gt; &lt;li class=\"page-item\"&gt;&lt;a class=\"page-link\"&gt;&lt;span&gt;当前页为：&lt;/span&gt;&lt;span th:text=\"第+$&#123;pageInfo.pageNum&#125;+页\"&gt;&lt;/span&gt;&lt;/a&gt;&lt;/li&gt; &lt;!--&lt;li class=\"page-item\"&gt;&lt;a class=\"page-link\" th:href=\"@&#123;/emp/findAll&#125;\"&gt;首页&lt;/a&gt;&lt;/li&gt;--&gt; &lt;li&gt;&lt;a th:href=\"@&#123;/emp/findAll?pageNum=0&#125;\"&gt;首页&lt;/a&gt;&lt;/li&gt; &lt;li class=\"page-item\"&gt;&lt;a class=\"page-link\" th:href=\"@&#123;/emp/findAll(pageNum=1)&#125;\"&gt;1&lt;/a&gt;&lt;/li&gt; &lt;li class=\"page-item\"&gt;&lt;a class=\"page-link\" th:href=\"@&#123;/emp/findAll(pageNum=2)&#125;\"&gt;2&lt;/a&gt;&lt;/li&gt; &lt;li class=\"page-item\"&gt;&lt;a class=\"page-link\" th:href=\"@&#123;/emp/findAll(pageNum=3)&#125;\"&gt;3&lt;/a&gt;&lt;/li&gt; &lt;li class=\"page-item\"&gt;&lt;a class=\"page-link\" th:href=\"@&#123;/emp/findAll(pageNum=$&#123;pageInfo.getNextPage()&#125;)&#125;\"&gt;下一页&lt;/a&gt;&lt;/li&gt; &lt;li class=\"page-item\"&gt;&lt;a class=\"page-link\"&gt;&lt;span th:text=\"共+$&#123;pageInfo.pageSize&#125;+页\"&gt;&lt;/span&gt;&lt;/a&gt;&lt;/li&gt; &lt;/ul&gt; &lt;/div&gt; END","updated":"2020-07-23T03:07:27.825Z","categories":[{"name":"SpringBoot","slug":"SpringBoot","permalink":"http://yoursite.com/categories/SpringBoot/"}],"tags":[{"name":"SpringBoot","slug":"SpringBoot","permalink":"http://yoursite.com/tags/SpringBoot/"},{"name":"PageHelper","slug":"PageHelper","permalink":"http://yoursite.com/tags/PageHelper/"}]},{"title":"SpringBoot项目热部署生效方法","date":"2020-07-22T11:31:36.000Z","path":"2020/07/22/SpringBoot项目热部署生效方法/","text":"My Environment IDEA2018.3 JDK1.8 SpringBoot2.3.0 360浏览器 Springboot提供了热部署的方式，当发现有任何类发生了改变，马上通过JVM类加载的方式，加载最新的类到虚拟机中。 这样就不必重启也能看到改动后的效果了，只需在浏览器刷新页面即可更新显示内容，不需要再重启整个项目工程，提高了开发效率。 如果前端使用了thymeleaf，那么在properties或yml中配置关闭thymeleaf缓存： 1spring.thymeleaf.cache=false 如果修改的只是页面会自动刷新，如果是java类文件需要手动点击工具栏的build–&gt;Build-&gt;Modules ‘myProject’. Springboot版本也有可能导致热部署配置失败 1. pom.xml在pom文件中，引入如下依赖： 123456&lt;!--热部署插件--&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-devtools&lt;/artifactId&gt; &lt;scope&gt;runtime&lt;/scope&gt; &lt;/dependency&gt; 后，在插件中配置按如下配置： 12345678910111213&lt;build&gt; &lt;plugins&gt; &lt;plugin&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-maven-plugin&lt;/artifactId&gt; &lt;configuration&gt; &lt;!--fork : 必须配置，否则热部署不会生效，应用不会重置 --&gt; &lt;fork&gt;true&lt;/fork&gt; &lt;addResources&gt;true&lt;/addResources&gt; &lt;/configuration&gt; &lt;/plugin&gt; &lt;/plugins&gt; &lt;/build&gt; 或者直接在依赖中配置： 12345&lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-devtools&lt;/artifactId&gt; &lt;optional&gt;true&lt;/optional&gt; &lt;!--true时热部署生效 --&gt;&lt;/dependency&gt; 打开maven仓库查看配置和依赖是否引入完成。 2. IDEA中配置File中Settings打开顶部工具栏 File -&gt; Settings -&gt; Default Settings -&gt; Build -&gt; Compiler 然后勾选 Build project automatically 如下图所示：后点击Help中的Find Action —&gt;（Ctrl + Shift + A）后在搜索栏中输入Registry查找：点击确定后，勾选 Compiler autoMake allow when app running后保存设置： 3. 浏览器中配置打开浏览器按Fn + F12进入审查元素，选择Network后勾选【✅】Disable cache ： 确保以上均已完成配置，那么===================================================项目热部署配置完成，重新编译启动工程修改IDEA工程代码后刷新浏览器，不用再重新启动工程了! END","updated":"2020-07-23T02:54:29.424Z","categories":[{"name":"SpringBoot","slug":"SpringBoot","permalink":"http://yoursite.com/categories/SpringBoot/"}],"tags":[{"name":"SpringBoot","slug":"SpringBoot","permalink":"http://yoursite.com/tags/SpringBoot/"}]},{"title":"Maven仓库导包慢的解决办法","date":"2020-07-22T11:31:15.000Z","path":"2020/07/22/Maven仓库导包慢的解决办法/","text":"故障原因原因：默认安装的maven使用官网地址下载依赖包，在国内访问比较慢。方法：将maven配置文件中下载依赖包地址修改成国内地址，一般都使用阿里的地址。 解决方法1，右键项目名，选择maven替换setting.xml文件中的这部分为如下样式： 1234567891011121314151617181920212223242526272829303132333435&lt;mirrors&gt; &lt;!-- mirror | Specifies a repository mirror site to use instead of a given repository. The repository that | this mirror serves has an ID that matches the mirrorOf element of this mirror. IDs are used | for inheritance and direct lookup purposes, and must be unique across the set of mirrors. | &lt;mirror&gt; &lt;id&gt;mirrorId&lt;/id&gt; &lt;mirrorOf&gt;repositoryId&lt;/mirrorOf&gt; &lt;name&gt;Human Readable Name for this Mirror.&lt;/name&gt; &lt;url&gt;http://my.repository.com/repo/path&lt;/url&gt; &lt;/mirror&gt; --&gt; &lt;!-- &lt;mirror&gt; --&gt; &lt;!-- &lt;id&gt;repo2&lt;/id&gt; --&gt; &lt;!-- &lt;mirrorOf&gt;central&lt;/mirrorOf&gt; --&gt; &lt;!-- &lt;name&gt;Human Readable Name for this Mirror.&lt;/name&gt; --&gt; &lt;!-- &lt;url&gt;http://repo2.maven.org/maven2/&lt;/url&gt; --&gt; &lt;!-- &lt;/mirror&gt; --&gt; &lt;mirror&gt; &lt;!--This sends everything else to /public --&gt; &lt;id&gt;nexus&lt;/id&gt; &lt;mirrorOf&gt;*&lt;/mirrorOf&gt; &lt;url&gt;http://maven.aliyun.com/nexus/content/groups/public/&lt;/url&gt; &lt;/mirror&gt; &lt;mirror&gt; &lt;!--This is used to direct the public snapshots repo in the profile below over to a different nexus group --&gt; &lt;id&gt;nexus-public-snapshots&lt;/id&gt; &lt;mirrorOf&gt;public-snapshots&lt;/mirrorOf&gt; &lt;url&gt;http://maven.aliyun.com/nexus/content/repositories/snapshots/&lt;/url&gt; &lt;/mirror&gt; &lt;/mirrors&gt; 2.打开本地maven位置，选择setting.xml文件，修改同上位置打开.xml文件后替换红框部分：重启idea后更新maven仓库，下载飞快。 END","updated":"2020-07-23T02:55:53.132Z","categories":[{"name":"JavaWeb","slug":"JavaWeb","permalink":"http://yoursite.com/categories/JavaWeb/"}],"tags":[{"name":"SpringBoot","slug":"SpringBoot","permalink":"http://yoursite.com/tags/SpringBoot/"},{"name":"Maven","slug":"Maven","permalink":"http://yoursite.com/tags/Maven/"}]},{"title":"SpringBoot的启动图案修改","date":"2020-07-22T11:30:53.000Z","path":"2020/07/22/SpringBoot的启动图案修改/","text":"Springboot项目启动时，会出现大大的SpringBoot的图案：修改：首先创建springboot项目，首先在resources/目录下创建名为banner.txt的文件：点击链接：SpringBoot的启动图案修改 启动项目：无聊…..END","updated":"2020-07-22T11:34:03.025Z","categories":[{"name":"SpringBoot","slug":"SpringBoot","permalink":"http://yoursite.com/categories/SpringBoot/"}],"tags":[{"name":"SpringBoot","slug":"SpringBoot","permalink":"http://yoursite.com/tags/SpringBoot/"}]},{"title":"Java Web之环境搭建（测试用）","date":"2020-07-22T11:19:02.000Z","path":"2020/07/22/Java-Web之环境搭建（测试用）/","text":"Java Web之环境搭建1. Java Web介绍Java Web是用Java技术来解决web领域的技术，需要运行在特定的web服务器上，Java Web是跨平台的，可以在不同的平台上进行部署运行。需要掌握的技术1.前端方面的相关技术如：html、css、js等2.服务端先关技术如：java，jsp，服务器，ssh、ssm框架，等3.数据库相关：MySQL，Oracle等 2. 开发环境准备编辑器：Eclipse或Idea等java环境：JDK1.8服务器：Tomcat环境搭建完毕之后，就可以创建项目开始开发了。 环境搭建参考：Java Web之环境搭建.","updated":"2020-07-23T02:56:21.946Z","categories":[{"name":"JavaWeb","slug":"JavaWeb","permalink":"http://yoursite.com/categories/JavaWeb/"}],"tags":[{"name":"JavaWeb","slug":"JavaWeb","permalink":"http://yoursite.com/tags/JavaWeb/"}]},{"title":"springboot application.properties 配置及参数配置详情介绍","date":"2020-07-22T11:18:28.000Z","path":"2020/07/22/springboot-application-properties-配置及参数配置详情介绍/","text":"","updated":"2020-07-22T11:18:28.942Z","categories":[],"tags":[]},{"title":"SpringBoot项目打包为jar包","date":"2020-07-22T11:18:02.000Z","path":"2020/07/22/SpringBoot项目打包为jar包/","text":"My Environment IDEA2018.3 JDK1.8 SpringBoot2.3.0 360浏览器项目部署一般是两种方式：一种是打包成 jar 包直接执行，另一种是打包成 war 包放到 Tomcat 服务器下，SpringBoot一般情况下默认为jar包方式。pom.xml：&lt; packaging&gt;jar&lt; /packaging&gt; （默认）&lt; packaging&gt;war&lt; /packaging&gt; 打jar包选择 File -&gt; Project Structure-&gt;Artifacts-&gt;Jar-&gt;Form modules with dependencies后点ok:根据 下图内容创建 jar。如图所示，选择项目，入口类等。最后一项 META-INF，默认放到 src\\main\\java 目录里，如果使用默认值，没有进行其他配置，生成的 jar 有可能不会包含 META-INF 目录，导致运行 jar 出错。最好放在 src\\main\\resource目录中。点击ok保存。按下图所示配置：点击ok会出现如图所示信息:生成jar包点击idea菜单栏中的build，依次选择：点Build:在保存路经中查找所打包的jar包如果存在则说明打包成功。运行jar包开始运行jar包，打开cmd进入jar所在的路径，输入java -jar xxx.jar (jar名称) ，点击回车按键。 1234567891011121314151617181920212223242526272829303132333435363738Microsoft Windows [版本 10.0.18362.959](c) 2019 Microsoft Corporation。保留所有权利。C:\\Users\\92895&gt;D:D:\\&gt;cd D:\\data_view\\out\\artifacts\\data_view_jarD:\\data_view\\out\\artifacts\\data_view_jar&gt;Java -jar data_view_jarError: Unable to access jarfile data_view_jarD:\\data_view\\out\\artifacts\\data_view_jar&gt;java -jar data_view_jarError: Unable to access jarfile data_view_jarD:\\data_view\\out\\artifacts\\data_view_jar&gt;java -jar data_view.jar_________ ____.__ __\\_ ___ \\ | / \\ / \\/ \\ \\/ | \\ \\/\\/ /\\ \\____/\\__| |\\ / \\______ /\\________| \\__/\\ / \\/ \\/2020-07-20 09:51:27.016 INFO 12564 --- [ restartedMain] com.dvms.DataViewApplication : Starting DataViewApplication on 4C501 with PID 12564 (D:\\data_view\\out\\artifacts\\data_view_jar\\data_view.jar started by 92895 in D:\\data_view\\out\\artifacts\\data_view_jar)2020-07-20 09:51:27.020 INFO 12564 --- [ restartedMain] com.dvms.DataViewApplication : No active profile set, falling back to default profiles: default2020-07-20 09:51:27.068 INFO 12564 --- [ restartedMain] .e.DevToolsPropertyDefaultsPostProcessor : Devtools property defaults active! Set 'spring.devtools.add-properties' to 'false' to disable2020-07-20 09:51:27.068 INFO 12564 --- [ restartedMain] .e.DevToolsPropertyDefaultsPostProcessor : For additional web related logging consider setting the 'logging.level.web' property to 'DEBUG'2020-07-20 09:51:28.817 INFO 12564 --- [ restartedMain] o.s.b.w.embedded.tomcat.TomcatWebServer : Tomcat initialized with port(s): 8080 (http)2020-07-20 09:51:28.831 INFO 12564 --- [ restartedMain] o.apache.catalina.core.StandardService : Starting service [Tomcat]2020-07-20 09:51:28.832 INFO 12564 --- [ restartedMain] org.apache.catalina.core.StandardEngine : Starting Servlet engine: [Apache Tomcat/9.0.35]2020-07-20 09:51:28.896 INFO 12564 --- [ restartedMain] o.a.c.c.C.[Tomcat].[localhost].[/] : Initializing Spring embedded WebApplicationContext2020-07-20 09:51:28.896 INFO 12564 --- [ restartedMain] o.s.web.context.ContextLoader : Root WebApplicationContext: initialization completed in 1827 ms2020-07-20 09:51:29.631 INFO 12564 --- [ restartedMain] o.s.s.web.DefaultSecurityFilterChain : Creating filter chain: any request, [org.springframework.security.web.context.request.async.WebAsyncManagerIntegrationFilter@56cf4f3a, org.springframework.security.web.context.SecurityContextPersistenceFilter@45e169c9, org.springframework.security.web.header.HeaderWriterFilter@26d4eefe, org.springframework.security.web.authentication.logout.LogoutFilter@f17fdd6, org.springframework.security.web.authentication.UsernamePasswordAuthenticationFilter@5f33f6b3, org.springframework.security.web.authentication.ui.DefaultLoginPageGeneratingFilter@70ffa278, org.springframework.security.web.authentication.ui.DefaultLogoutPageGeneratingFilter@109a14b8, org.springframework.security.web.savedrequest.RequestCacheAwareFilter@54857a49, org.springframework.security.web.servletapi.SecurityContextHolderAwareRequestFilter@423bad4c, org.springframework.security.web.authentication.rememberme.RememberMeAuthenticationFilter@7e8ca12a, org.springframework.security.web.authentication.AnonymousAuthenticationFilter@3ee5e690, org.springframework.security.web.session.SessionManagementFilter@7139411a, org.springframework.security.web.access.ExceptionTranslationFilter@1ec9ee0a, org.springframework.security.web.access.intercept.FilterSecurityInterceptor@bf4c490]2020-07-20 09:51:29.711 INFO 12564 --- [ restartedMain] o.s.s.concurrent.ThreadPoolTaskExecutor : Initializing ExecutorService 'applicationTaskExecutor'2020-07-20 09:51:29.929 INFO 12564 --- [ restartedMain] o.s.b.d.a.OptionalLiveReloadServer : LiveReload server is running on port 357292020-07-20 09:51:29.967 INFO 12564 --- [ restartedMain] o.s.b.w.embedded.tomcat.TomcatWebServer : Tomcat started on port(s): 8080 (http) with context path ''2020-07-20 09:51:29.976 INFO 12564 --- [ restartedMain] com.dvms.DataViewApplication : Started DataViewApplication in 3.27 seconds (JVM running for 3.828)2020-07-20 09:51:44.774 INFO 12564 --- [nio-8080-exec-1] o.a.c.c.C.[Tomcat].[localhost].[/] : Initializing Spring DispatcherServlet 'dispatcherServlet'2020-07-20 09:51:44.775 INFO 12564 --- [nio-8080-exec-1] o.s.web.servlet.DispatcherServlet : Initializing Servlet 'dispatcherServlet'2020-07-20 09:51:44.782 INFO 12564 --- [nio-8080-exec-1] o.s.web.servlet.DispatcherServlet : Completed initialization in 5 ms2020-07-20 09:51:56.052 INFO 12564 --- [nio-8080-exec-5] com.alibaba.druid.pool.DruidDataSource : &#123;dataSource-1&#125; init 浏览器输入：localhost8080:/index（根据实际项目）显示网页说明打包成功！！！","updated":"2020-07-23T02:55:03.213Z","categories":[{"name":"SpringBoot","slug":"SpringBoot","permalink":"http://yoursite.com/categories/SpringBoot/"}],"tags":[{"name":"SpringBoot","slug":"SpringBoot","permalink":"http://yoursite.com/tags/SpringBoot/"},{"name":"jar包","slug":"jar包","permalink":"http://yoursite.com/tags/jar%E5%8C%85/"}]},{"title":"jar包和war包区别及理解","date":"2020-07-22T11:17:33.000Z","path":"2020/07/22/jar包和war包区别及理解/","text":"在开发阶段不适合使用war包，因为在开发阶段，经常需要添加或删除Web应用程序的内容，更新 Servlet类文件，而每一次改动后，重新建立war包将是一件浪费时间的事情。在产品发布阶段，使用war文件比较合适的，因为在这个时候，几乎不需要再做什么改动了。 jar包jar是类的归档文件JAR（Java Archive，Java 归档文件）是与平台无关的文件格式，它允许将许多文件组合成一个压缩文件，为 J2EE 应用程序创建的jar文件是 EAR 文件（企业 jar文件），jar文件格式以流行的 ZIP 文件格式为基础。与 ZIP 文件不同的是，jar文件不仅用于压缩和发布，而且还用于部署和封装库、组件和插件程序，并可被像编译器和 JVM 这样的工具直接使用。在 jar中包含特殊的文件，如 manifests 和部署描述符，用来指示工具如何处理特定的 jar。通常是开发时要引用通用类，打成jar包便于存放管理，当你使用某些功能时就需要这些jar包的支持，需要导入jar包。jar包就是java的类进行编译生成的class文件打包的压缩包，包里面就是一些class文件。当我们自己使用Maven写一些java程序，进行打包生成jar包。同时在可以在其他的工程下使用，但是我们在这个工程依赖的jar包，在其他工程使用该JAR包也要导入。 war包war包是一个Web应用程序一个web程序进行打包便于部署的压缩包，里面包含我们web程序需要的一些东西，其中包括web.xml的配置文件，前端的页面文件，以及依赖的jar。便于我们部署工程，直接放到tomcat的webapps目录下，直接启动tomcat即可。同时，可以使用WinRAR查看war包，直接将后缀.war改成.rar。 Web存档(war)文件包含Web应用程序的所有内容。它减少了传输文件所需要的时间。 jar包和war包区别jar是java普通项目打包，通常是开发时要引用通用类，打成jar包便于存放管理。当你使用某些功能时就需要这些jar包的支持，需要导入jar包。war是java web项目打包，web网站完成后，打成war包部署到服务器，目的是为了节省资源，提供效率。 jar文件（扩展名为. Jar，Java Application Archive）包含Java类的普通库、资源（resources）、辅助文件（auxiliary files）等。通常是开发时要引用的通用类，打成包便于存放管理。简单来说，jar包就是别人已经写好的一些类，然后对这些类进行打包。可以将这些jar包引入到你的项目中，可以直接使用这些jar包中的类和属性，这些jar包一般放在lib目录下。 war文件（扩展名为.War,Web Application Archive）包含全部Web应用程序。在这种情形下，一个Web应用程序被定义为单独的一组文件、类和资源，用户可以对jar文件进行封装，并把它作为小型服务程序（servlet）来访问。 war包是一个可以直接运行的web模块，通常用于网站，打成包部署到容器中。以Tomcat来说，将war包放置在其\\webapps\\目录下,然后启动Tomcat，这个包就会自动解压，就相当于发布了。war包是Sun提出的一种web应用程序格式，与jar类似，是很多文件的压缩包。war包中的文件按照一定目录结构来组织。根据其根目录下包含有html和jsp文件，或者包含有这两种文件的目录，另外还有WEB-INF目录。通常在WEB-INF目录下含有一个web.xml文件和一个classes目录，web.xml是这个应用的配置文件，而classes目录下则包含编译好的servlet类和jsp，或者servlet所依赖的其他类（如JavaBean）。通常这些所依赖的类也可以打包成jar包放在WEB-INF下的lib目录下。 Ear文件（扩展名为.Ear,Enterprise Application Archive）包含全部企业应用程序。在这种情形下，一个企业应用程序被定义为多个jar文件、资源、类和Web应用程序的集合。 SpringBoot项目既可以打成war包发布，也可以找成jar包发布。jar包：直接通过内置Tomcat运行，不需要额外安装Tomcat。如需修改内置Tomcat的配置，只需要在SpringBoot的配置文件中配置。内置Tomcat没有自己的日志输出，全靠jar包应用输出日志。但是比较方便，快速，比较简单。war包：传统的应用交付方式，需要安装Tomcat，然后放到wabapps目录下运行war包，可以==灵活选择Tomcat版本==，可以直接修改Tomcat的配置，有自己的Tomcat日志输出，可以灵活配置安全策略,相对打成jar包来说没那么快速方便。 END","updated":"2020-07-23T02:56:37.305Z","categories":[{"name":"JavaWeb","slug":"JavaWeb","permalink":"http://yoursite.com/categories/JavaWeb/"}],"tags":[{"name":"SpringBoot","slug":"SpringBoot","permalink":"http://yoursite.com/tags/SpringBoot/"},{"name":"jar包","slug":"jar包","permalink":"http://yoursite.com/tags/jar%E5%8C%85/"}]},{"title":"MANIFEST.MF文件属性总结理解","date":"2020-07-22T11:15:57.000Z","path":"2020/07/22/MANIFEST-MF文件属性总结理解/","text":"MANIFEST.MF定义了与扩展和包相关的数据；打开Java的JAR文件我们经常可以看到文件中包含着一个META-INF目录， 这个目录下会有一些文件，其中必有一个MANIFEST.MF，这个文件描述了该Jar文件的很多信息。 MANIFEST.MF文件属性 一. 一般属性 Manifest-Version用来定义manifest文件的版本，例如：Manifest-Version: 1.0 Created-By声明该文件的生成者，一般该属性是由jar命令行工具生成的，例如：Created-By: Apache Ant 1.5.1 Signature-Version定义jar文件的签名版本 Class-Path应用程序或者类装载器使用该值来构建内部的类搜索路径 二. 应用程序相关属性 Main-Class定义jar文件的入口类，该类必须是一个可执行的类，一旦定义了该属性即可通过 java -jar x.jar来运行该jar文件。 三. 小程序(Applet)相关属性 Extendsion-List该属性指定了小程序需要的扩展信息列表，列表中的每个名字对应以下的属性 -Extension-Name -Specification-Version -Implementation-Version -Implementation-Vendor-Id -Implementation-URL 四. 扩展标识属性 Extension-Name该属性定义了jar文件的标识，例如Extension-Name: Struts Framework 五. 包扩展属性 Implementation-Title 定义了扩展实现的标题 Implementation-Version 定义扩展实现的版本 Implementation-Vendor 定义扩展实现的组织 Implementation-Vendor-Id 定义扩展实现的组织的标识 Implementation-URL : 定义该扩展包的下载地址(URL) Specification-Title 定义扩展规范的标题 Specification-Version 定义扩展规范的版本 Specification-Vendor 声明了维护该规范的组织 Sealed 定义jar文件是否封存，值可以是true或者false (这点我还不是很理解) 六. 签名相关属性 签名方面的属性我们可以来参照JavaMail所提供的mail.jar中的一段 Name: javax/mail/Address.classDigest-Algorithms: SHA MD5SHA-Digest: AjR7RqnN//cdYGouxbd06mSVfI4=MD5-Digest: ZnTIQ2aQAtSNIOWXI1pQpw== 这段内容定义类签名的类名、计算摘要的算法名以及对应的摘要内容(使用BASE方法进行编码) 七.自定义属性 除了前面提到的一些属性外，你也可以在MANIFEST.MF中增加自己的属性以及响应的值，例如J2ME程序jar包中就可能包含着如下信息 MicroEdition-Configuration: CLDC-1.0MIDlet-Name: J2ME_MOBBER Midlet SuiteMIDlet-Info-URL: http://www.javayou.comMIDlet-Icon: /icon.pngMIDlet-Vendor: Midlet Suite VendorMIDlet-1: mobber,/icon.png,mobberMIDlet-Version: 1.0.0MicroEdition-Profile: MIDP-1.0MIDlet-Description: Communicator其他可参考：MANIFEST.MF文件详解 END","updated":"2020-07-23T02:56:13.459Z","categories":[{"name":"JavaWeb","slug":"JavaWeb","permalink":"http://yoursite.com/categories/JavaWeb/"},{"name":"SpringBoot","slug":"JavaWeb/SpringBoot","permalink":"http://yoursite.com/categories/JavaWeb/SpringBoot/"}],"tags":[{"name":"JavaWeb","slug":"JavaWeb","permalink":"http://yoursite.com/tags/JavaWeb/"},{"name":"SpringBoot","slug":"SpringBoot","permalink":"http://yoursite.com/tags/SpringBoot/"}]},{"title":"Maven仓库安装配置教程(windows)","date":"2020-07-21T11:42:28.000Z","path":"2020/07/21/Maven仓库安装配置教程-windows/","text":"1. 安装本地Maven点此进入maven官网下载 2.配置环境变量系统变量:MAVEN_HOME = D:\\apache-maven-3.6.1系统变量:path = %MAVEN_HOME%\\bin 3. 验证安装然后win+R 运行cmd 输入 mvn -version，如图所示则配置成功！！！ 4. 配置settings文件在D:\\apache-maven-3.6.1\\conf下可以找到settings文件找到第52行，这里是maven默认的仓库，复制第53行/path/to/local/repo将它拿到注释外并将中间的内容改成你需要的路径:(不改也行) 1&lt;localRepository&gt;D:/repository&lt;/localRepository&gt; 这里的路径随便设置，注意这里是正斜杠因为国外的服务器下载jar包很慢所以我们改为阿里云服务器（大约在150行左右），这两个仓库只用选一个(根据大家反馈建议使用第一个，第二个在有的版本可能会出现warning) alimaven central aliyun maven http://maven.aliyun.com/nexus/content/repositories/central/ 或者 nexus-aliyun * Nexus aliyun http://maven.aliyun.com/nexus/content/groups/public 在最后配置jdk，也要夹在两个profiles标签之间（不改也没事） jdk-1.8 true 1.8 &lt;properties&gt; &lt;maven.compiler.source&gt;1.8&lt;/maven.compiler.source&gt; &lt;maven.compiler.target&gt;1.8&lt;/maven.compiler.target&gt; &lt;maven.compiler.compilerVersion&gt;1.8&lt;/maven.compiler.compilerVersion&gt; &lt;/properties&gt; 配置完成，在命令行输入mvn help:system测试，看到下载链接里面是ailiyun的链接表示配置成功： END","updated":"2020-07-23T02:56:00.309Z","categories":[],"tags":[]},{"title":"SpringBoot整合Mybatis","date":"2020-07-21T11:20:32.000Z","path":"2020/07/21/SpringBoot整合Mybatis/","text":"My Environment IDEA2018.3 JDK1.8 SpringBoot2.3.0 360浏览器整合过程 新建一个Spring Initializr项目 创建项目的文件结构以及jdk的版本 选择项目所需要的依赖 修改项目名，点击完成 选择自动导入依赖pom,xml文件 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081&lt;?xml version=\"1.0\" encoding=\"UTF-8\"?&gt;&lt;project xmlns=\"http://maven.apache.org/POM/4.0.0\" xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\" xsi:schemaLocation=\"http://maven.apache.org/POM/4.0.0 https://maven.apache.org/xsd/maven-4.0.0.xsd\"&gt; &lt;modelVersion&gt;4.0.0&lt;/modelVersion&gt; &lt;parent&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-parent&lt;/artifactId&gt; &lt;version&gt;2.3.1.RELEASE&lt;/version&gt; &lt;relativePath/&gt; &lt;!-- lookup parent from repository --&gt; &lt;/parent&gt; &lt;groupId&gt;com.cjw&lt;/groupId&gt; &lt;artifactId&gt;demo&lt;/artifactId&gt; &lt;version&gt;0.0.1-SNAPSHOT&lt;/version&gt; &lt;name&gt;demo&lt;/name&gt; &lt;description&gt;Demo project for Spring Boot&lt;/description&gt; &lt;properties&gt; &lt;java.version&gt;1.8&lt;/java.version&gt; &lt;/properties&gt; &lt;dependencies&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-jdbc&lt;/artifactId&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-security&lt;/artifactId&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-thymeleaf&lt;/artifactId&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-web&lt;/artifactId&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.mybatis.spring.boot&lt;/groupId&gt; &lt;artifactId&gt;mybatis-spring-boot-starter&lt;/artifactId&gt; &lt;version&gt;2.1.3&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;mysql&lt;/groupId&gt; &lt;artifactId&gt;mysql-connector-java&lt;/artifactId&gt; &lt;scope&gt;runtime&lt;/scope&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.projectlombok&lt;/groupId&gt; &lt;artifactId&gt;lombok&lt;/artifactId&gt; &lt;optional&gt;true&lt;/optional&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-test&lt;/artifactId&gt; &lt;scope&gt;test&lt;/scope&gt; &lt;exclusions&gt; &lt;exclusion&gt; &lt;groupId&gt;org.junit.vintage&lt;/groupId&gt; &lt;artifactId&gt;junit-vintage-engine&lt;/artifactId&gt; &lt;/exclusion&gt; &lt;/exclusions&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.security&lt;/groupId&gt; &lt;artifactId&gt;spring-security-test&lt;/artifactId&gt; &lt;scope&gt;test&lt;/scope&gt; &lt;/dependency&gt; &lt;/dependencies&gt; &lt;build&gt; &lt;plugins&gt; &lt;plugin&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-maven-plugin&lt;/artifactId&gt; &lt;/plugin&gt; &lt;/plugins&gt; &lt;/build&gt;&lt;/project&gt; 6.修改配置文件 12345678910111213#server.port=8080#server.servlet.context-path=/index #访问路径设置spring.datasource.url = jdbc:mysql://localhost:3306/ems?characterEncoding=UTF-8&amp;useSSL=true&amp;serverTimezone=UTCspring.datasource.username = rootspring.datasource.password = 123456spring.datasource.driverClassName = com.mysql.cj.jdbc.Driverspring.datasource.type = com.alibaba.druid.pool.DruidDataSourcemybatis.mapper-locations = classpath:mapper/*.xmlmybatis.type-aliases-package = com.dvms.entityspring.resources.static-locations = classpath:/templates/,classpath:/static/ 这里使用application.properties文件，也可以使用更加简洁的application.yml文件，须要将resource文件夹下原有的application.properties文件删除，染回创建application.yml配置文件（备注：其实SpringBoot底层会把application.yml文件解析为application.properties）7.实现业务流程创建包controller、entity、mapper、service。resources下创建mapper文件夹，用于写sql语句，也可以用注解的方式直接写在mapper文件里。最终框架结构:完成以上，下面在启动类里加上注解用于给出需要扫描的dao文件路径@MapperScan(“com.dvms.dao”) //扫描dao接口,mybatis扫描路径，针对的是接口Mapper类最后启动，浏览器输入地址：http://localhost:8080/index(根据实际项目)显示出对应界面即可。END","updated":"2020-07-21T12:15:27.769Z","categories":[],"tags":[]},{"title":"SSM框架下各层的解释说明（Controller等）","date":"2020-07-21T11:04:12.000Z","path":"2020/07/21/SSM框架下各层的解释说明（Controller等）/","text":"SSM框架SSM框架是spring MVC ，Spring和Mybatis框架的整合，是标准的MVC模式，将整个系统划分为表现层（web），controller层，service层，dao层四层,使用spring MVC负责请求的转发和视图管理。Spring实现业务对象管理，Mybatis作为数据对象的持久化引擎。表现层（web）：通俗讲就是展现给用户的界面，即用户在使用一个系统的时候他的所见所得。业务逻辑层（service）：针对具体问题的操作，也可以说是对数据层的操作，对数据业务逻辑处理。数据访问层（dao）：该层所做事务直接操作数据库，针对数据的增添、删除、修改、更新、查找等。DataBase ===&gt; Entity ===&gt; Mapper.xml ===&gt; Dao.Java ===&gt; Service.java ===&gt; Controller.java ===&gt; html css js（thymeleaf） 各层解释说明用IDEA创建一个maven项目结构如左图所示,在该项目中,有五个包,分别是controller、dao、entity、service和serviceimpl：|层| 描述 ||–|–|| 实体层 | 数据库在项目中的类，主要用于定义与数据库对象应的属性，提供get/set方法,tostring方法,有参无参构造函数。 ||持久层 | 与数据库交互，dao层首先会创建dao接口，接着就可以在配置文件中定义该接口的实现类；接着就可以在模块中调用dao的接口进行数据业务的处理，而不用关注此接口的具体实现类是哪一个类，dao层的数据源和数据库连接的参数都是在配置文件中进行配置的。 ||业务层 |控制业务,业务模块的逻辑应用设计，和dao层一样都是先设计接口，再创建要实现的类，然后在配置文件中进行配置其实现的关联。接下来就可以在service层调用接口进行业务逻辑应用的处理。 || 实现层 |实现service接口的所有方法，整合service和dao ||控制层 | controller层主要调用Service层里面的接口控制具体的业务流程，控制的配置也要在配置文件中进行。Controller和Service的区别是：Controller负责具体的业务模块流程的控制；Service层负责业务模块的逻辑应用设计 | entity层（model层） 实体层用于存放我们的实体类，与数据库中的属性值基本保持一致，实现set和get的方法。 1.导入lombok小辣椒驱动依赖,用来生成get/set方法依赖： 12345678910111213141516171819202122232425package com.dvms.entity;import lombok.AllArgsConstructor;import lombok.Data;import lombok.NoArgsConstructor;import lombok.ToString;import lombok.experimental.Accessors;import java.util.Date;@Data@ToString@AllArgsConstructor@NoArgsConstructor@Accessors(chain = true) //链式调用public class Emp &#123; private String id; private String name; private Double salary; private Integer age; private Date bir;&#125; 2.传统方式 123456789101112131415161718192021222324252627282930313233343536373839404142package com.umf.entity;import java.io.Serializable;public class UpdataSettingEntity implements Serializable &#123; private static final long serialVersionUID = 1L; // private Integer id = 1; // private int updataflag; /** * 设置： */ public void setId(Integer id) &#123; this.id = id; &#125; /** * 获取： */ public Integer getId() &#123; return id; &#125; /** * 设置： */ public void setUpdataflag(int updataflag) &#123; this.updataflag = updataflag; &#125; /** * 获取： */ public int getUpdataflag() &#123; return updataflag; &#125;&#125; dao层（mapper层）dao层（接口类）对数据库进行数据持久化操作，他的方法语句是直接针对数据库操作的，主要实现一些增删改查操作，在Mybatis中方法主要与与xxxDao（Mapper）.xml内相互一一映射。Mybatis可以用.xml进行数据操作，也可以在dao层用注解的方式，也可以采取xml和dao层接口组合使用的方法（常用）。 12345678910111213141516171819202122232425262728package com.dvms.dao;import com.dvms.entity.User;import org.apache.ibatis.annotations.Param;import org.springframework.stereotype.Repository;import java.util.List;@Repositorypublic interface UserDao &#123; //登录 User login(@Param(\"username\") String username, @Param(\"password\") String password);// 在mybatis中传递多个参数要做参数的绑定 //新增用户(注册) void save(User user); //查询所有用户 List&lt;User&gt; findAlluser(); //删除用户 void delete(String id); //修改用户信息（先查再改） User update(String id); void add(User user);&#125; xxxDao（Mapper）.xml：关键： &lt; mapper namespace=”com.dvms.dao.UserDao“&gt;前提：基本数据库语法 123456789101112131415161718192021222324252627282930313233&lt;?xml version=\"1.0\" encoding=\"UTF-8\" ?&gt;&lt;!DOCTYPE mapper PUBLIC \"-//mybatis.org//DTD Mapper 3.0//EN\" \"http://mybatis.org/dtd/mybatis-3-mapper.dtd\"&gt;&lt;mapper namespace=\"com.dvms.dao.UserDao\"&gt;&lt;!--注册/新增用户--&gt; &lt;insert id=\"save\" parameterType=\"User\"&gt; insert into user (id,username,password,sex,phone,email,role) values (#&#123;id&#125;,#&#123;username&#125;,#&#123;password&#125;,#&#123;sex&#125;,#&#123;phone&#125;,#&#123;email&#125;,#&#123;role&#125;) &lt;/insert&gt;&lt;!--登录验证--&gt; &lt;select id=\"login\" resultType=\"User\"&gt; select id,username,password,sex,phone,email,role from user where username =#&#123;username&#125; and password =#&#123;password&#125; &lt;/select&gt;&lt;!--查询所有用户--&gt; &lt;select id=\"findAlluser\" resultType=\"User\"&gt; select id,username,password,sex,phone,email,role from user &lt;/select&gt;&lt;!--删除用户--&gt; &lt;delete id=\"delete\" parameterType=\"String\"&gt; delete from user where id=#&#123;id&#125; &lt;/delete&gt;&lt;!--修改用户信息--&gt; &lt;!--查到要修改的用户信息--&gt; &lt;select id=\"update\" parameterType=\"String\" resultType=\"User\"&gt; select id,username,password,sex,phone,email,role from user where id=#&#123;id&#125; &lt;/select&gt; &lt;!--修改用户信息--&gt; &lt;update id=\"add\" parameterType=\"User\"&gt; update user set username=#&#123;username&#125;,password=#&#123;password&#125;,sex=#&#123;sex&#125;,phone=#&#123;phone&#125;,email=#&#123;email&#125;,role=#&#123;role&#125; where id=#&#123;id&#125; &lt;/update&gt;&lt;/mapper&gt; 在dao层用注解的方式： 12345public interface StudentDao &#123; @Select(\"select * from student where stu_id=#&#123;stuId&#125;\") public Student queryById(int stuId);&#125; service层service层（接口类）为controller层的类提供接口进行调用,一般就是自己写的方法封装起来，具体实现在serviceImpl中。service层是建立在dao层之上的，建立了dao层后才可以建立service层，而service层又是在controller层之下的，因而service层应该既调用dao层的接口，又要提供接口给Controller层的类来进行调用，它刚好处于一个中间层的位置。每个模型都有一个service接口，每个接口分别封装各自的业务处理方法。 12345678910111213141516171819202122232425package com.dvms.service;import com.dvms.entity.User;import java.util.List;public interface UserService &#123; //新增用户 void save(User user); //登录 User login(String username, String password); //查询所有用户 List&lt;User&gt; findAlluser(); //删除用户 void delete(String id); //修改用户信息 User update(String id); void add(User user);&#125; servicedmpl（实现service层，整合service和dao）（导入dao层）（接口实现类） 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253package com.dvms.service.Impl;import com.dvms.dao.UserDao;import com.dvms.entity.User;import com.dvms.service.UserService;import org.springframework.beans.factory.annotation.Autowired;import org.springframework.stereotype.Service;import java.util.List;import java.util.UUID;@Servicepublic class UserServiceImpl implements UserService &#123; @Autowired private UserDao userDao; @Override public void save(User user) &#123; user.setId(UUID.randomUUID().toString()); userDao.save(user); &#125; @Override public User login(String username, String password) &#123; return userDao.login(username,password); &#125; @Override public List&lt;User&gt; findAlluser() &#123; return userDao.findAlluser(); &#125; @Override public void delete(String id) &#123; userDao.delete(id); &#125; @Override public User update(String id) &#123; return userDao.update(id); &#125; @Override public void add(User user) &#123; userDao.add(user); &#125;&#125; Controller层（web 层）负责具体模块的业务流程控制（获取参数（前端传过来）返回响应（前端或数据库或一个指定路径）），需要调用service逻辑设计层的接口来控制业务流程（导入service层）。 1234567891011121314151617181920212223242526272829303132package com.dvms.controller;import com.dvms.entity.Emp;.....@Controllerpublic class EmpController &#123; @Autowired private EmpService empService; @GetMapping(\"emp/findAll\") public String findAll(@RequestParam(defaultValue = \"1\") int pageNum, @RequestParam(defaultValue = \"5\") int pageSize, Model model)&#123; PageHelper.startPage(pageNum,pageSize);// PageInfo&lt;Emp&gt; pageInfo = new PageInfo&lt;&gt;(empService.findAll()); model.addAttribute(\"pageInfo\",pageInfo);// List&lt;Emp&gt; emps = empService.findAll();// model.addAttribute(\"emps\",emps); return \"ems/tables\"; &#125; @RequestMapping(\"/emp/save\") public String save(Emp emp)&#123; empService.save(emp); return \"redirect:/emp/findAll\"; &#125;&#125; Controller层调用了Service层的接口方法，Service层调用Dao层的方法，其中调用的参数是使用Entity层进行传递的。View层与Controller层协同工作,主要负责界面展示。","updated":"2020-07-23T03:15:55.159Z","categories":[{"name":"JavaWeb","slug":"JavaWeb","permalink":"http://yoursite.com/categories/JavaWeb/"}],"tags":[{"name":"JavaWeb","slug":"JavaWeb","permalink":"http://yoursite.com/tags/JavaWeb/"},{"name":"SSM框架","slug":"SSM框架","permalink":"http://yoursite.com/tags/SSM%E6%A1%86%E6%9E%B6/"}]},{"title":"MyBatis映射标签resultMap与resultType、parameterMap与 parameterType","date":"2020-07-21T10:49:06.000Z","path":"2020/07/21/MyBatis映射标签resultMap与resultType、parameterMap与-parameterType/","text":"MyBatis映射标签1234567&lt;?xml version=\"1.0\" encoding=\"UTF-8\" ?&gt;&lt;!DOCTYPE mapper PUBLIC \"-//mybatis.org//DTD Mapper 3.0//EN\" \"http://mybatis.org/dtd/mybatis-3-mapper.dtd\"&gt;&lt;mapper namespace=\"com.dvms.dao.UserDao\"&gt;....&lt;/mapper&gt; 123456789101112131415161718192021222324252627282930313233&lt;?xml version=\"1.0\" encoding=\"UTF-8\" ?&gt;&lt;!DOCTYPE mapper PUBLIC \"-//mybatis.org//DTD Mapper 3.0//EN\" \"http://mybatis.org/dtd/mybatis-3-mapper.dtd\"&gt;&lt;mapper namespace=\"com.dvms.dao.UserDao\"&gt;&lt;!--注册/新增用户--&gt; &lt;insert id=\"save\" parameterType=\"User\"&gt; insert into user (id,username,password,sex,phone,email,role) values (#&#123;id&#125;,#&#123;username&#125;,#&#123;password&#125;,#&#123;sex&#125;,#&#123;phone&#125;,#&#123;email&#125;,#&#123;role&#125;) &lt;/insert&gt;&lt;!--登录验证--&gt; &lt;select id=\"login\" resultType=\"User\"&gt; select id,username,password,sex,phone,email,role from user where username =#&#123;username&#125; and password =#&#123;password&#125; &lt;/select&gt;&lt;!--查询所有用户--&gt; &lt;select id=\"findAlluser\" resultType=\"User\"&gt; select id,username,password,sex,phone,email,role from user &lt;/select&gt;&lt;!--删除用户--&gt; &lt;delete id=\"delete\" parameterType=\"String\"&gt; delete from user where id=#&#123;id&#125; &lt;/delete&gt;&lt;!--修改用户信息--&gt; &lt;!--查到要修改的用户信息--&gt; &lt;select id=\"update\" parameterType=\"String\" resultType=\"User\"&gt; select id,username,password,sex,phone,email,role from user where id=#&#123;id&#125; &lt;/select&gt; &lt;!--修改用户信息--&gt; &lt;update id=\"add\" parameterType=\"User\"&gt; update user set username=#&#123;username&#125;,password=#&#123;password&#125;,sex=#&#123;sex&#125;,phone=#&#123;phone&#125;,email=#&#123;email&#125;,role=#&#123;role&#125; where id=#&#123;id&#125; &lt;/update&gt;&lt;/mapper&gt; 在MyBatis中，输入与输出都是相对于数据库而言，我们通过parameterType完成输入映射(指将值映射到sql语句的占位符中，值的类型与dao层响应方法的参数类型一致)，通过resultType完成输出映射(从数据库中输出，通过dao层的方法查询到的数据输出到pojo对象（实体类entity）中)。 1. 输入映射（往数据库输入）parameterMap（不常用）与 parameterType（常用） ParameterMap和resultMap类似，表示将查询结果集中列值的类型一一映射到java对象属性的类型上，在开发过程中不推荐这种方式。 一般使用parameterType直接将查询结果列值类型自动对应到java对象属性类型上，不再配置映射关系一一对应。 2. 输出映射（从数据库输出）resultMap与resultType（常用） 两者都是表示查询结果集与java对象之间的一种关系，处理查询结果集，映射到java对象。 resultMap表示将查询结果集中的列一一映射到bean对象的各个属性。映射的查询结果集中的列标签可以根据需要灵活变化，并且，在映射关系中，还可以通过typeHandler设置实现查询结果值的类型转换，比如布尔型与0/1的类型转换。 #{}和${}的使用resultMap和ParameterMap书写拼写要使用#{}，resultType 和parameterType类型使用${}，（一般是用#{}）使用例子如下： Select ID，COMMAND from Message where COMMAND=#{command} Select ID，COMMAND from Message where COMMAND=‘${command}’ 前者解析为： Select ID，COMMAND from Message where COMMAND=？具有预编译效果后者解析为： Select ID，COMMAND from Message where COMMAND=段子 不具有预编译效果 在Mybatis中传递多个参数要做参数的绑定（@Param）不写parameterType也可以运行,因为Mybatis能自动识别，但返回值类型不能不写!!Mybatis自动识别入参对象, 传入单个map或单个对象,无需写@Param注解 如@Param(“map”) Map&lt;String, Object&gt; map那么什么时候必须在mapper接口上写@Param注解呢, mapper接口中有多个参数(每个对象或参数都要加@Param注解), 或一个 String, 必须使用@Param注解,END","updated":"2020-07-23T02:55:47.737Z","categories":[],"tags":[]},{"title":"Spring框架常用注解","date":"2020-07-21T10:17:34.000Z","path":"2020/07/21/Spring框架常用注解/","text":"Spring常用注解 @Controller@Controller 用来响应页面，表示当前的类为控制器。在SpringMVC 中，控制器Controller 负责处理由DispatcherServlet 分发的请求，它把用户请求的数据经过业务处理层处理之后封装成一个Model ，然后再把该Model 返回给对应的View 进行展示。在SpringMVC 中提供了一个非常简便的定义Controller 的方法，你无需继承特定的类或实现特定的接口，只需使用@Controller 标记一个类是Controller ，然后使用@RequestMapping 和@RequestParam 等一些注解用以定义URL 请求和Controller 方法之间的映射，这样的Controller 就能被外界访问到。此外Controller 不会直接依赖于HttpServletRequest 和HttpServletResponse 等HttpServlet 对象，它们可以通过Controller 的方法参数灵活的获取到。@Controller 用于标记在一个类上，使用它标记的类就是一个SpringMVC Controller 对象。分发处理器将会扫描使用了该注解的类的方法，并检测该方法是否使用了@RequestMapping 注解。@Controller 只是定义了一个控制器类，而使用@RequestMapping 注解的方法才是真正处理请求的处理器。单单使用@Controller 标记在一个类上还不能真正意义上的说它就是SpringMVC 的一个控制器类，因为这个时候Spring 还不认识它。那么要如何做Spring 才能认识它呢?这个时候就需要我们把这个控制器类交给Spring 来管理。 @RestControllerSpring4之后新加入的注解，原来返回json需要@ResponseBody和@Controller配合，表明当前类是控制器且返回的是一组数据，不是页面。@RestController是@ResponseBody和@Controller的组合注解，推荐直接使用@RestController注解来处理http请求。 12345678@RestControllerpublic class HelloController &#123; @RequestMapping(value=\"/hello\",method= RequestMethod.GET) public String sayHello()&#123; return \"hello\"; &#125;&#125; 123456789@Controller@ResponseBodypublic class HelloController &#123; @RequestMapping(value=\"/hello\",method= RequestMethod.GET) public String sayHello()&#123; return \"hello\"; &#125;&#125; @Autowired@Autowired的作用是将其他的类，接口引入，类似于之前的类的初始化等，用这个注解，类中或接口的方法就可以直接调用了。@Autowired顾名思义，就是自动装配，其作用是为了消除代码Java代码里面的getter/setter与bean属性中的property。当然，getter看个人需求，如果私有属性需要对外提供的话，应当予以保留。@Resource的作用相当于@Autowired @ResponseBody作用: 该注解用于将Controller的方法返回的对象，通过适当的HttpMessageConverter转换为指定格式后，写入到Response对象的body数据区。当返回的数据不是html标签的页面，而是其他某种格式的数据时(如json、xml等)时使用。 @RequestMapping （配置url映射）@RequestMapping如果没有指定请求方式，将接收Get,Post,Head,Options等所有的请求方式。@RequestMapping此注解即可以作用在控制器的某个方法上，也可以作用在此控制器类上。当前台界面调用Controller处理数据时候告诉控制器怎么操作有3种情形：1.当控制器在类级别上添加@RequestMapping注解时，这个注解会应用到控制器的所有处理器方法上。处理器方法上的@RequestMapping注解会对类级别上的@RequestMapping的声明进行补充。2.@RequestMapping作用在处理器方法上。3.@RequestMapping同时作用在类级别和处理器方法上。所响应的url=localhost:8080/updata_setting/updata @RequestMapping注解属性作用：简化常用的HTTP方法的映射，并更好地表达被注解方法的语义。RequestMapping注解有六个属性：1、 value， method; value: 指定请求的实际地址，指定的地址可以是URI Template 模式(后面将会说明); method: 指定请求的method类型， GET、POST、PUT、DELETE等;常用： GET、POST组合注解： @GetMapping @RequestMapping(method = RequestMethod.GET)的简写作用：对应查询，表明是一个查询URL映射 @PostMapping @RequestMapping(method =RequestMethod.POST)的简写作用：对应增加，表明是一个增加URL映射 @PutMapping@RequestMapping(method = RequestMethod.PUT)的简写作用：对应更新，表明是一个更新URL映射 @DeleteMapping @RequestMapping(method = RequestMethod.DELETE)的简写作用：对应删除，表明是一个删除URL映射 2、consumes，produces consumes: 指定处理请求的提交内容类型(Content-Type)，例如application/json, text/html; produces: 指定返回的内容类型，仅当request请求头中的(Accept)类型中包含该指定类型才返回; 3、params，headers params: 指定request中必须包含某些参数值是，才让该方法处理。 headers: 指定request中必须包含某些指定的header值，才能让该方法处理请求。 @PathVaribale通过@PathVariable注解来获取URL中的参数时的前提条件是我们知道url的格式时怎么样的。只有知道url的格式，我们才能在指定的方法上通过相同的格式获取相应位置的参数值。1.获取url中的单个参数（如id） 12345678@RestControllerpublic class HelloController &#123; @RequestMapping(value=\"/hello/&#123;id&#125;\",method= RequestMethod.GET) public String sayHello(@PathVariable(\"id\") Integer id)&#123; return \"id:\"+id; &#125;&#125; 2.获取url有多个参数 12345678@RestControllerpublic class HelloController &#123; @RequestMapping(value=\"/hello/&#123;id&#125;/&#123;name&#125;\",method= RequestMethod.GET) public String sayHello(@PathVariable(\"id\") Integer id,@PathVariable(\"name\") String name)&#123; return \"id:\"+id+\" name:\"+name; &#125;&#125; @RequestParam作用：获取请求参数的值@RequestParam注解给允许用户不输入参数时，使用默认值； @RequestBody如果传输的是单层json对象，我们后台可以直接用 @RequestParam接收。如果传输的是多层嵌套json对象，这个时候会就会出现数据丢失问题，@ResponseBody很好的解决了这个问题，它会把前台传输过来的json转化为后台对应的对象；@RequestBody接收的是一个Json对象的字符串，而不是一个Json对象。（易出错）然而在ajax请求往往传的都是Json对象，用JSON.stringify(data)的方式就能将对象变成字符串。同时ajax请求的时候也要指定dataType: “json”,contentType:”application/json” 这样就可以轻易的将一个对象或者List传到Java端，使用@RequestBody即可绑定对象或者List。 12345678910111213141516171819var vm = new Vue(&#123; el: '#updata', data: &#123; updata_setting: &#123;&#125; &#125;, methods: &#123; Save:function(ev)&#123; var url = \"../updata_setting/updata\"; $.ajax(&#123; type: \"POST\", url: url, data: JSON.stringify(vm.updata_setting), success: function(r)&#123; alert('操作成功！'); &#125; &#125;); &#125; &#125;&#125;); @Service用于标注业务层组件，位于service实现层：形如：@Service(“xxxService”) @Override@Override是伪代码,表示重写(当然不写也可以),不过写上有如下好处:1、可以当注释用,方便阅读。2、编译器可以给你验证@Override下面的方法名是否是你父类中所有的,如果没有则报错。比如你如果没写@Override而你下面的方法名又写错了,这时你的编译器是可以编译通过的(它以为这个方法是你的子类中自己增加的方法)。 @Repository@Repository用于标注数据访问组件，即dao层如果 Web 应用程序采用了经典的三层分层结构的话，最好在持久层、业务层和控制层分别采用上述注解对分层中的类进行注释。@Component泛指组件，当组件不好归类的时候，我们可以使用这个注解进行标注。 END","updated":"2020-07-23T02:53:03.271Z","categories":[],"tags":[]}]