[{"title":"Vue常用指令及实例","date":"2020-08-03T10:33:08.000Z","path":"2020/08/03/Vue常用指令及实例/","text":"Hello Vue!","updated":"2020-08-03T10:55:40.814Z","categories":[{"name":"前端","slug":"前端","permalink":"http://yoursite.com/categories/%E5%89%8D%E7%AB%AF/"}],"tags":[{"name":"Vue","slug":"Vue","permalink":"http://yoursite.com/tags/Vue/"},{"name":"Javaweb","slug":"Javaweb","permalink":"http://yoursite.com/tags/Javaweb/"}]},{"title":"Vue.js使用实例","date":"2020-08-03T10:32:48.000Z","path":"2020/08/03/Vue-js使用实例/","text":"Hello Vue! Vue(读音/vju/， 类似于view) 是一套用于构建用户界面的渐进式框架， 发布于2014年2月。与其它大型框架不同的是， Vue被设计为可以自底向上逐层应用。Vue的核心库只关注视图层， 不仅易于上手， 还便于与第三方库(如：vue-router，vue-resource，vue x) 或既有项目整合。Vue==不支持IE 8及以下版本==， Vue使用了IE 8无法模拟的ECMAScript 5特性。但它支持所有兼容ECMAScript 5的浏览器。链接: Vue官网 MVVM模式Model：模型层， 在这里表示JavaScript对象。View：视图层， 在这里表示DOM(HTML操作的元素)。ViewModel：连接视图和数据的中间件， Vue.js就是MVVM中的View Model层的实现者。在MVVM架构中， 是不允许数据和视图直接通信的， 只能通过ViewModel来通信， 而View Model就是定义了一个Observer观察者；ViewModel能够观察到数据的变化， 并对视图对应的内容进行更新ViewModel能够监听到视图的变化， 并能够通知数据发生改变Vue.js就是一个MVVM的实现者， 核心就是==实现了DOM监听与数据绑定==。 Vue.js优点轻量级， 体积小是一个重要指标。Vue.js压缩后有只有20多kb(Angular压缩后56kb+，React压缩后44kb+)移动优先。更适合移动端， 比如移动端的Touch事件易上手，学习曲线平稳，文档齐全吸取了Angular(模块化) 和React(虚拟DOＭ) 的长处， 并拥有自己独特的功能，如：计算属性开源，社区活跃度高…… Vue使用实例123456789101112131415161718192021222324252627282930&lt;!DOCTYPE html&gt;&lt;html&gt;&lt;head&gt;&lt;meta charset=\"utf-8\"&gt;&lt;title&gt;Vue使用实例&lt;/title&gt;&lt;script src=\"https://unpkg.com/vue/dist/vue.js\"&gt;&lt;/script&gt;&lt;/head&gt;&lt;body&gt;&lt;div id=\"app\"&gt; &lt;h1&gt;site : &#123;&#123;site&#125;&#125;&lt;/h1&gt; &lt;h1&gt;url : &#123;&#123;url&#125;&#125;&lt;/h1&gt; &lt;h1&gt;&#123;&#123;details()&#125;&#125;&lt;/h1&gt;&lt;/div&gt;&lt;script type=\"text/javascript\"&gt; var vm = new Vue(&#123; el: '#vue_det', data: &#123; site: \"菜鸟\", url: \"www.runoob.com\", alexa: \"10000\" &#125;, methods: &#123; details: function() &#123; return this.site + \" - 学的不仅是技术，更是梦想！\"; &#125; &#125; &#125;)&lt;/script&gt;&lt;/body&gt;&lt;/html&gt; 注意事项：首先在使用时要导入vue,js;然后需要创建构造器： 123var vm = new Vue&#123;...&#125; 1.el 参数在 Vue 构造器中有一个el 参数，它是 DOM 元素中的 id。在上面实例中 id 为 app，在 div 元素中： 123&lt;div id = \"app\"&gt;...&lt;/div&gt; 这意味着我们接下来的改动==全部在以上指定的 div 内，div 外部不受影响==。2.定义数据对象data 用于定义属性，实例中有三个属性分别为：site、url、alexa。3.定义方法methods 用于定义的函数，可以通过 return 来返回函数值。4.输出两个花括号用于输出对象属性和函数返回值。如： 1&lt;h1&gt;url : &#123;&#123;url&#125;&#125;&lt;/h1&gt; 当一个 Vue 实例被创建时，它向 Vue 的响应式系统中加入了其 data 对象中能找到的所有的属性。当这些属性的值发生改变时，html 视图将也会产生相应的变化。 END","updated":"2020-08-03T10:57:29.943Z","categories":[{"name":"前端","slug":"前端","permalink":"http://yoursite.com/categories/%E5%89%8D%E7%AB%AF/"}],"tags":[{"name":"Vue","slug":"Vue","permalink":"http://yoursite.com/tags/Vue/"},{"name":"Javaweb","slug":"Javaweb","permalink":"http://yoursite.com/tags/Javaweb/"}]},{"title":"前端知识体系","date":"2020-08-03T10:32:47.000Z","path":"2020/08/03/前端知识体系/","text":"Hello Vue! 前端知识体系前端主要围绕逻辑（判断、循环）、事件（浏览器事件：window document;Dom事件：增删改及遍历节点元素内容；jQurey的应用）、视图（HTML、CSS）、通信（AJAX）四个方面展开。 前端三要素HTMLHTML（结构）：超文本标记语言（Hyper Text Markup Language），决定网页的结构和内容。 CSSCSS（表现）：层叠样式表（Cascading Style Sheets），设定网页的表现样式。CSS层叠样式表是一门标记语言，并不是编程语言，因此不可以自定义变量，不可以引用等，换句话说就是不具备任何语法支持，它主要缺陷如下： 语法不够强大，比如无法嵌套书写，导致模块化开发中需要书写很多重复的选择器； 没有变量和合理的样式复用机制，使得逻辑上相关的属性值必须以字面量的形式重复输出，导致难以维护； 导致在工作中无端增加了许多工作量。为了解决这个问题，前端开发人员会使用一种称之为【CSS预处理器】的工具,提供CSS缺失的样式层复用机制、减少冗余代码，提高样式代码的可维护性。大大的提高了前端在样式上的开发效率。什么是CSS预处理器?CSS预处理器定义了一种新的语言，其基本思想是，用一种专门的编程语言，为CSS增加了一些编程的特性，将CSS作为目标生成文件，然后开发者就只需要使用这种语言进行CSS的编码工作。转化成通俗易懂的话来说就是“用一种专门的编程语言，进行Web页面样式设计，再通过编译器转化为正常的CSS文件，以供项目使用”。常用的CSS预处理器有哪些? SASS：基于Ruby ，通过服务端处理，功能强大。解析效率高。需要学习Ruby语言，上手难度高于LESS。 LESS：基于NodeJS，通过客户端处理，使用简单。功能比SASS简单，解析效率也低于SASS，但在实际开发中足够了，所以如果我们后台人员如果需要的话，建议使用LESS。链接: LESS文档12345678LESS程序实例：@width: 10px;@height: @width + 10px;#header &#123; width: @width; height: @height;&#125; JSJavaScript（行为）：是一种弱类型脚本语言，其源码不需经过编译，而是由浏览器解释运行，用于控制网页的行为。 Native 原生JS开发原生JS开发，也就是让我们按照【ECMAScript】标准的开发方式，简称ES，特点是所有浏览器都支持。截至到当前，ES标准以发布如下版本： ES3 ES4（内部，未正式发布） ES5（全浏览器支持） ES6（常用，当前主流版本：webpack打包成为ES5支持） ES7 ES8 ES9（草案阶段） 区别就是逐步增加新特性。 TypeScript是一种由微软开发的自由和开源的编程语言。它是JavaScript的一个超集， 而且本质上向这个语言添加了可选的静态类型和基于类的面向对象编程。由安德斯·海尔斯伯格(C#、Delphi、TypeScript之父； .NET创立者) 主导。该语言的特点就是除了具备ES的特性之外还纳入了许多不在标准范围内的新特性，所以会导致很多浏览器不能直接支持TypeScript语法， 需要==编译后(编译成JS)== 才能被浏览器正确执行。 JavaScript框架JQuery：大家熟知的JavaScript库，优点就是简化了DOM操作，缺点就是DOM操作太频繁，影响前端性能；在前端眼里使用它仅仅是为了兼容IE6，7，8；Vue：一款渐进式 JavaScript 框架，所谓渐进式就是逐步实现新特性的意思，如实现模块化开发、路由、状态管理等新特性。其特点是综合了 Angular（模块化）和React(虚拟 DOM) 的优点；Axios：前端通信框架；因为 Vue 的边界很明确，就是为了处理 DOM，所以并不具备通信能力，此时就需要额外使用一个通信框架与服务器交互；当然也可以直接选择使用jQuery 提供的AJAX 通信功能；Angular：Google收购的前端框架，由一群Java程序员开发，其特点是将后台的MVC模式搬到了前端并增加了模块化开发的理念，与微软合作，采用了TypeScript语法开发；React：Facebook 出品，一款高性能的JS前端框架；特点是提出了新概念 【虚拟DOM】用于减少真实 DOM 操作，在内存中模拟 DOM操作，有效的提升了前端渲染效率；缺点是使用复杂，因为需要额外学习一门【JSX】语言； UI框架Ant-Design：阿里巴巴出品，基于React的UI框架ElementUI、iview、ice：饿了么出品，基于Vue的UI框架（必学）BootStrap：Teitter推出的一个用于前端开发的开源工具包（必学）AmazeUI：又叫“妹子UI”，一款HTML5跨屏前端框架JavaScript构建工具Babel：JS编译工具，主要用于浏览器不支持的ES新特性，比如用于编译TypeScriptWebPack：模块打包器，主要作用就是打包、压缩、合并及按序加载 Node.js前端人员为了方便开发也需要掌握一定的后端技术但我们Java后台人员知道后台知识体系极其庞大复杂，所以为了方便前端人员开发后台应用，出现Node.js。Node.js框架及项目管理工具如下： Express：Node JS框架 Koa：Express简化版 NPM：项目综合管理工具，类似于Maven YARN：NPM的替代方案，类似于Maven和Gradle的关系 MVC为了降低开发的复杂度，以后端为出发点， 比如：Struts、Spring MVC等框架的使用， 就是后端的MVC时代；以SpringMVC流程为例：发起请求到前端控制器(Dispatcher Servlet)前端控制器请求HandlerMapping查找Handler，可以根据xml配置、注解进行查找处理器映射器HandlerMapping向前端控制器返回Handler前端控制器调用处理器适配器去执行Handler处理器适配器去执行HandlerHandler执行完成给适配器返回ModelAndView处理器适配器向前端控制器返回ModelAndView，ModelAndView是SpringMvc框架的一个底层对象，包括Model和View前端控制器请求视图解析器去进行视图解析，根据逻辑视图名解析成真正的视图(JSP)视图解析器向前端控制器返回View前端控制器进行视图渲染，视图渲染将模型数据(在ModelAndView对象中)填充到request域前端控制器向用户响应结果优点:MVC是一个非常好的协作模式， 能够有效降低代码的耦合度从架构上能够让开发者明白代码应该写在哪里。为了让View更纯粹， 还可以使用Thymeleaf、Frree marker等模板引擎， 使模板里无法写入Java代码， 让前后端分工更加清晰。缺点:前端开发重度依赖开发环境，开发效率低，这种架构下，前后端协作有两种模式：第一种是前端写DEMO， 写好后， 让后端去套模板。好处是DEMO可以本地开发， 很高效。不足是还需要后端套模板，有可能套错，套完后还需要前端确定，来回沟通调整的成本比较大。 基于AJAX带来的SPA时代SPA模式下， 前后端的分工非常清晰， 前后端的关键协作点是AJAX接口。看起来是如此美妙， 但回过头来看看的话， 这与JSP时代区别不大。复杂度从服务端的JSP里移到了浏览器的JavaScript，浏览器端变得很复杂。类似Spring MVC. 前端为主的MV*时代此处的MV*模式如下： MVC(同步通信为主) ：Model、View、Controller MVP(异步通信为主) ：Model、View、Presenter MVVM(异步通信为主)：Model、View、View Model为了降低前端开发复杂度，涌现了大量的前端框架，比如：Angular.js、React.js、Vue.js等， 这些框架总的原则是先按类型分层， 比如Templates、Controllers、Models， 然后再在层内做切分。前后端分离的开发思想主要是基于Soc(关注度分离原则)，上面种种模式，都是让前后端的职责更清晰，分工更合理高效。 END","updated":"2020-08-03T10:41:11.929Z","categories":[{"name":"前端","slug":"前端","permalink":"http://yoursite.com/categories/%E5%89%8D%E7%AB%AF/"}],"tags":[{"name":"Vue","slug":"Vue","permalink":"http://yoursite.com/tags/Vue/"},{"name":"Javaweb","slug":"Javaweb","permalink":"http://yoursite.com/tags/Javaweb/"}]},{"title":"PyQt5界面控件自适应大小","date":"2020-08-03T10:32:45.000Z","path":"2020/08/03/PyQt5界面控件自适应大小/","text":"Hello PyQt5! PyQt5My Environment PyCharm 2019.2 Qt Desinger PyUIC实现效果界面控件自适应大小，点击窗口放大后，界面控件大小随之发生变化。实例1点击窗口放大后： 实例2点击窗口放大后： 实现过程 首先需要利用Qt Desinger设计大致的控件布局； 点击窗口layout选择栅格布局（局部和全局自适应均适用，局部自适应最好把控件放到一个frame中，之后进行布局）； 点击minnumsize和maxnumsize调整控件大小，有时候需要利用一些填充的lable等控件来保证放到后布局合理； 通过预览Ctrl+R查看布局情况。 所有操作均在==Qt Desinger==中进行。 END","updated":"2020-08-03T10:36:13.245Z","categories":[{"name":"PyQt5","slug":"PyQt5","permalink":"http://yoursite.com/categories/PyQt5/"}],"tags":[{"name":"工具","slug":"工具","permalink":"http://yoursite.com/tags/%E5%B7%A5%E5%85%B7/"},{"name":"python","slug":"python","permalink":"http://yoursite.com/tags/python/"}]},{"title":"Python编程小案例练习","date":"2020-07-30T07:03:39.000Z","path":"2020/07/30/Python编程基础之小案例练习/","text":"Hello Python! 1. 小说中的单词频次的统计Re库：Re库是Python的标准库，主要用于字符串匹配。| 方法 | 解释说明||–|–|| re.search() |在一个字符串中搜索匹配正则表达式的第一个位置，返回match对象 || re.match() | 从一个字符串的开始位置起匹配正则表达式，返回match对象 ||re.findall() | 搜索字符串，以列表类型返回全部能匹配的字符串|| re.split() | 将一个字符串按照正则表达式匹配结果进行分割，返回列表类型 || re.finditer() | 搜索字符串，返回一个匹配结果的迭代类型，每个迭代元素是match对象 || re.sub() | 字符串中替换所有匹配正则表达式的子串，返回替换后的字符串 |代码如下： 1234567891011121314151617181920# 小说中的单词频次的统计import re # 导入正则表达式库f = open('LOVE.txt', 'r') # 以只读的方式打开文件，注意文件路径txt = f.read() # 读取进来的数据类型是字符串f.close() # 关闭文件，释放内存txt = txt.lower() # 将所有字母变为小写# 去除小说中的标点符号(将txt文件中的,.?:\"\\'!-用空代替)txt = re.sub('[,.?:\"\\'!-]', '', txt) words = txt.split() # 单词分割word_sq = &#123;&#125; # 单词频次统计容器# 单词频次统计for i in words: if i not in word_sq.keys(): word_sq[i] = 1 else: word_sq[i] += 1# 利用键值对中的 值 来进行降序排列a = sorted(word_sq.items(), key=lambda x: x[1], reverse=True) print('该小说中的单词频次为：', a) 结果为：该小说中的单词频次为： [(‘the’, 7346), (‘and’, 4602), (‘of’, 3490), (‘to’, 3104), (‘a’, 3033),…..] 2. 自定义求序列偶数个数的函数1234567891011# 自定义函数:求序列中偶数个数def even(x): z = 0 for i in x: if i % 2 == 0: # if i % 2 != 0: 求奇数 z += 1 print('偶数位置：', [i]) return za = even([1, 2, 3, 4, 5, 6]) # 调用函数even()print('序列中偶数的个数为：', a) 3. 求曲边图形的面积将各小矩形的高度存放至一列表y中，将各高度x乘以宽度width，得各矩形面积，然后求和s/S。代码如下： 1234567891011121314151617# 求曲边图形的面积import math # 导入数学库n = 20000 # 分块数width = 2*math.pi/n # 宽度# 方法一：利用for循环构建x = [] # 宽y = [] # 高for i in range(n): x.append(i*width)for i in x: y.append(abs(math.sin(i)))S = sum(y)*widthprint('曲边图形的面积为：', '%.2f' % S)# 方法二：利用列表推导式构建s = [abs(math.sin(i*width))*width for i in range(n)]print('曲边图形的面积为：', sum(s)) 结果为：曲边图形的面积为： 4.00曲边图形的面积为： 3.999999999671082 4. 冒泡排序对序列[17.00, 21.50, 65.07, 20.91, 2.00, 30.16, -10.01, 27.45]]按从小到大顺序进行排列 12345678# 冒泡排序x = [17.00, 21.50, 65.07, 20.91, 2.00, 30.16, -10.01, 27.45]n = len(x) # 获取数组的长度for i in range(n): for j in range(i): if x[j] &gt; x[i]: x[i], x[j] = x[j], x[i]print('排序结果：', x) 排序结果： [-10.01, 2.0, 17.0, 20.91, 21.5, 27.45, 30.16, 65.07]","updated":"2020-07-30T07:04:58.290Z","categories":[{"name":"Python编程基础","slug":"Python编程基础","permalink":"http://yoursite.com/categories/Python%E7%BC%96%E7%A8%8B%E5%9F%BA%E7%A1%80/"}],"tags":[{"name":"python","slug":"python","permalink":"http://yoursite.com/tags/python/"},{"name":"PyCharm","slug":"PyCharm","permalink":"http://yoursite.com/tags/PyCharm/"}]},{"title":"Python语言的基础知识（下）","date":"2020-07-30T07:02:24.000Z","path":"2020/07/30/Python编程基础之Python语言的基础知识（下）/","text":"Hello Python! Python常用操作符： 算术操作符 赋值操作符 比较操作符 逻辑操作符 算术操作符一般会返回一个数，而比较和逻辑操作符会返回布尔值True或False。 逻辑控制： 1234567# Python逻辑控制符a = 1 &lt; 2b = 1 &lt; 2 &lt; 3c = 'Name' == 'name'd = 'M' in 'magic'e = 42 != 42print(a, b, c, d, e) 结果为：True True False False False 字符串：注意：“任何在这双引号之间的文字都属于String”单引号其实和双引号完全一样‘’’三个引号被用于长段文字或说明,只要引号不结束,你就可以任意换行’’’==字符串属不可变数据类型==基本用法： 合并：’char1’+’char2’+’char3’ 重复：’word’ * 3 转换：int(string) # 字符转整型 切片与索引：str[0] str[-4] str[1:4] str[3:] str[:3] 字符串的方法：应用举例： 123456789101112131415# 字符串基本用法string = 'My Name'a = string[0] # 字符串的索引b = string[:2] # 字符串的前两个c = string * 2 # 字符串重复两次d = string + ' is 韩梅梅！' # 字符串合并f = string.split(sep=',') # 字符串通过‘ ， ’截取g = string.lower() # 将字符串所有大写字符变为小写# string[0] = 'Y' # 非法操作，字符串属于不可变的数据类型print('1.', a, '2.', b, '3.', c, '4.', d, '5.', f, '6.', g) 结果为：1. M 2. My 3. My nameMy name 4. My name is 韩梅梅！ 5. [‘My name’] 6. my name 字典：1、键－值成对出现；2、键不能重复；3、键不可更改，值可修改；4、通过键来索引值。 12345678910# 字典基本用法dic = &#123;'Name': 'C J W', 'Sex': 'man', 'Age': '108', 'Hobby': 'Python'&#125;My_name = dic['Name'] # 字典中的元素无先后顺序，通过键来访问值dic['Age'] = 100dic['My love world'] = '人生苦短，我用 Python !' # 新增键值对dic.update(&#123;'Math': 100, 'Chinese': 100&#125;) # 新增键值对del dic['Sex']print('我的名字是：', My_name)print('输出字典内容:', dic)print('执行删除键值对操作：', dic) 结果为：我的名字是： C J W输出字典内容: {‘Name’: ‘C J W’, ‘Age’: 100, ‘Hobby’: ‘Python’, ‘My love world’: ‘人生苦短，我用 Python !’, ‘Math’: 100, ‘Chinese’: 100}执行删除键值对操作： {‘Name’: ‘C J W’, ‘Age’: 100, ‘Hobby’: ‘Python’, ‘My love world’: ‘人生苦短，我用 Python !’, ‘Math’: 100, ‘Chinese’: 100} 文件操作：1.文件访问模式2.文件的操作方法在文件中读 / 写数据： 12'''在Python中，使用open函数，可以打开一个已经存在的文件，或者创建一个新文件'''f = open('test.txt', 'w') # open(文件名，访问模式) 1234'''使用write()可以完成向文件写入数据'''f = open('helloworld.txt', 'w')f.write('hello world,\\n')f.close() 123456'''使用read(num)可以从文件中读取数据，num表示要从文件中读取的数据的长度（单位是字节），如果没有传入num，那么就表示读取文件中所有的数据'''f = open('helloworld.txt', 'r')word = f.read(10)word t = f.read()print(word)f.close() 1234'''readlines可以按照行的方式把整个文件中的内容进行一次性读取，并且返回的是一个列表，其中每一行的数据为一个元素'''f = open('helloworld.txt', 'r')word = f.readlines()print(type(word)) Python函数：在Python中有很多内建函数如：print() input() int() etc 自定义函数的方式： 1234567891011121314151617# 自定义函数用法# 第一种方式def Sum(x, y): return x + ya = Sum(1, 2)print('第一种方式:', a)# 第二种方式Y = lambda x: x ** 2X = lambda x: x[1]b = Y(10)c = X(['123456', 0])print('第二种方式:', b, c) Python –面向对象编程 类 对象 属性 方法 123456789101112131415# 面向对象编程class Human: def __init__(self, Age=None, Sex=None): # __init__ 一般是类的初始化函数,类似于构造函数 self.age = Age # 属性 self.sex = Sex def square(self, x): # 方法 return x**2CJW = Human(Age=24, Sex='男') # 实例化类a = CJW.square(10) # 调用方法square，面向对象CJWb = CJW.agec = CJW.sexprint(a, b, c) 模块和第三方类库安装与应用安装可参考：Python项目之类库和模块的安装导入：（模块可自定义但是==不要与原有模块和类库重名==）import packagenameimport packagename as new_name # 将包名如numpy用py代替from packagename import function_namefrom packagename import * # 导入包的全部函数（不推荐）调用：packagename.function_namenew_name. function_namefunction_name END","updated":"2020-07-30T07:05:18.608Z","categories":[{"name":"Python编程基础","slug":"Python编程基础","permalink":"http://yoursite.com/categories/Python%E7%BC%96%E7%A8%8B%E5%9F%BA%E7%A1%80/"}],"tags":[{"name":"python","slug":"python","permalink":"http://yoursite.com/tags/python/"},{"name":"PyCharm","slug":"PyCharm","permalink":"http://yoursite.com/tags/PyCharm/"}]},{"title":"Python语言的基础知识（上）","date":"2020-07-30T07:02:22.000Z","path":"2020/07/30/Python编程基础之Python语言的基础知识（上）/","text":"Hello Python! 第一个Python程序在.txt文件中写入“hello world” 12345# “hello world”str = 'hello world'file = open('../Users/CJW/Desktop/FIRSTCODE.txt','w') # 以只写的方式打开TXT文件file.write(str) # 在文件中写入hello worldfile.close() # 关闭文档，释放内存 Python固定语法Python 中的变量不需要声明，==每个变量在使用前都必须赋值==，变量赋值以后该变量才会被创建。变量一般由==字母、数字和下划线==组成；通常第一个字符是字母或下划线‘_’；区分大小写。 Python 3 源码文件以 UTF-8 编码，所有字符串都是 unicode 字符串。或在脚本首行指定编码方式： -- coding: GB18030 -- 语法格式：代码块==以Tab或空格缩进==限制，而不以花括号”{}”等分割代码。 注释：单行注释：# 注释多行注释：’’’ 多行注释 ‘’’ 多变量赋值： 1234# 多变量赋值实例A,B,C = \"java\",\"c++\",\"python\"a = b = c = 1 print(A, B, C, a, b, c) [0:a] 左闭右开 1del cjw[0:2] # 删除数组中的前两个 标准数据类型：Number（int float bool complex）PS:1.整型无长短之分 2.布尔值:True, FalseStringListDictionarySets（集合）Tuple（元祖） 常用函数： 列表（List）：1、列表中每个元素都是==可变==的；2、列表中的元素是==有序==的，每个元素对应一个位置；3、列表可以容纳Python中的==任何对象==。 123456789# List实例cjw = [ 24, 'Tree’, print('男'), True, [24,100],]print(cjw[0]) 列表常用函数：List的增删改查: 1234567891011# List的增删改查cjw = [ 24, '男', True, A, [24,100] ]cjw.insert(0,'666') # 第一个元素插入 666del cjw[-1] # 删除 [24,100]del cjw[0:2] # 删除数组中的 24 和 ‘男’ 循环语句:在Python中没有do..while循环(==注意冒号和缩进==)for循环: 可以遍历任何序列的项目，如一个列表或者一个字符串eg1: 123List = [2,'a',True,3.4]for i in List: print(i) eg2: 12for i in range(10): print(i) while 1234while 判断条件： 语句else: 语句 while循环体中只有一条语句，你可以将该语句与while写在==同一行中==。break 语句可以跳出 for 和 while 的循环体，跳出后任何对应的循环 else 块将不执行。continue语句用来跳过当前循环块中的剩余语句，然后继续进行下一轮循环。pass是空语句，是为了保持程序结构的完整性，一般用做占位语句。 列表推导式： 123a = []a = [i**2 for i in range(1,10)]print(a) 结果：[1, 4, 9, 16, 25, 36, 49, 64, 81]","updated":"2020-07-30T07:05:41.860Z","categories":[{"name":"Python编程基础","slug":"Python编程基础","permalink":"http://yoursite.com/categories/Python%E7%BC%96%E7%A8%8B%E5%9F%BA%E7%A1%80/"}],"tags":[{"name":"python","slug":"python","permalink":"http://yoursite.com/tags/python/"},{"name":"PyCharm","slug":"PyCharm","permalink":"http://yoursite.com/tags/PyCharm/"}]},{"title":"Python语言的输入输出","date":"2020-07-30T07:02:20.000Z","path":"2020/07/30/Python编程基础之Python语言的输入输出/","text":"Hello Python! Python和其他高级语言一样，程序的基本构架都会有输入和输出部分: 1. 输出 在Python语言中，实现数据的输出方式有两种：一种是使用print函数；另一种直接使用变量名查看该变量的原始值。(1) print函数 print函数可以打印输出数据的输出操作，其语法结构如下： print( &lt; expressions &gt;) print语法结构里的&lt; expressions &gt;单词后边有s的复数，其含义是表达式可以是多个。 如果有多个&lt; expression &gt;，则表达式之间用逗号隔开，其语法格式如下： print( &lt; expression &gt;,&lt; expression &gt;,..&lt; expression &gt;) 在新建的.py文件中，输入print语句。 &gt;&gt;&gt; print (‘hello world’) hello world 可以看到每条print语句输出后都自动换了一行，如果要实现不换行，则需要在变量末尾加上逗号。(2) 直接使用变量名查看该变量的原始值 在交互式环境中，为了方便，可以直接使用变量名查看该变量的原始值，以达到输出的效果。 &gt;&gt;&gt; character = “hello world” &gt;&gt;&gt; character ‘hello world‘ 也可以直接在交互式环境中运行“hello world”，实现输出。 &gt;&gt;&gt; &quot;hello world&quot; &apos;hello world‘ 2. 输入在Python里可以通过input函数从键盘获得用户的数据输入，其语法结构如下。input(&lt; prompt &gt;)input函数的形参prompt是一个字符串，用于提示用户输入数据。input函数的返回值是字符串型的。 123# 输入实例a = input('请输入a的值：a=')print('已输入的a的值为：', a) 当用户输入数据后，input函数会把输入数据传给等号左边的character变量来保存输入的数据。第2行调用print打印character变量的值，所以执行第2行后会打印字符串出“input your character:”，以此作为新的提示符，输入“hello world”，可以完整的输出“hello world”。 END","updated":"2020-07-30T07:06:00.906Z","categories":[{"name":"Python编程基础","slug":"Python编程基础","permalink":"http://yoursite.com/categories/Python%E7%BC%96%E7%A8%8B%E5%9F%BA%E7%A1%80/"}],"tags":[{"name":"python","slug":"python","permalink":"http://yoursite.com/tags/python/"},{"name":"PyCharm","slug":"PyCharm","permalink":"http://yoursite.com/tags/PyCharm/"}]},{"title":"Python编程基础之学前准备","date":"2020-07-30T07:02:19.000Z","path":"2020/07/30/Python编程基础之学前准备/","text":"Hello Python! 1.认识PythonPython官方文档：https://docs.python.org/zh-cn/3/ 1.1 什么是PythonPython是一种计算机程序设计语言。是一种==面向对象的动态类型语言==，最初被设计用于编写自动化脚本(shell)，随着版本的不断更新和语言新功能的添加，越来越多被用于独立的、大型项目的开发。| | ||–|–||起源|1991年发行、基于C语言实现 || 设计思想 |优雅、明确、简单 || | | 1.2 Python优点和缺点 Python优点 简单、易学免费、开源 可扩展性 可嵌入性 跨平台性 丰富的第三方类库 Python缺点 运行速度 框架选择太多 ### 1.3 Python的应用领域 Web开发 数据分析师 数据挖掘工程师 自动化运维：批量处理大量的运维任务 游戏开发者 自动化测试 机器学习等 *** ## 2.搭建Python开发环境 ### 2.1 Python实际工作（开发）环境： - Python（程序运行基础(引擎)） - Python（如Python3.6.x） 如果Windows版本是32位的，则单击“Windows x86 executable installer”版本，然后下载。 如果Windows版本是64位的，则单击“Windows x86-64 executable installer”版本，然后下载。 - 第三方类库（功能拓展） - Numpy - pandas - scikit-learn - …… - 类库安装教程参考 - 编辑器（提高代码编辑效率） - Pycharm - Spyder - jupyter notebook 2.2 搭建Python环境方案 方案一： Python + Pycharm / jupyter notebook + 第三方类库 方案二： Anaconda 3.其它 使用IDE工具：jupyter notebook、PyCharm、Spyder1、jupyter notebook：pip install jupyter notebook2、PyCharm / PyCharm学习手册包括：社区版免费，专业版付费PyCharm是由JetBrains打造的一款Python IDE，带有一整套可以帮助Python开发者提高工作效率的工具，比如调试、语法高亮、Project管理、代码跳转、智能提示、自动完成、单元测试、版本控制。它提供一些高级功能，以用于支持Django框架下的专业Web开发。还提供了一些很好的功能用于Django开发，同时支持Google App Engine，并且PyCharm支持IronPython。这些功能在先进代码分析程序的支持下，使PyCharm成为Python专业开发人员和刚起步人员使用的有力工具。3、 Anaconda：Python科学计算包合集 END","updated":"2020-07-30T07:06:18.867Z","categories":[{"name":"Python编程基础","slug":"Python编程基础","permalink":"http://yoursite.com/categories/Python%E7%BC%96%E7%A8%8B%E5%9F%BA%E7%A1%80/"}],"tags":[{"name":"python","slug":"python","permalink":"http://yoursite.com/tags/python/"},{"name":"PyCharm","slug":"PyCharm","permalink":"http://yoursite.com/tags/PyCharm/"}]},{"title":"PyQt5基本控件之QMessageBox","date":"2020-07-30T06:52:40.000Z","path":"2020/07/30/PyQt5基本控件之QMessageBox/","text":"Hello PyQt5! QMessageBoxQmessageBox是一种通用的弹出式对话框，用于显示消息，允许用户通过单击不同的标准按钮对消息进行反馈，每个标准按钮有一个预定义的文本，角色和十六进制数QMessageBox类提供了许多常用的弹出式对话框，如提示。警告，错误，询问等会话框，不同类型的QMessageBox对话框只是显示的图标不同，其它的功能是一样。 1.常用方法 方法 说明 information(QWdiget parent,title,text,buttons,defaultButton) 弹出消息对话框 question（QWidget parent,title,text,buttons,defaultButton） 弹出问答对话框 warning（QWidget parent,title,text,buttons,defaultButton） 弹出警告对话框 critical（QWidget parent,title,text,buttons,defaultButton） 弹出严重错误对话框 about（QWidget parent,title,text） 弹出关于对话框 ### 2.常用方法的参数 参数 说明 – – parent 父窗口控件 title 对话框标题 text 对话框文本 buttons 多个标准按钮，默认为ok按钮 defaultButton 默认选中的标准按钮，默认选中第一个标准按钮 setTitle() 设置标题 setText() 设置正文消息 setIcon() 设置弹出对话框的图片 3.参数中的标准按钮类型 按钮类型 功能说明 QMessageBox.Cancel 取消 QMessageBox.Ok 同意 QMessageBox.No 取消 QMessageBox.Yes 同意 QMessageBox.Abort 终止 QMessageBox.Retry 重试 QMessageBox.Ignore 忽略 4.QMessageBox代码及逻辑关系举例代码： 123456789101112131415161718192021222324252627282930313233343536# 4.QMessageBox代码及逻辑关系举例import sysfrom PyQt5.QtWidgets import *class MyWindow(QWidget): def __init__(self, parent=None): super(MyWindow, self).__init__(parent) self.setWindowTitle('QMessageBox代码及逻辑关系举例') self.resize(400, 450) self.button = QPushButton(self) self.button.move(125, 225) self.button.setText('消息框按钮') self.button.clicked.connect(self.Message) # 弹出消息对话框按钮 def Message(self): # 消息框举例 # 1.消息对话框 QMessageBox.information(self, '消息对话框标题', '消息对话框内容', QMessageBox.Yes | QMessageBox.No) # 2.提问对话框 QMessageBox.question(self, \"提问框标题\", \"提问框内容\", QMessageBox.Yes | QMessageBox.No) # 3.警告对话框 QMessageBox.warning(self, \"警告框标题\", \"警告框内容\", QMessageBox.Yes | QMessageBox.No) # 4.严重错误对话框 QMessageBox.critical(self, \"严重错误对话框标题\", \"严重错误对话框内容\", QMessageBox.Yes | QMessageBox.No) # 5.简单对话框 QMessageBox.about(self, \"对话框标题\", \"对话框内容\")if __name__ == '__main__': app = QApplication(sys.argv) md = MyWindow() md.show() sys.exit(app.exec_()) 逻辑关系举例：未完待续……….","updated":"2020-07-30T06:59:11.636Z","categories":[{"name":"PyQt5","slug":"PyQt5","permalink":"http://yoursite.com/categories/PyQt5/"}],"tags":[{"name":"pyqt5","slug":"pyqt5","permalink":"http://yoursite.com/tags/pyqt5/"},{"name":"python","slug":"python","permalink":"http://yoursite.com/tags/python/"}]},{"title":"PyQt5中的QMessageBox的Yes和No按钮转换成中文，并进行逻辑判断","date":"2020-07-30T06:52:29.000Z","path":"2020/07/30/PyQt5中的QMessageBox的Yes和No按钮转换成中文，并进行逻辑判断/","text":"Hello PyQt5! QmessageBoxQmessageBox是一种通用的弹出式对话框，用于显示消息，允许用户通过单击不同的标准按钮对消息进行反馈，每个标准按钮有一个预定义的文本，角色和十六进制数QMessageBox类提供了许多常用的弹出式对话框，如提示。警告，错误，询问等会话框，不同类型的QMessageBox对话框只是显示的图标不同，其它的功能是一样。1.不进行Yes和No按钮转换成中文： 12345678reply = QMessageBox.information(self, \"系统提示框\", \"提示信息！\", QMessageBox.Yes | QMessageBox.Cancel) if reply == QtWidgets.QMessageBox.Yes: # 需要进行的操作 else: pass # 需要进行的操作 2.进行Yes和No按钮转换成中文： 12345678self.box = QMessageBox(QMessageBox.Warning, \"警告框\", \"提示信息\")qyes=self.box.addButton(self.tr(\"确定\"), QMessageBox.YesRole)qno=self.box.addButton(self.tr(\"取消\"), QMessageBox.NoRole)self.box.exec_()if self.box.clickedButton() == qyes: # 需要进行的操作else: return # 需要进行的操作 END","updated":"2020-07-30T06:58:20.899Z","categories":[{"name":"PyQt5","slug":"PyQt5","permalink":"http://yoursite.com/categories/PyQt5/"}],"tags":[{"name":"pyqt5","slug":"pyqt5","permalink":"http://yoursite.com/tags/pyqt5/"},{"name":"python","slug":"python","permalink":"http://yoursite.com/tags/python/"}]},{"title":"PyQt5表格控件QTableWidget","date":"2020-07-30T06:52:27.000Z","path":"2020/07/30/PyQt5表格控件QTableWidget/","text":"Hello PyQt5! QTableWidgetQTableWidget 是 Qt 中的表格组件类。在窗体上放置一个 QTableWidget 组件后，可以在 Property Editor 里对其进行属性设置，双击这个组件，可以打开一个编辑器，对其 Colum、Row 和 Item 进行编辑。 一个 QTableWidget 组件的界面基本结构（加样式后） QTableWidget类中的常用方法 常用方法 方法描述 setROwCount(int row) 设置QTableWidget表格控件的行数 setColumnCount(int col) 设置QTableWidget表格控件的列数 setHorizontalHeaderLabels() 设置QTableWidget表格控件的行标签 setVerticalHeaderLabels() 设置QTableWidget表格控件的列标签 setItem(int ,int ,QTableWidgetItem) 在QTableWidget表格控件的每个选项的单元控件内添加控件 horizontalHeader() 获得QTableWidget表格控件的表格头，以便执行隐藏 rowCount() 获得QTableWidget表格控件的行数 columnCount() 获得QTableWidget表格控件的列数 setEditTriggers(EditTriggers triggers) 设置表格是否可以编辑，设置表格的枚举值 setSelectionBehavior（） 设置表格的选择行为 setTextAlignment() 设置单元格内文本的对齐方式 setSpan（） 合并单元格，要改变单元格的第row行，column列，要合并rowSpancount行数和columnSpanCount列数row：要改变的行数column：要改变的列数rowSpanCount：需要合并的行数columnSpanCount：需要合并的列数 setShowGrid() 在默认情况下表格的显示是有网格的，可以设置True或False用于是否显示，默认True setColumnWidth(int column,int width) 设置单元格行的宽度 setRowHeight(int row,int height) 设置单元格列的高度 2. QAbstractItemView单元格内容编辑规则 方法 取值 方法效果 QAbstractItemView.NoEditTriggers0No 0 单元格内容不能修改 QAbstractItemView.CurrentChanged1Editing 1 单元格内容随时修改 QAbstractItemView.DoubleClicked2Editing 2 单元格内容双击修改 QAbstractItemView.SelectedClicked4Editing 4 单元格内容单击修改 QAbstractItemView.EditKeyPressed8Editing 8 单元格内容按下修改键时修改 QAbstractItemView.AnyKeyPressed16Editing 16 单元格内容按任意键修改 QAbstractItemView.AllEditTriggers31Editing 31 包括以上所有条件 3. QAbstractItemView单元格选择 方法 取值 方法效果 QAbstractItemView.SelectItems0Selecting 0 选中单个单元格 QAbstractItemView.SelectRows1Selecting 1 选中一行单元格 QAbstractItemView.SelectColumns2Selecting 2 选中一列单元格 4. 单元格文本水平/垂直对齐方式 方法 方法效果 水平 Qt.AlignLeft 单元格内容沿单元格的左边缘对齐 Qt.AlignRight 单元格内容沿单元格的右边缘对齐 Qt.AlignHCenter 单元格内容居中显示在水平方向 Qt.AlignJustify 单元格内容可用空间内对齐，默认从左到右 垂直 Qt.AlignTop 顶部对齐 Qt.AlignBottom 底部对齐 Qt.AlignVCenter 在垂直方向居中显示 Qt.AlignBaseline 基线对齐 应用实例首先利用Qt designer 和 PyUIC设计出窗口必须明确此时设置的表格控件名称 12# 表格属性和方法现在在self.tableWidget_test上边self.tableWidget_test = QtWidgets.QTableWidget(self.frame_table) 部分应用： 12345678910# 设置行表头self.tableWidget_test.setHorizontalHeaderLabels([\"XXX\", \"XXX\", \"XXX\"])# 表格禁止编辑self.tableWidget_test.setEditTriggers(QAbstractItemView.NoEditTriggers)# 行间隔变色（boolen）self.tableWidget_test.setAlternatingRowColors(1)# 设置水平方向表格为自适应的伸缩模式self.tableWidget_test.horizontalHeader().setSectionResizeMode(QHeaderView.Stretch)# 设置整行选中self.tableWidget_test.setSelectionBehavior(QAbstractItemView.SelectRows)","updated":"2020-07-30T06:58:01.425Z","categories":[{"name":"PyQt5","slug":"PyQt5","permalink":"http://yoursite.com/categories/PyQt5/"}],"tags":[{"name":"pyqt5","slug":"pyqt5","permalink":"http://yoursite.com/tags/pyqt5/"},{"name":"python","slug":"python","permalink":"http://yoursite.com/tags/python/"}]},{"title":"PyQt5基本控件之菜单栏QMenuBar","date":"2020-07-30T06:52:26.000Z","path":"2020/07/30/PyQt5基本控件之菜单栏QMenuBar/","text":"Hello PyQt5! QMenuBar基本方法 方法 效果 menuBar() 返回主窗口的QMenuBar对象 addMenu() 在菜单栏中添加一个新的QMenu对象 addAction() 向QMenu小控件中添加一个操作按钮，其中包含文本或图标 setEnabled() 将操作按钮设置为启用/禁用 addSeperator() 在菜单中添加一条分割线 clear() 删除菜单栏的内容 setShortcut() 将快捷键关联到操作按钮 setText() 设置菜单项的文本 setTitle() 设置QMenu小控件的标题 text() 返回与QACtion对象关联的文本 title() 返回QMenu小控件的标题 —– ## 应用实例 利用菜单栏实现添加子菜单及点击后响应： 顶层窗口必须是QMainWindow对象，才可以引用QMenuBar对象。 123456789101112131415161718# # 菜单栏调度---------------------------------------------------------------------------------------------------- openFileaction = QAction('&amp;子菜单1', self) # 在文件主菜单1下增加子菜单1 openFileaction.triggered.connect(self.menu_openFile_clicked) # 点击后打开新界面 openFileaction.setShortcut('Ctrl+A') # 子菜单1界面设置打开快捷键 ..... openHelpWordaction = QAction('&amp;子菜单2', self) openHelpWordaction.triggered.connect(self.menu_openHelpWordaction_clicked) # 在文件主菜单1下增加子菜单2 openHelpWordaction.setShortcut('Ctrl+B') # 子菜单2界面设置打开快捷键 menubar = self.menuBar() # 声明菜单栏 fileMenu_File = menubar.addMenu('&amp;主菜单1') # 菜单栏增加文件主菜单1 fileMenu_File.addAction(openFileaction) # 增加打开事件1 fileMenu_File.addAction(openHelpWordaction) # 增加打开事件2 ...... fileMenu_Help = menubar.addMenu('&amp;主菜单2') # 菜单栏增加文件主菜单2 fileMenu_Help.addAction(openxxxxxaction) # 增加打开事件# # 菜单栏调度---------------------------------------------------------------------------------------------------- Demo1234567891011121314151617181920212223242526272829303132333435363738394041import sysfrom PyQt5.QtWidgets import *class MenuDemo(QMainWindow): def __init__(self, parent=None): super(MenuDemo, self).__init__(parent) # 水平布局 layout = QHBoxLayout() # # 菜单栏调度---------------------------------------------------------------------------------------------------- openFileaction = QAction('&amp;子菜单1', self) # 在文件主菜单1下增加子菜单1 openFileaction.triggered.connect(self.menu_openFile_clicked) # 点击后打开新界面 openFileaction.setShortcut('Ctrl+A') # 子菜单1界面设置打开快捷键 openHelpWordaction = QAction('&amp;子菜单2', self) openHelpWordaction.triggered.connect(self.menu_openHelpWordaction_clicked) # 在文件主菜单1下增加子菜单2 openHelpWordaction.setShortcut('Ctrl+B') # 子菜单2界面设置打开快捷键 menubar = self.menuBar() # 声明菜单栏 fileMenu_File = menubar.addMenu('&amp;主菜单1') # 菜单栏增加文件主菜单1 fileMenu_File.addAction(openFileaction) # 增加打开事件1 fileMenu_File.addAction(openHelpWordaction) # 增加打开事件2 fileMenu_Help = menubar.addMenu('&amp;主菜单2') # 菜单栏增加文件主菜单2 # # 菜单栏调度---------------------------------------------------------------------------------------------------- def menu_openFile_clicked(self): print(123) def menu_openHelpWordaction_clicked(self): print(456)if __name__ == '__main__': app = QApplication(sys.argv) demo = MenuDemo() demo.show() sys.exit(app.exec_()) END","updated":"2020-07-30T06:56:13.912Z","categories":[{"name":"PyQt5","slug":"PyQt5","permalink":"http://yoursite.com/categories/PyQt5/"}],"tags":[{"name":"pyqt5","slug":"pyqt5","permalink":"http://yoursite.com/tags/pyqt5/"},{"name":"python","slug":"python","permalink":"http://yoursite.com/tags/python/"}]},{"title":"JSON教程","date":"2020-07-28T10:26:09.000Z","path":"2020/07/28/JSON教程/","text":"Hello JSON! JSONJSON 指的是 JavaScript 对象表示法（JavaScript Object Notation），是轻量级的文本数据交换格式，使用 Javascript语法来描述数据对象，具有自我描述性，更易理解，但是 JSON 仍然独立于语言和平台，JSON 解析器和 JSON 库支持许多不同的编程语言。 目前非常多的动态（PHP，JSP，.NET）编程语言都支持JSON。在语法上与创建 JavaScript 对象的代码相同。由于这种相似性，无需解析器，JavaScript 程序能够使用内建的 eval() 函数，用 JSON 数据来生成原生的 JavaScript 对象。 JSON语法JSON 语法是 JavaScript 对象表示语法的子集。 数据在名称/值对中 数据由逗号分隔 大括号{}保存对象 中括号[]保存数组 JSON 数据的书写格式是：名称/值对。名称/值对包括字段名称（在双引号中），后面写一个冒号，然后是值： 1\"name\" : \"cjw\" 等价于这条 JavaScript 语句：name = \"cjw\" JSON 使用 JavaScript 语法，所以无需额外的软件就能处理 JavaScript 中的 JSON。通过 JavaScript，可以创建一个对象数组，并像这样进行赋值：实例: 1234567var data = [ &#123; \"name\":\"dog\" , \"url\":\"www.dog.com\" &#125;, &#123; \"name\":\"cat\" , \"url\":\"www.cat.com\" &#125;, &#123; \"name\":\"pig\" , \"url\":\"www.pig.com\" &#125; , .....]; data[0].name 返回： dog JSON 文件的文件类型是 “.json”JSON 文本的 MIME 类型是 “application/json” JSON 对象形如：{ “name”:”runoob”, “alexa”:10000, “site”:null }，JSON 对象使用在大括号({})中书写。对象可以包含==多个 key/value（键/值）对==。key 必须是字符串，value 是合法的 JSON 数据类型（字符串, 数字, 对象, 数组, 布尔值或 null），key 和 value 中使用冒号(:)分割，每个 key/value 对使用逗号(,)分割。 接收/发送数据1. JSON.parse()JSON 通常用于与服务端交换数据，在接收服务器数据时一般是字符串。使用 JSON.parse() 方法将数据转换为 JavaScript 对象。语法格式：JSON.parse(text[, reviver])参数说明：text:必需， 一个有效的 JSON 字符串。reviver: 可选，一个转换结果的函数， 将为对象的每个成员调用此函数。JSON 解析实例：如：从服务器接收了以下数据：data = { “name”:”runoob”, “alexa”:10000, “site”:”www.runoob.com&quot; }我们使用 JSON.parse() 方法处理以上数据，将其转换为 JavaScript 对象：var obj = JSON.parse(‘data’);解析前要==确保你的数据是标准的 JSON 格式==，否则会解析出错。可以使用json格式在线工具检测，确保数据为json格式。 2. JSON.stringify()JSON 通常用于与服务端交换数据。在向服务器发送数据时一般是字符串。可以使用 JSON.stringify() 方法将 JavaScript 对象转换为字符串。 语法格式：JSON.stringify(value[, replacer[, space]])参数说明：value:必需， 要转换的 JavaScript 值（通常为对象或数组）。replacer:可选。用于转换结果的函数或数组。如果 replacer 为函数，则 JSON.stringify 将调用该函数，并传入每个成员的键和值。使用返回值而不是原始值。如果此函数返回 undefined，则排除成员。根对象的键是一个空字符串：””。 如果 replacer 是一个数组，则仅转换该数组中具有键值的成员。成员的转换顺序与键在数组中的顺序一样。当 value 参数也为数组时，将忽略 replacer 数组。 space:可选，文本添加缩进、空格和换行符，如果 space 是一个数字，则返回值文本在每个级别缩进指定数目的空格，如果 space 大于 10，则文本缩进 10 个空格。space 也可以使用非数字，如：\\t。 JavaScript 对象转换向服务器发送以下数据：var obj = { “name”:”runoob”, “alexa”:10000, “site”:”www.runoob.com&quot;};我们使用 JSON.stringify() 方法处理以上数据，将其转换为字符串：var myJSON = JSON.stringify(obj);myJSON 为字符串。我们可以将 myJSON 发送到服务器：实例：var obj = { “name”:”cjw”, “alexa”:10000, “site”:”www.cjw.com&quot;};var myJSON = JSON.stringify(obj);document.getElementById(“demo”).innerHTML = myJSON; JsonpJsonp(JSON with Padding) 是 json 的一种”使用模式”，可以让网页从别的域名（网站）那获取资料，即跨域读取数据。 更多内容可以参考：JSON教程 END","updated":"2020-07-28T10:28:32.499Z","categories":[{"name":"JavaWeb","slug":"JavaWeb","permalink":"http://yoursite.com/categories/JavaWeb/"}],"tags":[{"name":"JSON","slug":"JSON","permalink":"http://yoursite.com/tags/JSON/"}]},{"title":"jQuery教程","date":"2020-07-28T10:26:07.000Z","path":"2020/07/28/jQuery教程/","text":"Hello jQuery! jQueryjQuery是一个JavaScript函数库，是一个==轻量级的”写的少，做的多”的JavaScript库==。jQuery库包含以下功能： HTML 元素 选取 HTML 元素 操作 CSS 操作 HTML 事件函数 JavaScript 特效 动画 HTML DOM 遍历和修改 AJAX 除此之外，JQuery还提供了大量的插件。目前兼容于所有主流浏览器。 jQuery 语法通过 jQuery，您可以选取（查询，query） HTML 元素，并对它们执行”操作”（actions）。jQuery 语法是通过选取 HTML 元素，并对选取的元素执行某些操作。基础语法： $(selector).action()美元符号定义 jQuery，选择符（selector）”查询”和”查找” HTML 元素，jQuery 的 action() 执行对元素的操作。实例: $(this).hide() - 隐藏当前元素 $(“p”).hide() - 隐藏所有 元素 $(“p.test”).hide() - 隐藏所有 class=”test” 的 元素 $(“#test”).hide() - 隐藏 id=”test” 的元素 标准写法：所有 jQuery 函数位于一个 document ready 函数中： 12345$(document).ready(function()&#123; // 开始写 jQuery 代码... &#125;); 这是为了防止文档在完全加载（就绪）之前运行 jQuery 代码，即在 DOM 加载完成后才可以对 DOM 进行操作。==如果在文档没有完全加载之前就运行函数，操作可能失败。==****————————————————————————————————————————————–jQuery 入口函数与 JavaScript 入口函数的区别：jQuery 的入口函数是在 html 所有标签(DOM)都加载之后，就会去执行。JavaScript 的 window.onload 事件是等到所有内容，包括外部图片之类的文件加载完后，才会执行。****————————————————————————————————————————————–简洁写法（与以上写法效果相同）: 12345$(function()&#123; // 开始写 jQuery 代码... &#125;); 以上两种方式选择一种方式实现文档就绪后执行 jQuery 方法。 jQuery 选择器jQuery 选择器允许对 HTML 元素组或单个元素进行操作，基于元素的 id、类、类型、属性、属性值等”查找”（或选择）HTML 元素。 它基于已经存在的 CSS 选择器，除此之外，还有一些自定义的选择器。jQuery 中所有选择器都以美元符号开头：==$()==。常用的有： 元素选择器jQuery 元素选择器基于元素名选取元素。在页面中选取所有 元素:$(“p”)如：用户点击按钮后，所有 元素都隐藏：12345$(document).ready(function()&#123; $(\"button\").click(function()&#123; $(\"p\").hide(); &#125;);&#125;); id 选择器jQuery #id 选择器通过 HTML 元素的 id 属性选取指定的元素，页面中元素的 id 应该是唯一的，所以您要在页面中选取唯一的元素需要通过 #id 选择器。通过 id 选取元素语法如下：$(“#test”)如：当用户点击按钮后，有 id=”test” 属性的元素将被隐藏：12345$(document).ready(function()&#123; $(\"button\").click(function()&#123; $(\"#test\").hide(); &#125;);&#125;); .class 选择器jQuery 类选择器可以通过指定的 class 查找元素。语法如下：$(“.test”)如：用户点击按钮后所有带有 class=”test” 属性的元素都隐藏：12345$(document).ready(function()&#123; $(\"button\").click(function()&#123; $(\".test\").hide(); &#125;);&#125;); jQuery 事件页面对不同访问者的响应叫做事件。事件处理程序指的是当 HTML 中发生某些事件时所调用的方法。常见 DOM 事件：| 事件| 方法 ||–|–||鼠标事件 | click dblclick mouseenter mouseleave blur hover || 键盘事件 | keypress keydown keyup blur || 表单事件 | submit change focus unload||文档/窗口事件 |load reasize scroll | jQuery 事件方法语法:在 jQuery 中，大多数 DOM 事件都有一个等效的 jQuery 方法。 页面中指定一个点击事件：$(“p”).click();下一步是定义什么时间触发事件。您可以通过一个事件函数实现： 123$(\"p\").click(function()&#123; // 动作触发后执行的代码!!&#125;); jQuery方法1. jQuery load()jQuery load() 方法是简单但强大的 AJAX 方法。load() 方法从服务器加载数据，并把返回的数据放入被选元素中。语法: $(selector).load(URL,data,callback);必需的 URL 参数规定希望加载的 URL。可选的 data 参数规定与请求一同发送的查询字符串键/值对集合。可选的 callback 参数是 load() 方法完成后所执行的函数名称。如：为了避免多页面情形下的代码重复，可以利用 load() 方法，将重复的部分（例如导航栏）放入单独的文件，使用下列方法进行导入： //1.当前文件中要插入的地方使用此结构： 1&lt;div class=\"include\" file=\"***.html\"&gt;&lt;/div&gt; //2.***.html中放入内容，用html格式仅仅因为会有编辑器的书写辅助。//3.代码： 12345678$(\".include\").each(function() &#123; if (!!$(this).attr(\"file\")) &#123; var $includeObj = $(this); $(this).load($(this).attr(\"file\"), function(html) &#123; $includeObj.after(html).remove(); //加载的文件内容写入到当前标签后面并移除当前标签 &#125;) &#125;&#125;); 或者在index文件里只写重复部分，剩下的一股脑放各自单独文件 load() 进来~ 2. get() 和 post()$.get() 方法通过 HTTP GET 请求==从服务器上请求数据==。语法：$.get(URL,callback);必需的 URL 参数规定您希望请求的 URL。可选的 callback 参数是请求成功后所执行的函数名。 $.post() 方法通过 HTTP POST 请求==向服务器提交数据==。语法:$.post(URL,data,callback);必需的 URL 参数规定您希望请求的 URL。可选的 data 参数规定连同请求发送的数据。可选的 callback 参数是请求成功后所执行的函数名。开发中一般利用jQurey的ajax方法与服务器交互数据（数据格式为JSON字符串）。 Ajax 具体可参考 jQurey教程 END","updated":"2020-07-28T10:29:10.723Z","categories":[{"name":"JavaWeb","slug":"JavaWeb","permalink":"http://yoursite.com/categories/JavaWeb/"}],"tags":[{"name":"jQuery","slug":"jQuery","permalink":"http://yoursite.com/tags/jQuery/"}]},{"title":"Bootstrap教程","date":"2020-07-28T10:26:03.000Z","path":"2020/07/28/Bootstrap教程/","text":"Hello Bootstrap! BootstrapBootstrap，来自 Twitter，是目前最受欢迎的前端框架。Bootstrap 是基于 HTML、CSS、JavaScript，它简洁灵活，使得 Web 开发更加快捷。 基本结构Bootstrap 提供了一个带有网格系统、链接样式、背景的基本结构。Bootstrap 提供了一套响应式、移动设备优先的流式网格系统，随着屏幕或视口（viewport）尺寸的增加，系统会自动分为==最多12列==。行内包含列，每行最多12列。Bootstrap 网格的基本结构： 12345678&lt;div class=\"container\"&gt; &lt;div class=\"row\"&gt; &lt;div class=\"col-*-*\"&gt;&lt;/div&gt; &lt;div class=\"col-*-*\"&gt;&lt;/div&gt; &lt;/div&gt; &lt;div class=\"row\"&gt;...&lt;/div&gt;&lt;/div&gt;&lt;div class=\"container\"&gt;.... 网格系统通过一系列包含内容的行和列来创建页面布局。 Bootstrap 网格系统工作原理： 行==必须放置在 .container class 内==，以便获得适当的对齐（alignment）和内边距（padding）。 使用行来创建列的水平组。 内容应该放置在列内，且唯有列可以是行的直接子元素。 预定义的网格类，比如 .row 和 .col-xs-4，可用于快速创建网格布局。LESS 混合类可用于更多语义布局。 列通过内边距（padding）来创建列内容之间的间隙。该内边距是通过 .rows 上的外边距（margin）取负，表示第一列和最后一列的行偏移。 网格系统是通过指定您想要横跨的十二个可用的列来创建的。例如，要创建三个相等的列，则使用三个 .col-xs-4。 CSS：Bootstrap 自带以下特性：全局的 CSS 设置、定义基本的 HTML 元素样式、可扩展的 class，以及一个先进的网格系统。 Bootstrap 表格Bootstrap 提供了一个清晰的创建表格的布局。表格样式： 1234567使用方法：&lt;table class = \" table table-striped\" &gt;.table 为任意 &lt;table&gt; 添加基本样式 (只有横向分隔线) .table-striped 在 &lt;tbody&gt; 内添加斑马线形式的条纹 ( IE8 不支持) .table-bordered 为所有表格的单元格添加边框 .table-hover 在 &lt;tbody&gt; 内的任一行启用鼠标悬停状态 .table-condensed 让表格更加紧凑 表格单元格样式： 1234567使用方法： &lt;tr class=\"active\"&gt;.active 将悬停的颜色应用在行或者单元格上 .success 表示成功的操作 .info 表示信息变化的操作 .warning 表示一个警告的操作 .danger 表示一个危险的操作 常用实例（鼠标悬停高亮）： 123456789101112131415161718192021222324252627&lt;table class=\"table table-hover\"&gt; &lt;caption&gt;悬停表格布局&lt;/caption&gt; &lt;thead&gt; &lt;tr&gt; &lt;th&gt;名称&lt;/th&gt; &lt;th&gt;城市&lt;/th&gt; &lt;th&gt;邮编&lt;/th&gt; &lt;/tr&gt; &lt;/thead&gt; &lt;tbody&gt; &lt;tr&gt; &lt;td&gt;Tanmay&lt;/td&gt; &lt;td&gt;Bangalore&lt;/td&gt; &lt;td&gt;560001&lt;/td&gt; &lt;/tr&gt; &lt;tr&gt; &lt;td&gt;Sachin&lt;/td&gt; &lt;td&gt;Mumbai&lt;/td&gt; &lt;td&gt;400003&lt;/td&gt; &lt;/tr&gt; &lt;tr&gt; &lt;td&gt;Uma&lt;/td&gt; &lt;td&gt;Pune&lt;/td&gt; &lt;td&gt;411027&lt;/td&gt; &lt;/tr&gt; &lt;/tbody&gt;&lt;/table&gt; 实际开发中，数据以JSON的格式从后数据库回传后，显示在表格对应的位置，再结合分页控件等实现表格功能。表格控件常用：BootstrapTable 参考文档: BT Bootstrap 表单Bootstrap 提供了下列类型的表单布局：垂直表单（默认）、内联表单、 水平表单。实例： 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667&lt;form th:action=\"@&#123;/user/register&#125;\" method=\"post\"&gt; &lt;table class=\"table table-striped table-condensed\"&gt; &lt;tr&gt; &lt;td valign=\"middle\" align=\"right\" style=\"color: red\"&gt; 用户名: &lt;/td&gt; &lt;td valign=\"middle\" align=\"left\"&gt; &lt;input type=\"text\" class=\"inputgri\" name=\"username\" placeholder=\"请输入用户名\"/&gt; &lt;/td&gt; &lt;/tr&gt; &lt;tr&gt; &lt;td valign=\"middle\" align=\"right\" style=\"color: red\"&gt; 密码: &lt;/td&gt; &lt;td valign=\"middle\" align=\"left\"&gt; &lt;input type=\"text\" class=\"inputgri\" name=\"password\" placeholder=\"请输入密码\"/&gt; &lt;/td&gt; &lt;/tr&gt; &lt;tr&gt; &lt;td valign=\"middle\" align=\"right\"&gt; 性别: &lt;/td&gt; &lt;td valign=\"middle\" align=\"left\"&gt; &lt;!--&lt;input type=\"text\" class=\"inputgri\" name=\"sex\" th:value=\"$&#123;user.sex&#125;\"/&gt;--&gt; &lt;label class=\"radio-inline\"&gt; &lt;input type=\"radio\" name=\"sex\" id=\"man\" value=\"男\" checked&gt; 男 &lt;/label&gt; &lt;label class=\"radio-inline\"&gt; &lt;input type=\"radio\" name=\"sex\" id=\"women\" value=\"女\"&gt; 女 &lt;/label&gt; &lt;/td&gt; &lt;/tr&gt; &lt;tr&gt; &lt;td valign=\"middle\" align=\"right\"&gt; 电话: &lt;/td&gt; &lt;td valign=\"middle\" align=\"left\"&gt; &lt;input type=\"text\" class=\"inputgri\" name=\"phone\" placeholder=\"请输入联系电话\"/&gt; &lt;/td&gt; &lt;/tr&gt; &lt;tr&gt; &lt;td valign=\"middle\" align=\"right\"&gt; 邮箱: &lt;/td&gt; &lt;td valign=\"middle\" align=\"left\"&gt; &lt;input type=\"text\" class=\"inputgri\" name=\"email\" placeholder=\"请输入邮箱\"/&gt; &lt;/td&gt; &lt;/tr&gt; &lt;tr&gt; &lt;td valign=\"middle\" align=\"right\" style=\"color: red\"&gt; 权限: &lt;/td&gt; &lt;td valign=\"middle\" align=\"left\"&gt; &lt;select class=\"form-control\" name=\"role\"&gt; &lt;option&gt;超级管理员&lt;/option&gt; &lt;option&gt;管理员&lt;/option&gt; &lt;option&gt;普通用户&lt;/option&gt; &lt;/select&gt; &lt;/td&gt; &lt;/tr&gt; &lt;/table&gt; &lt;p&gt; &lt;input type=\"submit\" class=\"btn btn-success btn-xs\" value=\"提交\" /&gt;&amp;nbsp; &lt;input type=\"button\" class=\"btn btn-info btn-xs\" onclick=\"location.href='/tofindAlluser'\" value=\"返回 &amp;raquo;\" /&gt; &lt;/p&gt; &lt;a&gt;注意：&lt;span style=\"color: red\"&gt;1.红色为必填必选项；2.用户名不能重复！&lt;/span&gt;&lt;/a&gt; &lt;/form&gt; Bootstrap 按钮任何带有 class .btn 的元素都会继承圆角灰色按钮的默认外观。但是 Bootstrap 提供了一些选项来定义按钮的样式。以下样式可用于, , 或 元素上，但是最好在 元素上使用按钮 class，避免跨浏览器的不一致性问题。实例： 1234567891011121314151617181920使用方法：&lt;!-- 标准的按钮 --&gt;&lt;button type=\"button\" class=\"btn btn-default\"&gt;默认按钮&lt;/button&gt;&lt;!-- 提供额外的视觉效果，标识一组按钮中的原始动作 --&gt;&lt;button type=\"button\" class=\"btn btn-primary\"&gt;原始按钮&lt;/button&gt;.btn 为按钮添加基本样式 .btn-default 默认/标准按钮 .btn-primary 原始按钮样式（未被操作） .btn-success 表示成功的动作 .btn-info 该样式可用于要弹出信息的按钮 .btn-warning 表示需要谨慎操作的按钮 .btn-danger 表示一个危险动作的按钮操作 .btn-link 让按钮看起来像个链接 (仍然保留按钮行为) .btn-lg 制作一个大按钮 .btn-sm 制作一个小按钮 .btn-xs 制作一个超小按钮 .btn-block 块级按钮(拉伸至父元素100%的宽度) .active 按钮被点击 .disabled 禁用按钮 实例： 1234&lt;p&gt; &lt;input type=\"submit\" class=\"btn btn-success btn-xs\" value=\"提交\" /&gt;&amp;nbsp; &lt;input type=\"button\" class=\"btn btn-info btn-xs\" onclick=\"location.href='/tofindAlluser'\" value=\"返回 &amp;raquo;\" /&gt;&lt;/p&gt; Bootstrap组件：Bootstrap 包含了十几个可重用的组件，用于创建图像、下拉菜单、导航、警告框、弹出框、面板等等。 面板面板组件用于把 DOM 组件插入到一个盒子中。创建一个基本的面板，只需要向 元素添加 class .panel 和 class .panel-default 即可。如： 12345&lt;div class=\"panel panel-default\"&gt; &lt;div class=\"panel-body\"&gt; 这是一个基本的面板 &lt;/div&gt;&lt;/div&gt; 可以扩展添加面板标题、面板脚注、带语境色彩的面板、带表格的面板、带列表组的面板等。 12345678&lt;div class=\"panel panel-default\"&gt; &lt;div class=\"panel-heading\"&gt; &lt;h3 class=\"panel-title\" style=\"color: #0f0f0f\"&gt;新增用户&lt;/h3&gt; &lt;/div&gt; &lt;div class=\"panel-body\"&gt; ..... &lt;/div&gt;&lt;/div&gt; 进度条进度条有默认、交替、条纹、动画（看着比较好）、堆叠。 12345678使用方法（以动画进度条为例）：&lt;div class=\"progress progress-striped active\"&gt; &lt;div class=\"progress-bar progress-bar-success\" role=\"progressbar\" aria-valuenow=\"60\" aria-valuemin=\"0\" aria-valuemax=\"100\" style=\"width: 40%;\"&gt; &lt;span class=\"sr-only\"&gt;40% 完成&lt;/span&gt; &lt;/div&gt;&lt;/div&gt; 使用过程中配合setInterval（）和clearInterval（）两个函数，以及利用Vue.js或jQuery.js等完成实际进度条开发。如： 123456基于vue和bootstrap:&lt;div class=\"progress progress-striped\" v-show=\"isShow\"&gt; &lt;div class=\"progress-bar progress-bar-info\" :style=\"&#123;width:prc+'%'&#125;\"&gt; &lt;b class=\"font-light\"&gt;&#123;&#123;prc&#125;&#125;%&lt;/b&gt; &lt;/div&gt; &lt;/div&gt; JavaScript 插件：Bootstrap 包含了十几个自定义的 jQuery 插件。可以直接包含所有的插件，也可以逐个包含这些插件。 定制：可以定制 Bootstrap 的组件、LESS 变量和 jQuery 插件来得到自己的版本。 具体可参考： Bootstrap教程 END","updated":"2020-07-28T10:29:37.812Z","categories":[{"name":"JavaWeb","slug":"JavaWeb","permalink":"http://yoursite.com/categories/JavaWeb/"}],"tags":[{"name":"Bootstrap","slug":"Bootstrap","permalink":"http://yoursite.com/tags/Bootstrap/"}]},{"title":"Ajax教程","date":"2020-07-27T08:15:00.000Z","path":"2020/07/27/Ajax教程/","text":"Hello Ajax! AjaxAsynchronous JavaScript and XML（异步的 JavaScript 和 XML）： AJAX 不是新的编程语言，而是一种使用现有标准的新方法。 AJAX最大的优点==是在不重新加载整个页面的情况下，可以与服务器交换数据并更新部分网页内容==。 AJAX 不需要任何浏览器插件，但需要==允许JavaScript在浏览器上执行==（这点不用考虑）。 AJAX是基于现有的Internet标准，并且联合使用XMLHttpRequest 对象 (异步的与服务器交换数据)、JavaScript/DOM (信息显示/交互)、CSS (给数据定义样式)、XML (作为转换数据的格式)。 AJAX应用程序与浏览器和平台无关。 了解更多：AJAX菜鸟教程 Ajax原理 Ajax基本结构（jQurey）123456789$.ajax(&#123; url:\"发送请求（提交或读取数据）的地址\", dataType:\"预期服务器返回数据的类型\", type:\"请求方式\", async:\"true/false\", data:&#123;发送到/读取后台（服务器）的数据，json字符串&#125;, success:function(data)&#123;请求成功时执行&#125;, error:function()&#123;请求失败时执行&#125;&#125;); ajax参数均为选填，如果不设置，按默认值处理: url 默认为当前页地址 dataType 可用类型：xml：返回XML文档，可用Jquery处理。html：返回纯文本HTML信息。script：返回纯文本JavaScript代码。json：返回json数据。jsonp：(JSON with Padding) 是 json 的一种”使用模式”，可以让网页从别的域名获取资料，即跨域读取数据。text：返回纯文本字符串。（如果不指定，Jquery将自动根据http包mime信息返回responseXML或responseText，并作为回调函数参数传递） type 可用类型主要为post和get两种（默认为GET）:GET：从指定的资源请求数据（从服务器读取数据）POST：向指定的资源提交要被处理的数据（向服务器提交数据）GET 还是 POST？与 POST 相比，GET 更简单也更快，并且在大部分情况下都能用。然而，在以下情况中，请使用 POST 请求： 无法使用缓存文件（更新服务器上的文件或数据库） 向服务器发送大量数据（POST 没有数据量限制） 发送包含未知字符的用户输入时，POST 比 GET 更稳定也更可靠 async 异步方式，默认为true，即异步方式。当设置为false时，为同步方式。异步方式：ajax执行后，会继续执行ajax后面的脚本，直到服务器端返回数据后，触发ajax里的success方法，这时候执行的是两个线程。同步方式：在没有返回值之前，同步请求将锁住浏览器，用户其它操作必须等待请求完成才可以执行。 data 请求的数据，{ }中可以填入多项数据。如果不填（一般为get请求），则读取对应地址的全部数据，此时可以在console中通过console.log(res)显示数据情况。 success 和 error 两个函数 一般需要设置，方便确定请求是否成功，以及请求成功后的提示或是对数据的处理和显示。 实例： 123456789101112131415161718192021&lt;script type=\"text/javascript\" src=\"http://code.jquery.com/jquery-latest.js\"&gt;&lt;/script&gt; &lt;script type=\"text/javascript\"&gt; function Save(event)&#123; var url = \"../updata_setting/updata\"; $.ajax(&#123; type: \"POST\", url: url, data: JSON.stringify(vm.updata_setting), success: function(r)&#123; if(r.code === 0)&#123; alert('操作成功', function(index)&#123; vm.reload(); &#125;); &#125;else&#123; alert(r.msg); &#125; &#125; &#125;); &#125; &lt;/script&gt; END","updated":"2020-07-27T08:19:30.458Z","categories":[{"name":"JavaWeb","slug":"JavaWeb","permalink":"http://yoursite.com/categories/JavaWeb/"}],"tags":[{"name":"Ajax","slug":"Ajax","permalink":"http://yoursite.com/tags/Ajax/"},{"name":"jQurey","slug":"jQurey","permalink":"http://yoursite.com/tags/jQurey/"}]},{"title":"RuoYi代码生成器傻瓜教程","date":"2020-07-26T07:35:03.000Z","path":"2020/07/26/RuoYi代码生成器傻瓜教程/","text":"Hello RuoYi! My Environment RuoYi多模块版本 IDEA 2018.3 JDK 1.8 Maven 3.6.2 SpringBoot 2.3.0 360浏览器 构建过程（代码生成器） 建数据库表（==字段及表必须添加注释==），表名形如：para_value： 修改ruoyi-admin的配置文件application.yml1234author: cjw # 开发者姓名，生成到类注释上packageName: com.ruoyi.para # 默认生成包路径autoRemovePre: true # 是否自动去除表前缀tablePrefix: para # 表前缀（与数据库建立的表对应比如shop_order） 新建模块ruoyi-xxx,如ruoyi-para,按如图所示操作：点击Maven，写入要新建的模块名：之后引入common模块至新建模块pom.xml文件下：12345678&lt;!-- 通用工具--&gt; &lt;dependencies&gt; &lt;!-- 通用工具--&gt; &lt;dependency&gt; &lt;groupId&gt;com.ruoyi&lt;/groupId&gt; &lt;artifactId&gt;ruoyi-common&lt;/artifactId&gt; &lt;/dependency&gt; &lt;/dependencies&gt; 登录Ruoyi系统，点击系统工具，进入代码生成模块。导入需要生成的数据表：接着修改生成功能名以及检查表描述是否添加描述：生成后打开压缩文件，将压缩文件中mapper文件夹复制到新建模块的resource目录下，将压缩文件中java文件夹下的com复制到新建模块的java目录下。 在ruoyi-admin模块下的Controller中新建对应的para（功能package），复制新建模块的Controller到该package下，并删除原新建模块中的controller。 在ruoyi-admin模块下的templates中新建对应的para（功能package），复制新建模块的templates下生成的html到该package下。 在父工程下引入新建模块的依赖：123456&lt;!-- 核心模块--&gt; &lt;dependency&gt; &lt;groupId&gt;com.ruoyi&lt;/groupId&gt; &lt;artifactId&gt;ruoyi-para&lt;/artifactId&gt; &lt;version&gt;$&#123;ruoyi.version&#125;&lt;/version&gt; &lt;/dependency&gt; 之后再ruoyi-admin中引入新建模块依赖： 1234 &lt;dependency&gt; &lt;groupId&gt;com.ruoyi&lt;/groupId&gt; &lt;artifactId&gt;ruoyi-para&lt;/artifactId&gt;&lt;/dependency&gt; 然后刷新Maven，爆红的地方消失。8 .进入若依系统，点击系统管理中的菜单管理，构建目录及其目录下的菜单:请求地址和权限标识来自于对应的Controller：重启或等待热部署（前提配置了热部署）后，刷新界面： END","updated":"2020-07-26T07:40:50.335Z","categories":[{"name":"RuoYi","slug":"RuoYi","permalink":"http://yoursite.com/categories/RuoYi/"}],"tags":[{"name":"工具","slug":"工具","permalink":"http://yoursite.com/tags/%E5%B7%A5%E5%85%B7/"},{"name":"RuoYi脚手架（IDEA)","slug":"RuoYi脚手架（IDEA","permalink":"http://yoursite.com/tags/RuoYi%E8%84%9A%E6%89%8B%E6%9E%B6%EF%BC%88IDEA/"}]},{"title":"Python多.py文件打包为可运行.exe文件","date":"2020-07-23T12:01:01.000Z","path":"2020/07/23/Python多-py文件打包为可运行-exe文件/","text":"Hello World! 多文件Python项目打包成.exe运行文件工具：Pycharm2019.2.2 + Anaconda3(导入需要的库及Python.exe以及==pyinstaller==) 1.pyinstaller的安装在PyCharm中点击工具菜单栏File后点击Settings后按如下图所示步骤进行： 开始下载….下载成功（右下角会弹出提示框！）-*-成功后开始进入正题：打包.exe运行文件 2.打包可运行文件2.1准备图标a.图标下载网站链接: 图标下载网站,也可以自己准备或设计好的图片，b.然后通过图标转换网站链接： 图标转换网站转换为合适可用的图标。==备注==：所有图片路径必须改为绝对路径（否则无法显示）如：self.setWindowIcon(QIcon(‘D:/工程名/systemcode/images/icon1.png’)) # 设置窗体标题图标 2.2程序打包1.在控制台中选择==Terminal==输入形如以下形式内容（格式如：pyinstaller -F D:\\工程名\\systemcode\\main.py）： 运行过程如下： 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283848586878889(base) D:\\工程名&gt;pyinstaller -F D:\\工程名\\systemcode\\main.py224 INFO: PyInstaller: 3.6225 INFO: Python: 3.7.3 (conda)227 INFO: Platform: Windows-10-10.0.18362-SP0229 INFO: wrote D:\\工程名\\main.spec237 INFO: UPX is not available.248 INFO: Extending PYTHONPATH with paths['D:\\\\工程名', 'D:\\\\工程名']248 INFO: checking Analysis249 INFO: Building Analysis because Analysis-00.toc is non existent249 INFO: Initializing module dependency graph...270 INFO: Caching module graph hooks...288 INFO: Analyzing base_library.zip ...16899 INFO: Caching module dependency graph...17181 INFO: running Analysis Analysis-00.toc17244 INFO: Adding Microsoft.Windows.Common-Controls to dependent assemblies of final executable required by D:\\Anaconda3\\python.exe20606 INFO: Analyzing D:\\工程名\\systemcode\\main.py22940 INFO: Processing pre-find module path hook distutils22975 INFO: distutils: retargeting to non-venv dir 'D:\\\\Anaconda3\\\\lib'24081 INFO: Processing module hooks...24082 INFO: Loading module hook \"hook-cv2.py\"...39939 INFO: Processing pre-safe import module hook setuptools.extern.six.moves42892 INFO: Processing pre-find module path hook site42900 INFO: site: retargeting to fake-dir 'D:\\\\Anaconda3\\\\lib\\\\site-packages\\\\PyInstaller\\\\fake-modules'66116 INFO: Loading module hook \"hook-distutils.py\"...66148 INFO: Loading module hook \"hook-encodings.py\"...67143 INFO: Loading module hook \"hook-importlib_metadata.py\"...67149 INFO: Loading module hook \"hook-lib2to3.py\"...67160 INFO: Loading module hook \"hook-numpy.core.py\"...68459 INFO: MKL libraries found when importing numpy. Adding MKL to binaries68482 INFO: Loading module hook \"hook-numpy.py\"...68486 INFO: Loading module hook \"hook-pkg_resources.py\"...71269 INFO: Processing pre-safe import module hook win32com72539 INFO: Excluding import '__main__'72541 INFO: Removing import of __main__ from module pkg_resources72541 INFO: Loading module hook \"hook-pycparser.py\"...72543 INFO: Loading module hook \"hook-pydoc.py\"...72545 INFO: Loading module hook \"hook-PyQt5.py\"...73014 INFO: Loading module hook \"hook-PyQt5.QtCore.py\"...73283 INFO: Loading module hook \"hook-PyQt5.QtGui.py\"...73747 INFO: Loading module hook \"hook-PyQt5.QtWidgets.py\"...74148 INFO: Loading module hook \"hook-pytest.py\"...80434 INFO: Loading module hook \"hook-pythoncom.py\"...82638 INFO: Loading module hook \"hook-pywintypes.py\"...84663 INFO: Loading module hook \"hook-scipy.py\"...84701 INFO: Loading module hook \"hook-setuptools.py\"...88301 INFO: Loading module hook \"hook-sysconfig.py\"...88359 INFO: Loading module hook \"hook-win32com.py\"...90940 INFO: Loading module hook \"hook-xml.dom.domreg.py\"...90942 INFO: Loading module hook \"hook-xml.etree.cElementTree.py\"...90944 INFO: Loading module hook \"hook-xml.py\"...91005 INFO: Looking for ctypes DLLs91213 INFO: Analyzing run-time hooks ...91222 INFO: Including run-time hook 'pyi_rth_pyqt5.py'91243 INFO: Including run-time hook 'pyi_rth_multiprocessing.py'91260 INFO: Including run-time hook 'pyi_rth_pkgres.py'91282 INFO: Including run-time hook 'pyi_rth_win32comgenpy.py'91336 INFO: Looking for dynamic libraries91478 WARNING: lib not found: msmpi.dll dependency of D:\\Anaconda3\\Library\\bin\\mkl_blacs_msmpi_ilp64.dll91541 WARNING: lib not found: mpich2mpi.dll dependency of D:\\Anaconda3\\Library\\bin\\mkl_blacs_mpich2_lp64.dll92243 WARNING: lib not found: mpich2mpi.dll dependency of D:\\Anaconda3\\Library\\bin\\mkl_blacs_mpich2_ilp64.dll93386 WARNING: lib not found: impi.dll dependency of D:\\Anaconda3\\Library\\bin\\mkl_blacs_intelmpi_lp64.dll94157 WARNING: lib not found: pgf90rtl.dll dependency of D:\\Anaconda3\\Library\\bin\\mkl_pgi_thread.dll94167 WARNING: lib not found: pgc14.dll dependency of D:\\Anaconda3\\Library\\bin\\mkl_pgi_thread.dll94177 WARNING: lib not found: pgf90.dll dependency of D:\\Anaconda3\\Library\\bin\\mkl_pgi_thread.dll96204 WARNING: lib not found: impi.dll dependency of D:\\Anaconda3\\Library\\bin\\mkl_blacs_intelmpi_ilp64.dll97152 WARNING: lib not found: msmpi.dll dependency of D:\\Anaconda3\\Library\\bin\\mkl_blacs_msmpi_lp64.dll101534 WARNING: lib not found: api-ms-win-downlevel-shlwapi-l1-1-0.dll dependency of D:\\Anaconda3\\Library\\bin\\opencv_videoio342.dll102988 INFO: Looking for eggs102988 INFO: Using Python library D:\\Anaconda3\\python37.dll102989 INFO: Found binding redirects:[]103009 INFO: Warnings written to D:\\工程名\\build\\main\\warn-main.txt103213 INFO: Graph cross-reference written to D:\\工程名\\build\\main\\xref-main.html103297 INFO: checking PYZ103298 INFO: Building PYZ because PYZ-00.toc is non existent103298 INFO: Building PYZ (ZlibArchive) D:\\工程名\\build\\main\\PYZ-00.pyz105361 INFO: Building PYZ (ZlibArchive) D:\\工程名\\build\\main\\PYZ-00.pyz completed successfully.105453 INFO: checking PKG105453 INFO: Building PKG because PKG-00.toc is non existent105454 INFO: Building PKG (CArchive) PKG-00.pkg285478 INFO: Building PKG (CArchive) PKG-00.pkg completed successfully.285516 INFO: Bootloader D:\\Anaconda3\\lib\\site-packages\\PyInstaller\\bootloader\\Windows-64bit\\run.exe285518 INFO: checking EXE285534 INFO: Building EXE because EXE-00.toc is non existent285535 INFO: Building EXE from EXE-00.toc285548 INFO: Appending archive to EXE D:\\工程名\\dist\\main.exe286886 INFO: Building EXE from EXE-00.toc completed successfully. ==注意==在运行过程中有很多==WARNNING：==我们需要把这些都找出来放到一个新文件夹中如下所示：2.修改生成的main.spec文件，在其中修改位置做出修改如：hiddenimports=[‘MainUi.py’, ‘SecondUi’, ‘c57.py’],console=False , icon=’D:\\工程名\\systemcode\\logo.ico’如下图所示： 123456789101112131415161718192021222324252627282930313233# -*- mode: python ; coding: utf-8 -*-block_cipher = Nonea = Analysis(['D:\\\\工程名\\\\systemcode\\\\main.py'], pathex=['D:\\\\工程名'], binaries=[], datas=[], hiddenimports=['MainUi.py', 'SecondUi', 'c57.py'], #修改位置：添加其他.py文件 hookspath=[], runtime_hooks=[], excludes=[], win_no_prefer_redirects=False, win_private_assemblies=False, cipher=block_cipher, noarchive=False)pyz = PYZ(a.pure, a.zipped_data, cipher=block_cipher)exe = EXE(pyz, a.scripts, a.binaries, a.zipfiles, a.datas, [], name='main', debug=False, bootloader_ignore_signals=False, strip=False, upx=True, upx_exclude=[], runtime_tmpdir=None, console=False , icon='D:\\\\工程名\\\\systemcode\\\\logo.ico' ) #修改位置：添加图标位置 当我们修改完main.spec之后，对文件进行打包了，在命令框中输入如下命令（形如：pyinstaller -F -w -i D:\\工程名\\systemcode\\logo.ico main.spec）：点击运行过程如下： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899(base) D:\\工程名&gt;pyinstaller -F -w -i D:\\project\\systemcode\\logo.ico main.spec231 INFO: PyInstaller: 3.6232 INFO: Python: 3.7.3 (conda)233 INFO: Platform: Windows-10-10.0.18362-SP0240 INFO: UPX is not available.243 INFO: Extending PYTHONPATH with paths['D:\\\\工程名', 'D:\\\\工程名']243 INFO: checking Analysis256 INFO: Building because hiddenimports changed256 INFO: Initializing module dependency graph...276 INFO: Caching module graph hooks...286 INFO: Analyzing base_library.zip ...13046 INFO: Caching module dependency graph...13322 INFO: running Analysis Analysis-00.toc13353 INFO: Adding Microsoft.Windows.Common-Controls to dependent assemblies of final executable required by D:\\Anaconda3\\python.exe14102 INFO: Analyzing D:\\工程名\\systemcode\\main.py15118 INFO: Processing pre-find module path hook distutils15120 INFO: distutils: retargeting to non-venv dir 'D:\\\\Anaconda3\\\\lib'15864 INFO: Analyzing hidden import 'MainUi.py'15868 ERROR: Hidden import 'MainUi.py' not found15868 INFO: Analyzing hidden import 'SecondUi'15872 ERROR: Hidden import 'SecondUi' not found15872 INFO: Analyzing hidden import 'c57.py'15879 ERROR: Hidden import 'c57.py' not found15879 INFO: Processing module hooks...15880 INFO: Loading module hook \"hook-cv2.py\"...29174 INFO: Processing pre-safe import module hook setuptools.extern.six.moves32195 INFO: Processing pre-find module path hook site32197 INFO: site: retargeting to fake-dir 'D:\\\\Anaconda3\\\\lib\\\\site-packages\\\\PyInstaller\\\\fake-modules'50105 INFO: Loading module hook \"hook-distutils.py\"...50108 INFO: Loading module hook \"hook-encodings.py\"...50502 INFO: Loading module hook \"hook-importlib_metadata.py\"...50508 INFO: Loading module hook \"hook-lib2to3.py\"...50518 INFO: Loading module hook \"hook-numpy.core.py\"...50826 INFO: MKL libraries found when importing numpy. Adding MKL to binaries50847 INFO: Loading module hook \"hook-numpy.py\"...50849 INFO: Loading module hook \"hook-pkg_resources.py\"...53673 INFO: Processing pre-safe import module hook win32com54626 INFO: Excluding import '__main__'54628 INFO: Removing import of __main__ from module pkg_resources54629 INFO: Loading module hook \"hook-pycparser.py\"...54630 INFO: Loading module hook \"hook-pydoc.py\"...54632 INFO: Loading module hook \"hook-PyQt5.py\"...55169 INFO: Loading module hook \"hook-PyQt5.QtCore.py\"...55386 INFO: Loading module hook \"hook-PyQt5.QtGui.py\"...55830 INFO: Loading module hook \"hook-PyQt5.QtWidgets.py\"...56219 INFO: Loading module hook \"hook-pytest.py\"...60422 INFO: Loading module hook \"hook-pythoncom.py\"...62380 INFO: Loading module hook \"hook-pywintypes.py\"...64671 INFO: Loading module hook \"hook-scipy.py\"...64679 INFO: Loading module hook \"hook-setuptools.py\"...67959 INFO: Loading module hook \"hook-sysconfig.py\"...67962 INFO: Loading module hook \"hook-win32com.py\"...70088 INFO: Loading module hook \"hook-xml.dom.domreg.py\"...70090 INFO: Loading module hook \"hook-xml.etree.cElementTree.py\"...70092 INFO: Loading module hook \"hook-xml.py\"...70166 INFO: Looking for ctypes DLLs70414 INFO: Analyzing run-time hooks ...70424 INFO: Including run-time hook 'pyi_rth_pyqt5.py'70426 INFO: Including run-time hook 'pyi_rth_multiprocessing.py'70433 INFO: Including run-time hook 'pyi_rth_pkgres.py'70440 INFO: Including run-time hook 'pyi_rth_win32comgenpy.py'70474 INFO: Looking for dynamic libraries70552 WARNING: lib not found: msmpi.dll dependency of D:\\Anaconda3\\Library\\bin\\mkl_blacs_msmpi_ilp64.dll70770 WARNING: lib not found: mpich2mpi.dll dependency of D:\\Anaconda3\\Library\\bin\\mkl_blacs_mpich2_ilp64.dll71062 WARNING: lib not found: impi.dll dependency of D:\\Anaconda3\\Library\\bin\\mkl_blacs_intelmpi_ilp64.dll71619 WARNING: lib not found: pgc14.dll dependency of D:\\Anaconda3\\Library\\bin\\mkl_pgi_thread.dll71628 WARNING: lib not found: pgf90rtl.dll dependency of D:\\Anaconda3\\Library\\bin\\mkl_pgi_thread.dll71637 WARNING: lib not found: pgf90.dll dependency of D:\\Anaconda3\\Library\\bin\\mkl_pgi_thread.dll72151 WARNING: lib not found: msmpi.dll dependency of D:\\Anaconda3\\Library\\bin\\mkl_blacs_msmpi_lp64.dll72204 WARNING: lib not found: impi.dll dependency of D:\\Anaconda3\\Library\\bin\\mkl_blacs_intelmpi_lp64.dll72244 WARNING: lib not found: mpich2mpi.dll dependency of D:\\Anaconda3\\Library\\bin\\mkl_blacs_mpich2_lp64.dll74930 WARNING: lib not found: api-ms-win-downlevel-shlwapi-l1-1-0.dll dependency of D:\\Anaconda3\\Library\\bin\\opencv_videoio342.dll75978 INFO: Looking for eggs75978 INFO: Using Python library D:\\Anaconda3\\python37.dll75979 INFO: Found binding redirects:[]76044 INFO: Warnings written to D:\\工程名\\build\\main\\warn-main.txt76265 INFO: Graph cross-reference written to D:\\工程名\\build\\main\\xref-main.html76316 INFO: checking PYZ76329 INFO: Building because toc changed76329 INFO: Building PYZ (ZlibArchive) D:\\工程名\\build\\main\\PYZ-00.pyz79360 INFO: Building PYZ (ZlibArchive) D:\\工程名\\build\\main\\PYZ-00.pyz completed successfully.79392 INFO: checking PKG79397 INFO: Building because toc changed79397 INFO: Building PKG (CArchive) PKG-00.pkg228706 INFO: Building PKG (CArchive) PKG-00.pkg completed successfully.228720 INFO: Bootloader D:\\Anaconda3\\lib\\site-packages\\PyInstaller\\bootloader\\Windows-64bit\\runw.exe228720 INFO: checking EXE228727 INFO: Building because console changed228727 INFO: Building EXE from EXE-00.toc228840 INFO: Copying icons from ['D:\\\\工程名\\\\systemcode\\\\logo.ico']228924 INFO: Writing RT_GROUP_ICON 0 resource with 20 bytes228924 INFO: Writing RT_ICON 1 resource with 4264 bytes228935 INFO: Updating manifest in D:\\工程名\\build\\main\\runw.exe.t4_sreaw229409 INFO: Updating resource type 24 name 1 language 0229415 INFO: Appending archive to EXE D:\\工程名\\dist\\main.exe230034 INFO: Building EXE from EXE-00.toc completed successfully. 打包成功！！！在生成的dist文件夹中生成了打包好的.exe文件如下图所示：点击main.exe，正常运行。你以为这就完了（当时我也是怎么以为），此时我们需要把生成的main.exe文件放入刚才新建的文件夹中如下图所示：然后关掉你的PyCharm，如果可以正常运行，这样就真的可以了。END","updated":"2020-07-23T12:10:37.903Z","categories":[{"name":"Python","slug":"Python","permalink":"http://yoursite.com/categories/Python/"}],"tags":[{"name":"pyinstaller","slug":"pyinstaller","permalink":"http://yoursite.com/tags/pyinstaller/"}]},{"title":"Python可运行文件安装包制作","date":"2020-07-23T12:01:00.000Z","path":"2020/07/23/Python可运行文件安装包制作/","text":"Hello World! 安装包制作1.制作前准备a.软件：Advanced Installerb.已经做好的可执行文件（.EXE）c.其他程序扩展文件 2.开始制作安装包打开软件按如下步骤进行：新建工程安装界面样式有很多种：安装成功：在制作安装包其他可能需要的步骤是：END","updated":"2020-07-23T12:12:27.274Z","categories":[{"name":"Python","slug":"Python","permalink":"http://yoursite.com/categories/Python/"}],"tags":[{"name":"工具","slug":"工具","permalink":"http://yoursite.com/tags/%E5%B7%A5%E5%85%B7/"},{"name":"可运行文件","slug":"可运行文件","permalink":"http://yoursite.com/tags/%E5%8F%AF%E8%BF%90%E8%A1%8C%E6%96%87%E4%BB%B6/"}]},{"title":"Python可运行文件加密方法","date":"2020-07-23T12:00:58.000Z","path":"2020/07/23/Python可运行文件加密方法/","text":"Hello World! 软件加密==软件：==1.EXE ResPacker 2.做好的可运行文件或安装包加密方法：【步骤】1、指定要打包的软件源目录；1、指定EXE主程序；2、指定加密后文件输出目录。3、设置加密密钥；4、开始打包;==备注==：不一定能保证软件绝对安全！！！打包生成一个可以独立运行的exe文件，您可以将此打包后的文件分发给用户。界面如下图所示：用户打开您打包的文件时会弹出一个认证框，要求用户输入开启密码才可以打开如下图所示：，此认证框中显示有用户的机器码，用户将他的机器码发给你，你根据用户机器码为他创建开启密码，如下图所示：【创建开启密码】1、指定加密时使用的加密密钥;2、指定用户的机器码;3、创建开启密码；开启密码发给用户，用户只能在自己的电脑上运行你的软件。比如：END","updated":"2020-07-23T12:13:40.797Z","categories":[],"tags":[{"name":"工具","slug":"工具","permalink":"http://yoursite.com/tags/%E5%B7%A5%E5%85%B7/"},{"name":"文件加密","slug":"文件加密","permalink":"http://yoursite.com/tags/%E6%96%87%E4%BB%B6%E5%8A%A0%E5%AF%86/"}]},{"title":"PyQt5安装及Qt designer ，PyUIC工具的配置","date":"2020-07-23T12:00:56.000Z","path":"2020/07/23/PyQt5安装及Qt-designer-，PyUIC工具的配置/","text":"Hello World! PyQt5安装==PyQt5==主要是用在==Python GUI界面开发==,可以不用纯代码编写界面(偷懒方便或技术不行),这时可以利用PyQt5来完成Python图形界面的开发。下面我们来谈谈在PyCharm下的PyQt5安装过程（Windows环境下）： 1.安装 sipsip属于python依赖库（直接使用命令安装），是RiverBank（也就是PyQt的开发商）开发的用于PyQt的Python/C++混合编程解决方案。它包括一个sip工具、SDK以及Python Module。在windows的命令行窗口输入如下命令安装： 1pip install sip 2.PyQt52.1 安装 PyQt5PyQt5是python的一个插件库,通过这个库我们可以连接Qt和Python来进行GUI编程。==注意==：安装的版本问题PyQt5只有针对==Python3.x==的安装包而没有针对python2的安装版本。在windows的命令行窗口输入如下命令安装： 1Pip install –user d:\\ PyQt5-5.10-5.10.0-cp35.cp36.cp37-none-win_amd64.whl 或者： 1pip3 install PyQt5 2.2 安装 PyQt5-tools在windows的命令行窗口输入如下命令安装： 1pip install PyQt5-tools 安装完成后，我们可以在Python或者 Anaconda安装目录下看到 相应的文件。 3.PyCharm中的配置==目的==：在PyCharm里面实现打开Qt designer，然后生成Qt文件，并通过PyUIC将qt文件转换成python语言的软件文件直接使用，实现代码分离。配置过程如下图所示：点击File—&gt;Tools—&gt;External Tools后，点击==绿色的+==，添加Tools 完成如下配置：进行Qt designer的配置：|Name |Qt designer ||–|–||Program | 指向安装PyQt5-tools文件夹里面的designer.exe ||Work directory | $FileDir$ |然后新建“PyUIC”，配置如下图所示：| Name |PyUIC ||–|–|| Program | 指向文件里面的python.exe || Arguments | -m PyQt5.uic.pyuic $FileName$ -o $FileNameWithoutExtension$.py（固定代码） || Work directory| $FileDir$ |配置完成如下图所示： 4.测试通过Extrernal Tools打开Qt designer如下图所示：在界面中绘制如下图形测试：在左侧工程栏中会出现cjw.ui文件（前提是保存在当前工程下），之后鼠标右键点击选中Extrernal Tools中的PyUIC则会左侧工程栏自动生成一个cjw.py文件如下图所示：测试的界面代码如下： 12345678910111213141516171819202122232425262728293031323334353637# -*- coding: utf-8 -*-# Form implementation generated from reading ui file 'cjw.ui'## Created by: PyQt5 UI code generator 5.13.0## WARNING! All changes made in this file will be lost!from PyQt5 import QtCore, QtGui, QtWidgetsclass Ui_MainWindow1(object): def setupUi(self, MainWindow): MainWindow.setObjectName(\"MainWindow\") MainWindow.resize(1179, 912) self.centralwidget = QtWidgets.QWidget(MainWindow) self.centralwidget.setObjectName(\"centralwidget\") self.textBrowser = QtWidgets.QTextBrowser(self.centralwidget) self.textBrowser.setGeometry(QtCore.QRect(490, 170, 111, 51)) self.textBrowser.setObjectName(\"textBrowser\") MainWindow.setCentralWidget(self.centralwidget) self.statusbar = QtWidgets.QStatusBar(MainWindow) self.statusbar.setObjectName(\"statusbar\") MainWindow.setStatusBar(self.statusbar) self.retranslateUi(MainWindow) QtCore.QMetaObject.connectSlotsByName(MainWindow) def retranslateUi(self, MainWindow): _translate = QtCore.QCoreApplication.translate MainWindow.setWindowTitle(_translate(\"MainWindow\", \"MainWindow\")) self.textBrowser.setHtml(_translate(\"MainWindow\", \"&lt;!DOCTYPE HTML PUBLIC \\\"-//W3C//DTD HTML 4.0//EN\\\" \\\"http://www.w3.org/TR/REC-html40/strict.dtd\\\"&gt;\\n\"\"&lt;html&gt;&lt;head&gt;&lt;meta name=\\\"qrichtext\\\" content=\\\"1\\\" /&gt;&lt;style type=\\\"text/css\\\"&gt;\\n\"\"p, li &#123; white-space: pre-wrap; &#125;\\n\"\"&lt;/style&gt;&lt;/head&gt;&lt;body style=\\\" font-family:\\'SimSun\\'; font-size:9pt; font-weight:400; font-style:normal;\\\"&gt;\\n\"\"&lt;p style=\\\" margin-top:0px; margin-bottom:0px; margin-left:0px; margin-right:0px; -qt-block-indent:0; text-indent:0px;\\\"&gt;&lt;span style=\\\" font-size:26pt; font-weight:600; font-style:italic;\\\"&gt;PyQt5&lt;/span&gt;&lt;/p&gt;&lt;/body&gt;&lt;/html&gt;\")) 新建一个测试运行代码文件如下： 12345678910111213# 测试PyQt5运行 CJWfrom PyQt5.QtWidgets import QApplication, QMainWindowimport sysfrom cjw import Ui_MainWindow1if __name__=='__main__': app = QApplication(sys.argv) MainWindow = QMainWindow() ui = Ui_MainWindow1() ui.setupUi(MainWindow) MainWindow.show() sys.exit(app.exec_()) 配置好路径后点击运行上述文件，结果如下：Pyqt5安装成功！！！END","updated":"2020-07-23T12:14:55.479Z","categories":[{"name":"PyQt5","slug":"PyQt5","permalink":"http://yoursite.com/categories/PyQt5/"}],"tags":[{"name":"工具","slug":"工具","permalink":"http://yoursite.com/tags/%E5%B7%A5%E5%85%B7/"},{"name":"GUI","slug":"GUI","permalink":"http://yoursite.com/tags/GUI/"}]},{"title":"Python类库和模块的安装","date":"2020-07-23T12:00:55.000Z","path":"2020/07/23/Python类库和模块的安装/","text":"Hello World! 在Python中除了Python自带的的类库以外，其他类库均需我们自己下载安装。在利用PyCharm进行编程时，系统会提示对没有下载的包的安装。此外，我们还可以利用pip命令完成所需包的安装。 pip命令pip是Python自带的包管理工具，全称是python install pakeage，在使用Python开发的过程中,除了它自带的类库。几乎所有的第三方类库，均可以通过pip来安装，而且它可以随时地更新Python的类库。| 命令 | 说明 ||–|–||pip install xxx |windows下安装某某第三方类库 ||pip3 install xxx |windows下安装某某第三方类库 ||brew install xxx |Mac下安装某个程序或者文件 |==备注==：pip3是python3.0之后出来的pip进阶版本，如果电脑安装python3.x的时候,就可以使用pip3命令,同时也可以使用pip命令。此外pip3命令安装的库默认出现在python3.x版本的文件夹中。Homebrew是Mac系统上的包管理工具，只要是能在Mac上安装的东西，都可以通过Homebrew来安装和管理，并且可以及时的对其进行更新。（不常用）在windows的命令行窗口输入对应的命令安装相应的第三方类库：如安装sklearn库（用来进行ML的库）首先打开命令行窗口：在命令行输入pip install sklearn后回车即可，如下图所示：sklearn类库安装成功！！！ 模块和第三方类库模块是一个包含所有你定义的函数和变量的文件，其后缀名是.py#导入模块import support#现在可以调用模块里包含的函数了support.print_func(“Runoob”)标准模块如：math，random END","updated":"2020-07-23T12:15:55.571Z","categories":[{"name":"Python","slug":"Python","permalink":"http://yoursite.com/categories/Python/"}],"tags":[{"name":"工具","slug":"工具","permalink":"http://yoursite.com/tags/%E5%B7%A5%E5%85%B7/"}]},{"title":"PyQt5界面设计问题","date":"2020-07-23T12:00:53.000Z","path":"2020/07/23/PyQt5界面设计问题/","text":"Hello World! PyQt5界面设计问题及解决办法最近在做有关界面的项目遇到一些问题，在这里把遇到的一些问题做一个总结 1.窗体设计样式问题123self.setStyleSheet(\"#MainWindow&#123;background-color: white&#125;\")self.setWindowTitle('XXX软件v1.0')self.setWindowIcon(QIcon('D:/系统v1.0/systemcode/images/icon1.png')) # 设置窗体标题图标 2.文本显示问题12self.label_state.setText(\"CJW\") # 当前状态self.label_state.setStyleSheet(\"font:15pt '楷体';color:red\") # 控件样式 3.控件传值问题123angle = self.doubleSpinBox.value() # 角度值传递self.labeljiaodu.setText(\"\" + str(angle)) # 角度显示self.labeljiaodu.setText(\"\" + str(('%.3f' %angle))) # 保留3位有效数字 4.字体显示问题（在其它电脑打开会出现字样重叠）123456if __name__ == '__main__': QtCore.QCoreApplication.setAttribute(QtCore.Qt.AA_EnableHighDpiScaling) # Qt从5.6.0开始，支持High-DPI（插入这句code，必须放在创建QApplication项目之前） app = QApplication(sys.argv) md = MainCode() md.show() sys.exit(app.exec_()) 5.提示框问题12345QMessageBox.information(self, \"XXXX提示框\", \"当前XXXX异常！！！\", QMessageBox.Yes | QMessageBox.No)if QMessageBox.Yes: .......... 6.按钮图标问题1234567self.button_begin.setIcon(QIcon(\"D:/软件v1.0/systemcode/images/512.png\")) # 设置图标self.button_begin.setStyleSheet(\"QPushButton&#123;color:black&#125;\" \"QPushButton:hover&#123;color:red&#125;\" \"QPushButton&#123;background-color:lightgreen&#125;\" \"QPushButton&#123;border:2px&#125;\" \"QPushButton&#123;border-radius:10px&#125;\" \"QPushButton&#123;padding:2px 4px&#125;\") # 设置按钮样式 7.语音提示问题123import win32com.clientspeak = win32com.client.Dispatch('SAPI.SPVOICE')speak.Speak('CJW') 8.蜂鸣器设置问题1234import winsoundduration = 150 # 持续时间freq = 1000 # Hzwinsound.Beep(freq, duration) 9.doubleSpinBox等控件禁止编辑1234self.doubleSpinBox.setFocusPolicy(QtCore.Qt.NoFocus)self.doubleSpinBox_2.setFocusPolicy(QtCore.Qt.NoFocus)self.doubleSpinBox.setSingleStep(0.0)self.doubleSpinBox_2.setSingleStep(0.0) 10.窗口居中问题1234567891011121314151617181920212223242526272829303132# 窗口居中import sysfrom PyQt5 import QtWidgetsfrom PyQt5.QtWidgets import QDesktopWidgetclass CJW(QtWidgets.QWidget): def __init__(self, parent=None): QtWidgets.QWidget.__init__(self, parent) self.setWindowTitle('窗口居中实例') # 设置窗口的尺寸 self.resize(250, 250) self.center()# 窗口居中函数 def center(self): # 计算出显示器的分辨率(screen.width() * screen.height()) screen = QDesktopWidget().screenGeometry() # 获取QWidget窗口的大小(size.width()* size.heiget()) size = self.geometry() # 窗口移动到屏幕的中间位置 self.move((screen.width() - size.width()) / 2, (screen.height() - size.height()) / 2)if __name__ == \"__main__\": app = QtWidgets.QApplication(sys.argv) md = CJW() md.show() sys.exit(app.exec_()) 11.禁止窗口最大化和禁止窗口拉伸12345678class MainCode(QMainWindow, MainUi.Ui_MainWindow): def __init__(self): QMainWindow.__init__(self) MainUi.Ui_MainWindow.__init__(self) self.setupUi(self) self.setFixedSize(self.width(), self.height()) self.resize(1138, 678) .......................... 或 123# 1、方法setWindowFlags,选择哪些按钮生效，每个窗体应该都有# 2、通过 | 来同时显现多个按钮Form.setWindowFlags(QtCore.Qt.WindowCloseButtonHint|QtCore.Qt.WindowMinimizeButtonHint) 未完待续…….","updated":"2020-07-23T12:16:55.444Z","categories":[{"name":"PyQt5","slug":"PyQt5","permalink":"http://yoursite.com/categories/PyQt5/"}],"tags":[{"name":"工具","slug":"工具","permalink":"http://yoursite.com/tags/%E5%B7%A5%E5%85%B7/"},{"name":"GUI","slug":"GUI","permalink":"http://yoursite.com/tags/GUI/"}]},{"title":"PyCharm连接MySQL数据库安装过程及常见问题的解决办法","date":"2020-07-23T12:00:51.000Z","path":"2020/07/23/PyCharm连接MySQL数据库安装过程及常见问题的解决办法/","text":"Hello World! 首先对于PyCharm社区版来说，在侧面和View的工具窗口中没有database，如果要与数据库连接需要下载以下几个内容：1.MySQL数据库(下载并配置好)2.pymysql 1pip install pymysql 3.DataBase 安装完成后会在PyCharm的工具栏多出一个DB Navigator：点击 + 选择或删除对应的数据库: 之后填入与数据库一致的用户名和密码:然后配置==驱动jdbc(关键)==：在本地文件夹中导入下载好的驱动（注意数据库版本：低版本对应低版本的驱动，不然会报错）报错原因：版本不一致导致时差问题The server time zone value ‘ÖÐ¹ú±ê×¼Ê±¼ä’ is unrecognized or represents more than one time zone. You must configure either the server or JDBC driver (via the serverTimezone configuration property) to use a more specifc time zone value if you want to utilize time zone support.方法一：版本对应；方法二：修改数据库中的配置文件my,ini,添加代码：default-time_zone = ‘+8:00’测试连接：修改Name然后按确定退出弹出提示：点击Connection连接成功！！！ END","updated":"2020-07-23T12:18:00.044Z","categories":[{"name":"Pycharm","slug":"Pycharm","permalink":"http://yoursite.com/categories/Pycharm/"}],"tags":[{"name":"工具","slug":"工具","permalink":"http://yoursite.com/tags/%E5%B7%A5%E5%85%B7/"},{"name":"MySQL","slug":"MySQL","permalink":"http://yoursite.com/tags/MySQL/"}]},{"title":"Python获取时间间隔实现定时任务","date":"2020-07-23T12:00:49.000Z","path":"2020/07/23/Python获取时间间隔实现定时任务/","text":"Hello World! 1. datatime模块datetime模块是Python自带对时间的操作，常用的四类分别是date、time、datetime、timedelta.具体可参考: Python datetime模块详解、示例. 2. 获取时间间隔1234567import datatimedt1 = datetime.datetime.now()dt2 = datetime.datetime(2020, 5, 5,19,30,6,00000) # year, month, day,hour,minate,sec,usspan = dt2 - dt1time_span = round(span.total_seconds(), 1) # 保留一位小数print('当前时间间隔：', time_span) 通过判断时间间隔来控制相关函数实现每隔固定时间执行一次，比如可以以time_span%60==0来作为判断条件等等来控制定时任务的执行，当然也有其他的定时调度函数或者模块比如timer，threading、apscheduler等。这里的定时任务是隔一分钟向数据库插入一条数据，实现效果如下图所示： END","updated":"2020-07-23T12:18:59.122Z","categories":[{"name":"Python","slug":"Python","permalink":"http://yoursite.com/categories/Python/"}],"tags":[{"name":"datetime","slug":"datetime","permalink":"http://yoursite.com/tags/datetime/"}]},{"title":"利用pymysql操纵MySQl数据库","date":"2020-07-23T12:00:48.000Z","path":"2020/07/23/利用pymysql操纵MySQl数据库/","text":"Hello World! MyEnvironment pymysql MySQL PyCharm Python3.x pymysqlpymysql是一个使Python连接到数据库的模块，它是一个纯Python库，利用pymysql可以直接通过编写数据库的语句来操纵MySQL数据库完成一系列操作。 安装pysql:(安装方式有多种) 1pip install pymysql 通过输入以下代码至电脑命令控制台可查看是否安装成功： 1pip3 show PyMySQL 实现数据库的相关操作首先要与数据库建立连接： 123# 打开数据库连接（IP地址/数据库用户名/登录密码/编码方式/端口号）database = pymysql.connect(host='localhost', user='root', passwd='123456', charset='utf8', port=3306) 获取游标： 1cur = database.cursor() 之后需要建立数据库和数据表：（存在就不创建，防止异常） 1234567sql = \"CREATE DATABASE IF NOT EXISTS project\"# 执行创建数据库的sqlcur.execute(sql)# 使用数据库projectcur.execute(\"use project;\")# 创建数据库表datacur.execute(\"CREATE TABLE IF NOT EXISTS data(time timestamp primary key NOT NULL,money float NOT NULL,name varchar(30))character set utf8;\") 数据库插入数据操作： 123sql_insert = \"\"\"INSERT INTO OperationRecord VALUES( %s, %s, %s)\"\"\"data = (datetime.datetime.now().strftime(\"%Y-%m-%d %H:%M:%S\"), 100000, '老王')cur.execute(sql_insert, data) 提交插入的数据： 1database.commit() 这里我们也可以这样写： 123456789try: print('--开始插入--') cur.execute(sql_insert, data) database.commit()except Exception as e: database.rollback() print('---成功插入---')finally: database.close() 数据库更新数据列操作： 12345678910sql_update = \"update project.data set name = '%s' where money = '%s'\"try: print('开始更新') cur_update.execute(sql_update % (\"update_time\", \"update_money\", \"update_name\")) database.commit()except Exception as e: database.rollback() print('更新操作错误')finally: database.close() 数据库删除数据列操作： 1234567891011sql_delete = \"delete from project.data where name = '%s'\"try: print('开始删除操作') cur_delete.execute(sql_delete % (\"update_name\")) # 像sql语句传递参数 database.commit()except Exception as e: database.rollback() print('数据库删除操作错误')finally: database.close() 数据库查询数据操作： 1234567891011121314151617# sql查询语句 表名datasql = \"select * from data\"try: cur.execute(sql) # 执行sql语句 results = cur.fetchall() # 获取查询的所有记录 print(\"time\", \"money\", \"name\") # 遍历结果 for row in results: time = row[0] money = row[1] name = row[2] print(time, money, name)except Exception as e: raise efinally: db.close() # 关闭连接 END","updated":"2020-07-23T12:19:29.880Z","categories":[{"name":"Python","slug":"Python","permalink":"http://yoursite.com/categories/Python/"}],"tags":[{"name":"MySQL","slug":"MySQL","permalink":"http://yoursite.com/tags/MySQL/"},{"name":"pymysql","slug":"pymysql","permalink":"http://yoursite.com/tags/pymysql/"}]},{"title":"打包可运行文件时图标无法显示的解决方法","date":"2020-07-23T12:00:46.000Z","path":"2020/07/23/打包可运行文件时图标无法显示的解决方法/","text":"Hello World! Power:PyCharm、PyQt5（pyrcc5） 1.把用到的图片文件放到工程所处的文件夹下2.在工程中新建TEXT格式文件，命名为resource.txt3.Notepad++编辑resource.txt，插入一下代码（注意相对路径和绝对路径）后保存后更改文件后缀名为resource.qrc 12345678&lt;RCC&gt; &lt;qresource prefix=\"/\"&gt; &lt;file&gt;资源名&lt;/file&gt; &lt;file&gt;资源名&lt;/file&gt; &lt;file&gt;资源名&lt;/file&gt; &lt;file&gt;资源名&lt;/file&gt; &lt;/qresource&gt;&lt;/RCC&gt; 4.使用pyrcc5进行转换得到.py文件（pyrcc5是PyQt5的附带工具）,打开PyCharm控制台输入： 1pyrcc5 -o resource.py resource.qrc 转换成功：5.将装换后的resource.py引入主程序中 1import resource 6.在程序中的写法：注意：==资源名称还是原来的名称，前面的“：”冒号不能少== 12self.setWindowIcon(QIcon(':/icon1.png')) # 设置窗体标题图标self.button.setIcon(QIcon(\":/520.png\")) 7.最后使用pyinstaller打包可运行文件: Python项目之多文件打包为可运行文件 END","updated":"2020-07-24T06:48:03.983Z","categories":[{"name":"Python","slug":"Python","permalink":"http://yoursite.com/categories/Python/"}],"tags":[{"name":"可运行文件","slug":"可运行文件","permalink":"http://yoursite.com/tags/%E5%8F%AF%E8%BF%90%E8%A1%8C%E6%96%87%E4%BB%B6/"},{"name":"pyinstaller","slug":"pyinstaller","permalink":"http://yoursite.com/tags/pyinstaller/"}]},{"title":"PyQt5开发第二界面或弹出界面（子窗口）","date":"2020-07-23T12:00:44.000Z","path":"2020/07/23/PyQt5开发第二界面或弹出界面（子窗口）/","text":"Hello World! My Environment Python 3.x pyqt5 Qt designer PyUIC 各种轮子 实现方式通过==点击父窗口（主界面）的按钮打开子窗口（二界面）==，为防止操作失误或程序自身问题造成的闪退，最好自己开发时加上异常处理机制。 实现过程 首先设计二界面（子窗口）后生成.py文件，将设计好的二界面（子窗口）引入主界面当中12345678910# 二界面class SecondCode(QMainWindow, SecondUi.Ui_MainWindow): def __init__(self): QMainWindow.__init__(self) SecondUi.Ui_MainWindow.__init__(self) self.setupUi(self) self.setWindowTitle('二界面') self.setWindowIcon(QIcon('icon.png')) # 设置窗体标题图标 ... ... 通过主界面按钮打开二界面（当然前提必须先在主界面中设计好这个触发按钮）： 1self.button_opensecond.clicked.connect(button_opensecond_clicked) # 打开二界面按钮方法连接 12345678910# # 打开 second 界面 windowList = [] # 窗口扩展数组 def button_opensecond_clicked(self)： the_window = SecondCode() self.windowList.append(the_window) # 不可删 the_window.show() # ... # 二界面的属性和方法 # ... 优点：可以在这个基础上扩展出多个弹出界面 3.点击按钮就可以从父窗口打开子窗口 实现效果点击主界面按钮后，二界面弹出，主界面此时依然在。 END","updated":"2020-07-24T06:47:50.198Z","categories":[{"name":"PyQt5","slug":"PyQt5","permalink":"http://yoursite.com/categories/PyQt5/"}],"tags":[{"name":"工具","slug":"工具","permalink":"http://yoursite.com/tags/%E5%B7%A5%E5%85%B7/"},{"name":"GUI","slug":"GUI","permalink":"http://yoursite.com/tags/GUI/"}]},{"title":"QTableWidget读取数据库数据实现界面可视化","date":"2020-07-23T12:00:43.000Z","path":"2020/07/23/QTableWidget读取数据库数据实现界面可视化/","text":"Hello World! My Environment Python 3.x Pyqt5 MySQL数据库 Qt designer PyUIC 各种轮子 实现方式利用pymysql查到数据后，将数据在界面的tableWidget中展示出来最终效果： 实现过程1.首先需要先在界面中设计好表格及样式（包含隔行变色等） 12345678# 表格样式self.tableWidget.setStyleSheet(\"QTableWidget::item:hover&#123;background-color:rgb(92,188,227,200)&#125;\" \"QTableWidget::item:selected&#123;background-color:#1B89A1&#125;\" \"QHeaderView::section,QTableCornerButton:section&#123; \\ padding:3px; margin:0px; color:#DCDCDC; border:1px solid #242424; \\ border-left-width:0px; border-right-width:1px; border-top-width:0px; border-bottom-width:1px; \\ background:qlineargradient(spread:pad,x1:0,y1:0,x2:0,y2:1,stop:0 #646464,stop:1 #525252); &#125;\" \"QTableWidget&#123;alternate-background-color:#A9F5E1; background: white; color: #6b6d7b; 样式效果：修改配色可参考： 色彩表格工具.其他表格样式配置： 123456 # 设置行表头self.tableWidget.setHorizontalHeaderLabels([\"XXXX\", \"XXXX\", \"XXXX\"])# 表格禁止编辑self.tableWidget.setEditTriggers(QAbstractItemView.NoEditTriggers)# 行间隔变色（boolen）self.tableWidget.setAlternatingRowColors(1) 2.配置好数据库，确保能建立连接后开始查询操作(通过按钮绑定时间发起) 1234567891011121314151617181920212223242526# 打开数据库连接（IP地址/数据库用户名/登录密码/数据库模式名/编码方式/端口号）database = pymysql.connect(host='localhost', user='tree', password='5201314', db=\"databasename\", charset='utf8', port=3306) cur = database.cursor() # 数据库查询操作 cur.execute('select * from tablename') rows = cur.fetchall() # 取得记录个数，用于设置表格的行数 row = cur.rowcount # 取得字段数，用于设置表格的列数 vol = len(rows[0]) cur.close() database.close() self.tableWidget.setRowCount(row) self.tableWidget.setColumnCount(vol) for i in range(row): for j in range(vol): # 临时记录，不能直接插入表格 temp_data = rows[i][j] # 转换后可插入表格 data = QTableWidgetItem(str(temp_data)) self.tableWidget.setItem(i, j, data) self.button_sql.setText('刷新记录') END","updated":"2020-07-24T06:47:35.660Z","categories":[{"name":"PyQt5","slug":"PyQt5","permalink":"http://yoursite.com/categories/PyQt5/"}],"tags":[{"name":"工具","slug":"工具","permalink":"http://yoursite.com/tags/%E5%B7%A5%E5%85%B7/"},{"name":"GUI","slug":"GUI","permalink":"http://yoursite.com/tags/GUI/"}]},{"title":"PyQt5窗口退出X函数事件个性化设置","date":"2020-07-23T12:00:41.000Z","path":"2020/07/23/PyQt5窗口退出X函数事件个性化设置/","text":"Hello World! 窗口退出X函数事件个性化My Environment Python 3.x Pyqt5 Qt designer PyUIC 实现方式：通过重写Qwidget类中的closeEvent方法，实现功能效果 实现过程 首先设计好界面 重写方法closeEvent123456789101112# # 退出系统窗口 X 绑定函数事件 def closeEvent(self, e): self.box = QMessageBox(QMessageBox.Warning, \"系统提示信息\", \"是否退出系统？\") qyes = self.box.addButton(self.tr(\"是\"), QMessageBox.YesRole) qno = self.box.addButton(self.tr(\"否\"), QMessageBox.NoRole) self.box.exec_() if self.box.clickedButton() == qyes: e.accept() QtWidgets.QWidget.closeEvent(self, e) sys.exit().accept() else: e.ignore() 实现效果点击窗口X后弹出提示信息，通过点击按钮选择退出与否除此之外也可以在窗口中设置退出按钮来退出窗口，具体可参考链接: PyQt5通过绑定按钮事件实现点击后退出（含提示框）. END","updated":"2020-07-24T06:47:16.658Z","categories":[{"name":"PyQt5","slug":"PyQt5","permalink":"http://yoursite.com/categories/PyQt5/"}],"tags":[{"name":"工具","slug":"工具","permalink":"http://yoursite.com/tags/%E5%B7%A5%E5%85%B7/"},{"name":"GUI","slug":"GUI","permalink":"http://yoursite.com/tags/GUI/"}]},{"title":"PyQt5通过绑定按钮事件实现点击后退出（含提示框）","date":"2020-07-23T12:00:39.000Z","path":"2020/07/23/PyQt5通过绑定按钮事件实现点击后退出（含提示框）/","text":"Hello World! 绑定按钮点击实现退出事件（含提示框）My Environment Python 3.x Pyqt5 Qt designer PyUIC 实现过程 首先设计好界面及按钮 新建一个按钮点击函数 12345678910def button_close_clicked(self): self.box = QMessageBox(QMessageBox.Warning, \"系统提示信息\", \"是否退出系统？\") qyes = self.box.addButton(self.tr(\"是\"), QMessageBox.YesRole) qno = self.box.addButton(self.tr(\"否\"), QMessageBox.NoRole) self.box.exec_() if self.box.clickedButton() == qyes: sys.exit().accept() else: return 为界面按钮绑定按钮点击事件： 1self.button_close.clicked.connect(self.button_close_clicked) # 退出系统按钮 实现效果通过点击界面按钮弹出提示框，然后通过点击提示框按钮选择退出与否此外，通过点击窗口 X 退出可参考链接: PyQt5窗口退出X函数事件个性化设置. END","updated":"2020-07-24T06:47:00.744Z","categories":[{"name":"PyQt5","slug":"PyQt5","permalink":"http://yoursite.com/categories/PyQt5/"}],"tags":[{"name":"工具","slug":"工具","permalink":"http://yoursite.com/tags/%E5%B7%A5%E5%85%B7/"},{"name":"GUI","slug":"GUI","permalink":"http://yoursite.com/tags/GUI/"}]},{"title":"PyQt5下拉框及其点击事件绑定","date":"2020-07-23T12:00:37.000Z","path":"2020/07/23/PyQt5下拉框及其点击事件绑定/","text":"Hello World! PyQt5下拉框及其点击事件绑定My Environment Python 3.x Pyqt5 Qt designer PyUIC 最终效果描述通过点击下拉框选中信息显示在界面指定区域上，可以应用于在界面指定区域显示图像、文字、表格、数据库查询等方面。 实现过程1.需要自己设计好QComboBox下拉框（通过Qt designer ，也可以直接手写）及其他组件2.了解QComboBox类常用的信号及方法|信号|描述 ||–|–||Activated | 选中下拉选项时发射信号||currentIdexChanged | 当下拉选项索引发生变化时发射信号 ||highlighted | 当选中已选中的下拉框时发射信号 |3.新建下拉框相关函数test：（展示图片、文字、数据库查询（需要自己连接数据库，未提供数据库连接代码，可参考链接: 利用pymysql操纵MySQl数据库.）） 12#[str] 表示comboBox中的选择框内容self.comboBox_test.activated[str].connect(self.test) 1234567891011121314151617181920212223242526272829303132def findstate(self, itemtext): global state_flag1 statename = itemtext # 添加数据库连接代码位置 try: # cur = database.cursor() if itemtext == \"小猫\": self.graphicsView_5.setStyleSheet(\"border-image: url(:/images/cat.png);\") self.lineEdit_58.setText(\"小猫\") cur.execute('select * from world where animals=\"小猫\"') elif itemtext == \"小狗\": self.graphicsView_5.setStyleSheet(\"border-image: url(:/images/dog.png);\") self.lineEdit_58.setText(\"小狗\") cur.execute('select * from world where animals=\"小狗\"') elif itemtext == \"小猪\": self.graphicsView_5.setStyleSheet(\"border-image: url(:/images/pig.png);\") self.lineEdit_58.setText(\"小猪\") cur.execute('select * from world where animals=\"小猪\"') else: # 提示信息 self.box = QMessageBox(QMessageBox.Warning, \"提示信息\", \"未查询到相关信息！\") qyes = self.box.addButton(self.tr(\"确定\"), QMessageBox.YesRole) # qno = self.box.addButton(self.tr(\"否\"), QMessageBox.NoRole) self.box.exec_() # print(state_flag1) except Exception as e: print(\"未知异常！\") # 提示信息 self.box = QMessageBox(QMessageBox.Warning, \"提示信息\", \"未知异常！\") qyes = self.box.addButton(self.tr(\"确定\"), QMessageBox.YesRole) # qno = self.box.addButton(self.tr(\"否\"), QMessageBox.NoRole) self.box.exec_() 通过按钮点击激活下拉框操作方法：通过变量传值的方式，将item选中的内容先传递给一个临时变量或数组，当点击按钮时通过临时变量或数组执行相关操作。 END","updated":"2020-07-24T06:46:37.897Z","categories":[{"name":"PyQt5","slug":"PyQt5","permalink":"http://yoursite.com/categories/PyQt5/"}],"tags":[{"name":"工具","slug":"工具","permalink":"http://yoursite.com/tags/%E5%B7%A5%E5%85%B7/"},{"name":"GUI","slug":"GUI","permalink":"http://yoursite.com/tags/GUI/"}]},{"title":"PyQt5 通过文本框等组件动态实现数据库查询","date":"2020-07-23T12:00:36.000Z","path":"2020/07/23/PyQt5-通过文本框等组件动态实现数据库查询/","text":"Hello World! PyQt5 通过文本框等组件动态实现数据库查询My Environment Python 3.x Pyqt5 Qt designer PyUIC MySQL pymysql 实现效果通过在界面文本框等组件输入相关信息，点击按钮通过pysql完成数据库语句拼接实现数据库动态查询相关操作，查询后可通过表格组件展示。 实现过程1.在界面中设计好文本框、按钮等组件2.利用pymysql实现查询及创建点击函数 1self.button_test.clicked.connect(self.button_test_clicked) # 点击查询功能 123456789101112131415def button_test_clicked(self): # 打开数据库连接（IP地址/数据库用户名/登录密码/数据库模式名/编码方式/端口号） database = pymysql.connect(host='localhost', user='root', password='123456', db=\"angleStatemonitor\", charset='utf8', port=3306) cur = database.cursor() # 单日记录查询 if self.lineEdit_find.text() == self.lineEdit_find.text() and self.lineEdit_find.text() is not \"\": sql_select = \"select * from OperationRecord where time like '\" + str(self.lineEdit_find.text()) + \"'\" cur.execute(sql_select) else: # 提示信息 self.box = QMessageBox(QMessageBox.Warning, \"提示信息\", \"查询失败！\") qyes = self.box.addButton(self.tr(\"确定\"), QMessageBox.YesRole) # qno = self.box.addButton(self.tr(\"否\"), QMessageBox.NoRole) self.box.exec_() 其他python数据库语句请参考链接: MySQL数据库范围、模糊、时间范围（时间段）查询语句. END","updated":"2020-07-24T06:46:22.860Z","categories":[{"name":"PyQt5","slug":"PyQt5","permalink":"http://yoursite.com/categories/PyQt5/"}],"tags":[{"name":"工具","slug":"工具","permalink":"http://yoursite.com/tags/%E5%B7%A5%E5%85%B7/"},{"name":"GUI","slug":"GUI","permalink":"http://yoursite.com/tags/GUI/"}]},{"title":"PyCharm本地恢复或查看历史代码","date":"2020-07-23T12:00:34.000Z","path":"2020/07/23/PyCharm本地恢复或查看历史代码/","text":"Hello World! 首先，打开PyCharm软件后选中项目文件；点击pycharm的菜单中的 vcs ，选中菜单local history的选项选择对应历史代码查看或者右键进行恢复。 END","updated":"2020-07-24T06:46:01.275Z","categories":[{"name":"Pycharm","slug":"Pycharm","permalink":"http://yoursite.com/categories/Pycharm/"}],"tags":[{"name":"工具","slug":"工具","permalink":"http://yoursite.com/tags/%E5%B7%A5%E5%85%B7/"}]},{"title":"Nginx安装教程（windows）","date":"2020-07-23T12:00:32.000Z","path":"2020/07/23/Nginx安装教程（windows）/","text":"Hello World! 1.官网下载 Nginx官网下载后解压到本地 2.安装部署1、下载完成后，解压缩，运行cmd，使用命令进行操作，不要直接双击nginx.exe，一定要在dos窗口启动，不要直接双击nginx.exe，这样会导致修改配置后重启、停止nginx无效，需要手动关闭任务管理器内的所有nginx进程，再启动才可以。2、使用命令行到达nginx的加压缩后的目录 1cd D:\\nginx-1.19.1 3、启动nginx服务，启动时会一闪而过是正常的 1start nginx 4、查看任务进程是否存在，dos或打开任务管理器都行 1tasklist /fi \"imagename eq nginx.exe\" 通过任务管理器确认：之后就打开浏览器访问刚才的域名及端口http://localhost:80或127.0.0.1:80，（默认为80）出现欢迎页就说明部署成功了！启动脚本startup.bat（新建txt后另存，放到nginx.exe同一级）或者直接点击nginx.exe脚本内容： 123456789101112@echo offrem 如果启动前已经启动nginx并记录下pid文件，会kill指定进程nginx.exe -s stoprem 测试配置文件语法正确性nginx.exe -t -c conf/nginx.confrem 显示版本信息nginx.exe -vrem 按照指定配置去启动nginxnginx.exe -c conf/nginx.conf 3.常见问题错误查看： 3.常见错误：(1)端口号被占用在conf目录下找到nginx.conf使用txt文本打开即可，找到server这个节点，修改端口号，如果有需求可以修改主页目录没有就不用修改修改完成后保存，使用以下命令检查一下配置文件是否正确，后面是nginx.conf文件的路径，successful就说明正确了 1nginx -t -c /nginx-1.15.2/conf/nginx.conf 如果程序没启动就直接start nginx启动，如果已经启动了就使用以下命令重新加载配置文件并重启 1nginx -s reload 在项目中用到nginx，启动时闪退，查看错误日志，给出的错误如下：nginx: [emerg] bind() to 0.0.0.0:80 failed (10013: An attempt was made to access a socket in a way forbidden by its access permissions)分析：nginx的默认端口是80，通过错误日志可以看出是80端口被占用导致了nginx无法启动。解决办法：1、按键win+R打开运行界面，输入cmd进入控制台界面2、输入netstat -ano | findstr “:80 “通过上述命令查看80端口占用情况，查看后，pid的值为4。参考：链接: link.(2)nginx文件夹路径含中文 4.常用命令关闭nginx服务使用以下命令，同样也是一闪而过是正常的，看一下是否进程已消失即可 12345678nginx -s stop 快速关闭Nginx，可能不保存相关信息，并迅速终止web服务。nginx -s quit 平稳关闭Nginx，保存相关信息，有安排的结束web服务。nginx -s reload 因改变了Nginx相关配置，需要重新加载配置而重载。nginx -s reopen 重新打开日志文件。nginx -c filename 为 Nginx 指定一个配置文件，来代替缺省的。nginx -t 不运行，而仅仅测试配置文件。nginx 将检查配置文件的语法的正确性，并尝试打开配置文件中所引用到的文件。nginx -v 显示 nginx 的版本。nginx -V 显示 nginx 的版本，编译器版本和配置参数。","updated":"2020-07-26T07:40:50.356Z","categories":[{"name":"Nginx","slug":"Nginx","permalink":"http://yoursite.com/categories/Nginx/"}],"tags":[{"name":"Nginx安装教程","slug":"Nginx安装教程","permalink":"http://yoursite.com/tags/Nginx%E5%AE%89%E8%A3%85%E6%95%99%E7%A8%8B/"}]},{"title":"数据库日常之修改MySQL数据库密码的方法","date":"2020-07-23T06:14:46.000Z","path":"2020/07/23/数据库日常之修改MySQL数据库密码的方法/","text":"Hello World! 1.windows下利用CMD命令修改开始时如果用户user没有密码，则 -p 旧密码 一项就可以省略；修改格式： 1mysql -hlocalhost -u root -p 旧密码 password 新密码 修改步骤：(按回车键Enter执行命令行）1.首先在DOS下进入目录mysql\\binC: \\Users\\Adninistrator&gt;D:D:&gt;cd D:\\mysql-5.7.22-win32\\bin2.然后输入以下命令：D:\\mysql-5.7.22-win32\\bin&gt;mysql -hlocalhost -u root -p 111111 password 123456 2.在MySQL环境中修改MySQL命令结束后都带一个分号作为命令结束符修改格式： 1UPDATE mysql.user SET password=PASSWORD('123456') WHERE User='root'; (按回车键Ctrl+Shift+Enter执行命令行）mysql&gt; UPDATE mysql.user SET password=PASSWORD(‘123456’) WHERE User=’root’;运行完这行之后会提示下面的信息：Query OK, 0 rows affected (0.00 sec)Rows matched: 2 Changed: 0 Warnings: 0这时候还需要运行下面一句，否则密码不会被修改： 1FLUSH PRIVILEGES; 下面运行结果代表修改成功：Query OK, 0 rows affected (0.16 sec)然后显示当前的user： 1SELECT USER(); 3.在MySQL和Navicat中直接修改3.1 MySQL Workbench3.2 Navicat1.连接初始进入2.点击用户3.右键编辑root用户4.修改密码，授权数据库操作权限5.将链接密码修改为以上设置的密码即可（右键连接属性） END","updated":"2020-07-23T07:16:15.593Z","categories":[{"name":"MySQL","slug":"MySQL","permalink":"http://yoursite.com/categories/MySQL/"}],"tags":[{"name":"密码修改","slug":"密码修改","permalink":"http://yoursite.com/tags/%E5%AF%86%E7%A0%81%E4%BF%AE%E6%94%B9/"},{"name":"数据库","slug":"数据库","permalink":"http://yoursite.com/tags/%E6%95%B0%E6%8D%AE%E5%BA%93/"}]},{"title":"数据库学习与应用之利用cmd命令操纵数据库(下）","date":"2020-07-23T06:14:44.000Z","path":"2020/07/23/数据库学习与应用之利用cmd命令操纵数据库-下）/","text":"Hello World! 1. 数据库用户的权限控制：（数据表级的权限控制 : 将某个库中的某个表的控制权赋予某个用户） 1Grant all ON db_name.table_name TO user_name [ indentified by ‘password’ ]; 2. 修改数据库表中结构操作：2.1 增加一个表中的字段格式： 1alter table table_name add column (字段名 字段类型); 2.2 指定表中的字段插入的位置： 1alter table table_name add column 字段名 字段类型 after 某字段； 2.3 删除一个表中的字段： 1alter table table_name drop字段名; 2.4 修改表中字段名称/类型 1alter table table_name change 旧字段名 新字段名 新字段的类型; 2.5 改表的名字 1alter table table_name rename to table_new; 2.6 一次性清空表中的所有数据 1truncate table table_name; 2.7 数据库表字段更新: 123update table_name-&gt; set sex='不详' -&gt; where name_id=1; 3. 显示当前数据库版本和日期 ： 1select version(),current_date; 退出操作 1exit; END","updated":"2020-07-23T07:18:56.026Z","categories":[{"name":"MySQL","slug":"MySQL","permalink":"http://yoursite.com/categories/MySQL/"}],"tags":[{"name":"工具","slug":"工具","permalink":"http://yoursite.com/tags/%E5%B7%A5%E5%85%B7/"},{"name":"cmd","slug":"cmd","permalink":"http://yoursite.com/tags/cmd/"}]},{"title":"数据库学习与应用之利用cmd命令操纵数据库(上）","date":"2020-07-23T06:14:43.000Z","path":"2020/07/23/数据库学习与应用之利用cmd命令操纵数据库-上）/","text":"Hello World! 1.在DOS下进入目录mysql\\binC: \\Users\\Adninistrator&gt;D:D:&gt;cd D:\\mysql-5.7.22-win32\\bin 2.然后输入以下命令来操纵数据库： 2.1 连接数据库 1D:\\mysql-5.7.22-win32\\bin&gt;mysql -h localhost -u root -p123456 2.2 显示本地所有数据库（==所有的命令都以;结束==）： 1SHOW DATABASES; 2.3创建和删除数据库：创建和删除时可先判断是否存在，可写成 :create/drop database if exits db_name ，数据库中表的创建同理； 12create database 数据库名;drop database 数据库名; 2.4 操作数据库中的数据表：2.4.1 选择当前要操作的主数据库： 1USE 数据库名; 2.4.2 显示当前主数据库的所有数据表： 1SHOW TABLES; 2.4.3 查询表 显示表中的所有记录，* (表示所有字段)： 1SELECT * FROM table_name; 2.4.4 查询指定字段的数据 : 1select 字段1 , 字段2 from table_name; 2.4.5 查看表的结构： 123DESC table_name;Describe table_name;show columns from table_name; 2.4.6 删除整个表中的所以信息 : 1delete from table_name; 2.4.7 显示数据表创建时的全部信息 1show create table table_name; 2.5 创建和删除表：2.5.1 创建表 1CREATE TABLE table_name(字段名1 字段类型 字段的约束（可省略）, 字段名1 字段类型 字段的约束（可省略）,……); 例：create table cjw (id int , username char(20));2.5.2 删除表 1DROP TABLE table_name; 2.6 插入数据操作：如果向表中的每个字段都插入一个值,那么前面 [ ] 括号内字段名可写也可以不写 1Insert into table_name [(字段1 , 字段2 , ….)] values (值1 , 值2 , …..); 例如：insert into cjw (id,username) values (0,’tree’);2.7 更新（修改）和删除数据操作：2.7.1 更新指定数据 , 更新某一个字段的数据（不是更新字段名） 1Update table_name set 字段名=’修改值’ [, 字段2 =’修改值’ , …..][where id=id_num] [order by 字段 顺序] 例如 : update cjw set username=’marry’ where id=0;2.7.2 删除表中指定条件的语句 :在删除全部记录的同时将自增id的增长量也一并清零条件删除：DELETE FROM 表名 WHERE 条件where中的条件: [ 字段名 运算符 字段值 ]构成运算符:= != &lt;&gt; &gt; &lt; &gt;= &lt;= is null / is not null多个条件: and表示且 条件1 and 条件2，or 表示或，not 表示非 1delete from table_name where 条件语句 ; 例如：delete from cjw where id=0; 2.8 创建数据库用户 一次创建一个或多个数据库用户 1CREATE USER username1 identified BY ‘password’ , username2 IDENTIFIED BY ‘password’…. 例如：CREATE USER root identified BY ‘123456’ , cjw IDENTIFIED BY ‘5201314’…. Contiue……","updated":"2020-07-23T07:20:08.026Z","categories":[{"name":"MySQL","slug":"MySQL","permalink":"http://yoursite.com/categories/MySQL/"}],"tags":[{"name":"工具","slug":"工具","permalink":"http://yoursite.com/tags/%E5%B7%A5%E5%85%B7/"},{"name":"cmd","slug":"cmd","permalink":"http://yoursite.com/tags/cmd/"}]},{"title":"数据库学习与应用之什么是数据库","date":"2020-07-23T06:14:41.000Z","path":"2020/07/23/数据库学习与应用之什么是数据库/","text":"Hello World! 数据库数据库，是一个长期存储在计算机内的、有组织的、有共享的、统一管理的数据集合。 常用的数据库有Access、Oracle、Mysql、SQL Server、SQLite等； 数据库中的数据都有一定规律结构，相同类型的数据放在一起，不同类型的数据之间相互隔离；数据库由统一的规则来读写，有SQL语言专门用来读写数据库，一般都是用程序来读写数据库的内容。 数据库支持的软件模式：B/S：Browser/Server （浏览器/服务器）（淘宝）C/S：Client/Server （客户端/服务器）（QQ、微信） 常用的数据库 数据库应用 描述 MySQL数据库 小型数据库管理系统的数据库，由瑞典MySQLAB公司开发。MySQL被广泛地应用在Internet上的中小型网站当中 SqlServer数据库 中型数据库软件，真正的客户/服务器体系结构，图形化的用户界面，数据库管理方式更加直观和简单 Oracle数据库 大型企业级数据库，这是一款比较典型的客户/服务器(CLIENT/SERVER)或B/S体系结构的数据库之一，目前世界上使用最为广泛的数据库管理系统 Access数据库 小型的数据库，关联式数据序管理型系统的数据库，通常是被用来开发Web应用程序 数据库可视化管理工具1. MySQL WorkbenchMySQL Workbench为数据库管理员、程序开发者和系统规划师提供可视化设计、模型建立、以及数据库管理功能。它包含了用于创建复杂的数据建模ER模型，正向和逆向数据库工程，也可以用于执行通常需要花费大量时间和需要的难以变更和管理的文档任务。MySQL工作台可在Windows，Linux和Mac上使用；2. NavicatNavicat是一个桌面版MySQL数据库管理和开发工具。Navicat使用图形化的用户界面，可以让用户使用和管理更为轻松。支持中文，有免费版本提供；3. MySQLDumperMySQLDumper使用PHP开发的MySQL数据库备份恢复程序，解决了使用PHP进行大数据库备份和恢复的问题，数百兆的数据库都可以方便的备份恢复，不用担心网速太慢导致中间中断的问题，非常方便易用； 数据库访问方式利用数据库管理工具或者编写程序来访问数据库。当然，数据库和访问数据库可以跨空间进行（本地和远程）连接：数据库管理工具、编程语言（Java、PyThon等） END","updated":"2020-07-23T07:19:50.410Z","categories":[{"name":"MySQL","slug":"MySQL","permalink":"http://yoursite.com/categories/MySQL/"}],"tags":[{"name":"工具","slug":"工具","permalink":"http://yoursite.com/tags/%E5%B7%A5%E5%85%B7/"}]},{"title":"数据库学习与应用之SQL语法及常用操作","date":"2020-07-23T06:14:39.000Z","path":"2020/07/23/数据库学习与应用之SQL语法及常用操作/","text":"Hello World! SQL语法SQL：Structed Query Language 结构化查询语句 注意： 在数据库操作中，所有的命令和关键字以及自定义名称都==不区分大小写==，但是一般我们：关键字部分使用全部大写，自定义名称（数据库名、数据库表名、字段名）用小写字母开头； 字符串使用单引号或者双引号，一般使用单引号，方便在java/PHP/HTML程序和代码字符串类型的参数进行嵌套； 所有的符号都必须是英文状态的符号，数据库高版本可以直接使用双引号； 部分参数含义： 参数名 缩写 描述 host -h 服务器IP地址 port -P 服务器端口号 user -u 数据库用户名 pasword -p 数据库的密码 — # SQL语句 数据库创建 : Create database db_name; ———————————————————————– 创建时可先判断是否存在 : Create database if not exits db_name 数据库删除 : Drop database db_name; ———————————————————————– 删除时可先判断是否存在 : drop database if exits db_name ———————————————————————– 数据库表创建 : create table table_name (字段1 数据类型 , 字段2 数据类型); eg : create table demo (id int , name varchar(20)); ———————————————————————– 数据库表删除 : drop table table_name; eg: drop table demo; ———————————————————————– 数据库表插入数据 : Insert into 表名 [(字段1 , 字段2 , ….)] values (值1 , 值2 , …..); 如果向表中的每个字段都插入一个值,那么前面 [ ] 括号内字段名可写也可不写 eg : insert into demo (id,username) values (0,’cjw’); ———————————————————————– 查询数据库表中所有数据 : select * from table_name; 查询数据库表中指定字段的数据 : select 字段1 , 字段2 from table_name; eg : select id,username from demo where id=1 order by desc; ———————————————————————– 更新数据库表中指定字段的数据： Update table_name set 字段名=’新值’ [, 字段2 =’新值’ , …..][where id=id_num] [order by 字段 顺序] eg : update demo set username=’cjw’ where id=1; Where和order语句也可用于查询select 与删除delete 删除整个数据库表中的信息 : delete from table_name; 删除数据库表中指定条件的语句 : delete from table_name where 条件语句 ; 条件语句如 : id=1; ———————————————————————– 创建一个数据库用户: CREATE USER username1 identified BY ‘password’ 创建多个数据库用户: CREATE USER root identified BY ‘password’ , user1 IDENTIFIED BY ‘password’…. ———————————————————————– 用户的权限控制：grant 库，表级的权限控制 : 将某个库中的某个表的控制权赋予某个用户 Grant all ON db_name.table_name TO user_name [ indentified by ‘password’ ]; ———————————————————————– 数据库表中增加一个字段： alter table table_name add column (字段名 字段类型); 数据库表中指定字段插入的位置： alter table table_name add column 字段名 字段类型 after 某字段； 数据库表中删除一个字段： alter table table_name drop字段名; 数据库表中修改字段名称/类型 alter table table_name change 旧字段名 新字段名 新字段的类型; ———————————————————————– 修改数据库表名： alter table table_name rename to new_table_name; ———————————————————————– 清空数据库表中的所有数据 ： truncate table table_name; ———————————————————————– 增加主键，外键，约束，索引： 约束（主键Primary key、唯一性Unique、非空Not Null） 自动增张 auto_increment 外键Foreign key—–与reference table_name(col_name列名)配合使用，建表时单独使用 删除多个表中有关联的数据—-设置foreign key 为set null ———————————————————————– 查看数据库当前引擎： SHOW CREATE TABLE table_name; 修改数据库引擎 ： ALTER TABLE table_name ENGINE=MyISAM InnoDB; SQL常用操作 create database name; 创建数据库 use databasename; 选择数据库 drop databasename 直接删除数据库，不提示 mysqladmin drop databasename 删除数据库前，有提示 show tables; 显示数据库表 describe（DESC） tablename; 数据库表的详细描述 select * from tablename; 查询数据库表 查询数据库表的记录总数(三种方法) select count() from tablename;或者 select count() as num from tablename;或者 select count(*) as total from tablename; select 中加上distinct去除重复字段 select version(),current_date; 显示当前mysql版本和当前日期mysql的启动与停止 启动MySQL服务 net start mysqlversion停止MySQL服务 net stop mysqlversion show status;数据库状态信息参数解析(数据库连接后输入） alter table users character set GBK;解决中文乱码（utf-8） SQL语句运用举例: ——————————————————建表 —————————————————————- 1create table users (id int primary key auto_increment,nikename varchar(20) not null unique,password varchar(100) not null,address varchar(200), reg_date timestamp not null default CURRENT_TIMESTAMP); ———————————————–建表时设置外键———————————————————- 1create table demo (id int primary key auto_increment,content longtext not null,userid int,constraint foreign key (userid) references users(id) on delete set null); ———————————————–建表时不设置外键———————————————————- 1create table demo (id int primary key auto_increment,content longtext not null,userid int); ———————————————–给demo表设置外键 ——————————————————- 1alter table demo add constraint foreign key (userid) references users(id) on delete set null; ———————————————向表中同时插入多条数据 ————————————————— insert into users (id,name,password,address) values (1,’tom’,’123456’,null),(4,’li’,’654321’,’天津’),(null,’韩梅梅’,’456789’, ‘山西’);———————————————多表查询指定字段所有信息 ———————————————— 1select demo.id,demo.content,users.* from users,demo where users.id=1 and demo.userid=users.id order by demo.id desc; END","updated":"2020-07-23T07:20:13.955Z","categories":[{"name":"MySQL","slug":"MySQL","permalink":"http://yoursite.com/categories/MySQL/"}],"tags":[{"name":"sql语法","slug":"sql语法","permalink":"http://yoursite.com/tags/sql%E8%AF%AD%E6%B3%95/"}]},{"title":"MySQL数据库范围、模糊、时间范围（时间段）查询语句","date":"2020-07-23T06:14:38.000Z","path":"2020/07/23/MySQL数据库范围、模糊、时间范围（时间段）查询语句/","text":"Hello World! MySQL数据库范围、模糊、时间范围查询语句My Environment MySQL5.46 1. 模糊查询语句1SELECT 字段 FROM TABLENAME WHERE 某字段 Like 条件 其中条件有四种匹配方式：1、%：表示任意0个或多个字符。可匹配任意类型和长度的字符，如果是中文，使用两个百分号（%%）来表示。 eg:SELECT * FROM TABLENAME WHERE NAME LIKE ‘%aa%’功能：找出NAME中含有aa的所有记录eg:SELECT * FROM TABLENAME WHERE NAME LIKE ‘%aa%’ AND NAME LIKE ‘%bb%’功能：找出NAME中既有“aa”又有“bb”的所有记录eg:SELECT * FROM TABLENAME WHERE NAME LIKE ‘%aa%bb%’功能：找出 NAME中形如aabbcc,不能找出bbaacc 2、_： 表示任意单个字符。匹配单个任意字符，常用来限制表达式的字符长度语句 eg: SELECT * FROM TABLENAME WHERE NAME LIKE ‘aa‘功能：找出 NAME中形如找出bbaacc,也就是aa位于中间的所有记录eg: SELECT * FROM TABLENAME WHERE NAME LIKE ‘aa__’;功能：找出 NAME中形如aabbcc,不能找出bbaacc,只能找出以aa开头的所有记录 3、[ ]：表示括号内所列字符中的一个（类似正则表达式）。指定一个字符、字符串或范围，要求所匹配对象为它们中的任一个。 eg: SELECT * FROM TABLENAME WHERE NAME LIKE ‘[abc]d’功能：找出 NAME中形如ad、bd、cd的所有记录当 [ ] 内有一系列字符（01234、abcde之类的）则可略写为“0-4”、“a-e”eg:SELECT * FROM TABLENAME WHERE NAME LIKE ‘a[a-e]’功能：找出 NAME中形如aa、ab、ac、ad、ae的所有记录 4、[^ ] ：表示不在括号所列之内的单个字符。其取值和 [] 相同，要求所匹配对象为指定字符以外的任一个字符。 eg:SELECT * FROM TABLENAME WHERE NAME LIKE ‘[^abc]d’功能：找出 NAME中除了形如ad、bd、cd的所有记录eg:SELECT * FROM TABLENAME WHERE NAME LIKE ‘d[^abc]’其中abc也可以写成a-c功能：找出 NAME中除了形如da、db、dc的所有记录 范围查询语句between：between限制查询数据范围时包括了边界值between and 包含时间界限，这就相当于&gt;= &lt;=，而&gt; &lt;不包含not between不包括的数据范围 eg: SELECT * FROM TABLENAME WHERE time BETWEEN time1 AND time2功能：找出==在==time1 和 time2范围内的所有记录 eg: SELECT * FROM TABLENAME WHERE A NOT BETWEEN num1 AND num2功能：找出==不在== num1 和 num2范围内的所有记录 时间范围（时间段）查询语句eg: SELECT * FROM TABLENAME WHERE time BETWEEN ‘2020-06-13 00:00:00’ and ‘2020-06-13 18:30:59’功能：找出==在== 2020-06-13 00:00:00 和 2020-06-13 18:30:59范围内的所有记录 END","updated":"2020-07-23T07:20:48.061Z","categories":[{"name":"MySQL","slug":"MySQL","permalink":"http://yoursite.com/categories/MySQL/"}],"tags":[{"name":"sql语法","slug":"sql语法","permalink":"http://yoursite.com/tags/sql%E8%AF%AD%E6%B3%95/"}]},{"title":"MySQL数据库安装教程(windows)","date":"2020-07-23T06:13:31.000Z","path":"2020/07/23/MySQL数据库安装教程-windows/","text":"Hello World! 1. 下载及配置环境变量⦁ 解压mysql安装包：将mysql-5.7.22-win32的zip解压缩到一个位置，在这里我们假设其被解压缩到D盘⦁ 解压完后的mysql-5.7.22-win32文件夹如图2.1所示，在mysql-5.7.22-win32文件夹下新建一个叫data的文件夹和一个ini格式的叫my.ini的文件（用记事本新建一个txt，再将其另存为成my.ini）my.ini内容： 12345678910111213141516[mysql] # 设置mysql客户端默认字符集 default-character-set=utf8 [mysqld] #设置3306端口port = 3306 # 设置mysql的安装目录 basedir=D:\\mysql-5.7.22-win32# 设置mysql数据库的数据的存放目录 datadir=D:\\mysql-5.7.22-win32\\data # 允许最大连接数 max_connections=200 # 服务端使用的字符集默认为8比特编码的latin1字符集 character-set-server=utf8 # 创建新表时将使用的默认存储引擎 default-storage-engine=INNODB 配置环境变量：右键点击“我的电脑”，选择“属性”，得到如图3.1所示界面，选择“高级系统设置”；进入“环境变量”后，在下边的系统变量里选择“新建”，在弹出的对话框里“变量名”一栏里填mysql_home，变量值里填MySQL的bin文件夹的路径，本例中为D:\\mysql-5.7.22-win32\\bin。 之后再环境变量path中添加mysql的环境变量，选择Path的环境变量，之后点击编辑——右上角新建——填写”%环境变量名称%\\bin”，图中划横线的地方填写的是上一步第一个输入框的名称，所以我这是%mysql_home%\\bin；如果是windows7的可以在Path后追加“;%mysql_home%\\bin”。 2. 配置MySQL数据库1.以管理员身份运行cmd（按照C:\\Windows\\System32的路径找到cmd.exe，右键点击，选择“以管理员身份运行”），之后输入D:（即MySQL所在的盘），然后再输入cd mysql-5.7.22-win32\\bin（即MySQL的bin文件夹的路径）;2.这样就通过cmd进入MySQL的bin文件夹了。之后再输入mysqld –install，完成对MySQL的安装;3.再输入mysqld -–initialize，完成对MySQL的初始化，这一步骤会有一段时间;4.data文件夹会出现一些文件，其中.err的文件中有生成的MySQL初始密码，该密码为随机产生的，因此务必记住；5.启动 MySQL 服务：进入 MySQL 的 bin 目录(经过前面的步骤，此时正处于 MySQL 的 bin目录下)，输入：net start mysql登录MySQL，输入mysql -u root –p，当出现Enter password：就输入刚才随机生成的初始密码（==注意：初始密码无法复制，必须手动输入==）6.若觉得初始密码太过难记，则可修改密码，输入set password for root@localhost=password(‘123456’);其中括号里的就是修改后的密码，（现在我们的密码是：123456，必须加分号）进行上述步骤后，我们已经可以使用MySQL了，只要进行第5、6步就可以，但是这样的MySQL很不直观，因此我们有必要再安装MySQL的可视化文件MySQL workbench。 1234567891011121314151617181920212223242526272829C:\\Windows\\system32&gt;D:D:\\&gt;cd mysql-5.7.22-win32\\binD:\\mysql-5.7.22-win32\\bin&gt;mysqld -installService successfully installed.D:\\mysql-5.7.22-win32\\bin&gt;mysqld --initializeD:\\mysql-5.7.22-win32\\bin&gt;net start mysqlMySQL 服务正在启动 .MySQL 服务已经启动成功。D:\\mysql-5.7.22-win32\\bin&gt;mysql -u root -pEnter password: ************Welcome to the MySQL monitor. Commands end with ; or \\g.Your MySQL connection id is 2Server version: 5.7.22Copyright (c) 2000, 2018, Oracle and/or its affiliates. All rights reserved.Oracle is a registered trademark of Oracle Corporation and/or itsaffiliates. Other names may be trademarks of their respectiveowners.Type 'help;' or '\\h' for help. Type '\\c' to clear the current input statement.mysql&gt; set password for root@localhost=password('123456');Query OK, 0 rows affected, 1 warning (0.00 sec) 常见错误解决办法：1.未以管理员身份运行cmd执行mysqld -install时，出现Install/Remove of the Service Denied!进入系统盘找到C:\\Windows\\System32\\cmd.exe（文件较多，可以快速搜索找到cmd.exe）右键以管理员身份运行 再次进入相应目录执行.2.mysql解压目录下没有my.ini配置文件mysqld: [ERROR] Found option without preceding group in config file D:\\mysql-5.7.22-win32\\my.ini at line 1!mysqld: [ERROR] Fatal error in defaults handling. Program aborted!3.弹出：由于找不到MSVCR120.dll,无法继续执行代码.重新安装程序可能会解决此问题！（未安装 vcredist 引起的）下载 vcredist 地址：链接: vcredist安装刚才下载的那个软件，位置默认即可（会有一个安装不成功，不影响），然后重新进行安装，成功解决这个问题！ 3.安装可视化文件MySQL workbench本文中安装的workbench的文件名为：mysql-workbench-community-6.3.10-winx64.msi可能会出现如下情况，系统缺少“Visual C++2015 Redistributable Package”。此时运行文件夹下的vc_进行安装。双击后点击next按钮，之后我们可以选择workbench的安装路径，这里我们使用默认路径，再点击next，因为workbench并不大，因此我们选择完全安装，点击next，进入安装界面，点击Install即可安装等待安装完成后，点击Finish即可完成安装。安装完成后我们打开workbench，点击Local instance MySQL，输入我们设置的MySQL密码即可连接数据库：数据库可视化界面如下： END","updated":"2020-07-23T07:20:53.242Z","categories":[{"name":"MySQL","slug":"MySQL","permalink":"http://yoursite.com/categories/MySQL/"}],"tags":[{"name":"数据库安装教程","slug":"数据库安装教程","permalink":"http://yoursite.com/tags/%E6%95%B0%E6%8D%AE%E5%BA%93%E5%AE%89%E8%A3%85%E6%95%99%E7%A8%8B/"}]},{"title":"pom.xml解析","date":"2020-07-23T06:13:29.000Z","path":"2020/07/23/pom-xml解析/","text":"Hello World! pom.xmlpom.xml文件是Maven进行工作的主要配置文件。在这个文件中我们可以配置Maven项目的groupId、artifactId和version等Maven项目必须的元素；可以配置Maven项目需要使用的远程仓库；可以定义Maven项目打包的形式；可以定义Maven项目的资源依赖关系等等。 pom.xml标签12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273 &lt;!--project是pom.xml的根元素，包含了一些约束的信息，比如xlms,xsi--&gt;&lt;project&gt; &lt;!--指定了当前pom的版本--&gt; &lt;modelVersion&gt;4.0.0&lt;/modelVersion&gt; &lt;!--maven2.0必须是这样写，现在是maven2唯一支持的版本--&gt; &lt;!-- 基础设置 --&gt; &lt;groupId&gt;反写公司的网址+项目名称&lt;/groupId&gt; &lt;artifactId&gt;项目名称+模块名&lt;/artifactId&gt; &lt;version&gt;当前项目版本号&lt;/version&gt; &lt;!-- 默认是jar，还可以打包成war/zip/pom--&gt; &lt;packaging&gt;...&lt;/packaging&gt; &lt;!-- 项目描述名，一般是写项目文档的时候才使用 --&gt; &lt;name&gt;...&lt;/name&gt; &lt;!-- 项目的地址--&gt; &lt;url&gt;...&lt;/url&gt; &lt;!-- 项目的描述 --&gt; &lt;description&gt;...&lt;/description&gt; &lt;!-- 开发人员的列表 --&gt; &lt;developers&gt;...&lt;/developers&gt; &lt;!-- 许可证的信息 --&gt; &lt;licenses&gt;...&lt;/licenses&gt; &lt;!-- 组织信息 --&gt; &lt;organization&gt;...&lt;/organization&gt; &lt;!-- 依赖列表，下面可以包含多个依赖项dependency--&gt; &lt;dependencies&gt; &lt;dependency&gt; &lt;!-- 指定坐标确定依赖项的位置 --&gt; &lt;groupId&gt;&lt;/groupId&gt; &lt;artifactId&gt;&lt;/artifactId&gt; &lt;version&gt;&lt;/version&gt; &lt;type&gt;&lt;/type&gt; &lt;!-- 依赖包的依赖范围--&gt; &lt;scope&gt;&lt;/scope&gt; &lt;!-- 这个标签只有true和false两个值，是用来设置依赖是否可选 --&gt; &lt;optional&gt;&lt;/optional&gt; &lt;!-- 排除依赖传递列表 --&gt; &lt;exclusions&gt; &lt;exclusion&gt; &lt;/exclusion&gt; &lt;/exclusions&gt; &lt;/dependency&gt; &lt;/dependencies&gt; &lt;!-- 依赖管理，里面包含多个依赖，但是它并不会被运行，即不会被引用到实际的依赖中--&gt; &lt;!--这个标签主要是用来定义在父模块中，供子模块继承用 --&gt; &lt;dependencyManagement&gt; &lt;dependencies&gt; &lt;dependency&gt; &lt;/dependency&gt; &lt;/dependencies&gt; &lt;/dependencyManagement&gt; &lt;!-- 常用于给构件的行为提供相应的支持 --&gt; &lt;build&gt; &lt;!-- 插件列表 --&gt; &lt;plugins&gt; &lt;plugin&gt; &lt;groupId&gt;&lt;/groupId&gt; &lt;artifactId&gt;&lt;/artifactId&gt; &lt;version&gt;&lt;/version&gt; &lt;/plugin&gt; &lt;/plugins&gt; &lt;/build&gt; &lt;!-- 用于在子模块中对父模块的pom的继承 --&gt; &lt;parent&gt;...&lt;/parent&gt; &lt;!-- 用来聚合多个模块，让多个模块进行编译，不用一个一个来 --&gt; &lt;modules&gt; &lt;module&gt; &lt;/module&gt; &lt;/modules&gt;&lt;/project&gt; 如： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117&lt;?xml version=\"1.0\" encoding=\"UTF-8\"?&gt;&lt;project xmlns=\"http://maven.apache.org/POM/4.0.0\" xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\" xsi:schemaLocation=\"http://maven.apache.org/POM/4.0.0 https://maven.apache.org/xsd/maven-4.0.0.xsd\"&gt; &lt;modelVersion&gt;4.0.0&lt;/modelVersion&gt; &lt;parent&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-parent&lt;/artifactId&gt; &lt;version&gt;2.3.0.RELEASE&lt;/version&gt; &lt;relativePath/&gt; &lt;!-- lookup parent from repository --&gt; &lt;/parent&gt; &lt;groupId&gt;com.dvms&lt;/groupId&gt; &lt;artifactId&gt;data_view&lt;/artifactId&gt; &lt;version&gt;0.0.1-SNAPSHOT&lt;/version&gt; &lt;name&gt;data_view&lt;/name&gt; &lt;description&gt;Demo project for Spring Boot&lt;/description&gt; &lt;properties&gt; &lt;java.version&gt;1.8&lt;/java.version&gt; &lt;/properties&gt; &lt;dependencies&gt; &lt;!--导入Thymeleaf依赖，基于3.x开发--&gt; &lt;dependency&gt; &lt;groupId&gt;org.thymeleaf&lt;/groupId&gt; &lt;artifactId&gt;thymeleaf-spring5&lt;/artifactId&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-web&lt;/artifactId&gt; &lt;/dependency&gt; &lt;!--导入springboot和mybatis依赖 包含mybatis的核心--&gt; &lt;dependency&gt; &lt;groupId&gt;org.mybatis.spring.boot&lt;/groupId&gt; &lt;artifactId&gt;mybatis-spring-boot-starter&lt;/artifactId&gt; &lt;version&gt;2.1.0&lt;/version&gt; &lt;/dependency&gt; &lt;!--导入druid依赖，基于3.x开发--&gt; &lt;dependency&gt; &lt;groupId&gt;com.alibaba&lt;/groupId&gt; &lt;artifactId&gt;druid&lt;/artifactId&gt; &lt;version&gt;1.1.22&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;mysql&lt;/groupId&gt; &lt;artifactId&gt;mysql-connector-java&lt;/artifactId&gt; &lt;scope&gt;runtime&lt;/scope&gt; &lt;/dependency&gt; &lt;!--导入lombok小辣椒驱动依赖,用来生成get/set方法依赖--&gt; &lt;dependency&gt; &lt;groupId&gt;org.projectlombok&lt;/groupId&gt; &lt;artifactId&gt;lombok&lt;/artifactId&gt; &lt;!--&lt;optional&gt;true&lt;/optional&gt;--&gt; &lt;version&gt;1.18.12&lt;/version&gt; &lt;scope&gt;provided&lt;/scope&gt;&lt;!--自动生成有参无参构造--&gt; &lt;/dependency&gt; &lt;!--热部署插件--&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-devtools&lt;/artifactId&gt; &lt;scope&gt;runtime&lt;/scope&gt; &lt;/dependency&gt; &lt;!--引入pagehelper分页插件--&gt; &lt;dependency&gt; &lt;groupId&gt;com.github.pagehelper&lt;/groupId&gt; &lt;artifactId&gt;pagehelper-spring-boot-starter&lt;/artifactId&gt; &lt;version&gt;1.2.10&lt;/version&gt; &lt;/dependency&gt; &lt;!--kaptcha 框架--&gt; &lt;dependency&gt; &lt;groupId&gt;com.github.penggle&lt;/groupId&gt; &lt;artifactId&gt;kaptcha&lt;/artifactId&gt; &lt;version&gt;2.3.2&lt;/version&gt; &lt;/dependency&gt; &lt;!--安全框架--&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-security&lt;/artifactId&gt; &lt;/dependency&gt; &lt;!--Thymeleaf整合security--&gt; &lt;dependency&gt; &lt;groupId&gt;org.thymeleaf.extras&lt;/groupId&gt; &lt;artifactId&gt;thymeleaf-extras-springsecurity5&lt;/artifactId&gt; &lt;version&gt;3.0.4.RELEASE&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-test&lt;/artifactId&gt; &lt;scope&gt;test&lt;/scope&gt; &lt;exclusions&gt; &lt;exclusion&gt; &lt;groupId&gt;org.junit.vintage&lt;/groupId&gt; &lt;artifactId&gt;junit-vintage-engine&lt;/artifactId&gt; &lt;/exclusion&gt; &lt;/exclusions&gt; &lt;/dependency&gt; &lt;/dependencies&gt; &lt;build&gt; &lt;plugins&gt; &lt;plugin&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-maven-plugin&lt;/artifactId&gt; &lt;configuration&gt; &lt;!--fork : 如果没有该项配置，devtools不会起作用，即应用不会restart --&gt; &lt;fork&gt;true&lt;/fork&gt; &lt;addResources&gt;true&lt;/addResources&gt; &lt;/configuration&gt; &lt;/plugin&gt; &lt;/plugins&gt; &lt;/build&gt;&lt;/project&gt; END","updated":"2020-07-23T07:20:42.201Z","categories":[{"name":"JavaWeb","slug":"JavaWeb","permalink":"http://yoursite.com/categories/JavaWeb/"}],"tags":[{"name":"pom.xml","slug":"pom-xml","permalink":"http://yoursite.com/tags/pom-xml/"}]},{"title":"Tomcat安装教程","date":"2020-07-23T06:13:28.000Z","path":"2020/07/23/Tomcat安装教程/","text":"Hello World! 1. 下载Tomcat首先确定你Windows系统是64位，还是32位(现在大部分是64位)及JDK版本（Tomcat在 JDK1.8 环境下能够正常运行）下载地址：Tomcat官网. 2. 安装Tomcat解压压缩包，放在想要放在的盘符(最好不要是C盘，可能会出现拒绝访问)如安装在D盘，那就解压出来放在D盘下就行，里面的文件名不要改动，或者放在D盘某一文件夹下，路径不要包含中文和特殊字符！ 3.配置环境变量在变量名中填写：CATALINA_HOME(不要留空格)变量值就是你解压后的路径，你可以直接进入解压后的文件夹，复制这个路径到变量值之后再找到系统变量中的Path，在最后面追加 %CATALINA_HOME%\\bin; 4.Tomcat启动和验证配置环境变量到你解压的tomcat文件夹下的bin目录中点击startup.bat之后出现了Tomcat的启动窗口之后验证环境变量是否配置成功，浏览器输入一下 http://localhost:8080 弹出页面：链接: http://localhost:8080 配置成功！！！END","updated":"2020-07-23T07:20:34.564Z","categories":[{"name":"JavaWeb","slug":"JavaWeb","permalink":"http://yoursite.com/categories/JavaWeb/"}],"tags":[{"name":"Tomcat","slug":"Tomcat","permalink":"http://yoursite.com/tags/Tomcat/"}]},{"title":"Tomcat入门学习","date":"2020-07-23T06:13:26.000Z","path":"2020/07/23/Tomcat入门学习/","text":"Hello World! TomcatTomcat 是由 Apache 开发的一个 Servlet 容器，实现了对 Servlet 和 JSP 的支持，并提供了作为Web服务器的一些特有功能，如Tomcat管理和控制平台、安全域管理和Tomcat阀等。由于 Tomcat 本身也内含了一个 HTTP 服务器，它也可以被视作一个单独的 Web 服务器。但是，不能将 Tomcat 和 Apache HTTP 服务器混淆，Apache HTTP 服务器是一个用 C 语言实现的 HTTP Web 服务器；这两个 HTTP web server 不是捆绑在一起的。Tomcat 包含了一个配置管理工具，也可以通过编辑XML格式的配置文件来进行配置。 Tomcat 重要目录/bin - Tomcat 脚本存放目录（如启动、关闭脚本）。 *.sh 文件用于 Unix 系统； *.bat 文件用于 Windows 系统;/conf - Tomcat 配置文件目录;/logs - Tomcat 默认日志目录;/webapps - webapp 运行的目录;web 工程发布目录结构 一般 web 项目路径结构|– webapp # 站点根目录 |– META-INF # META-INF 目录 | `– MANIFEST.MF # 配置清单文件 |-- WEB-INF # WEB-INF 目录 | |-- classes # class文件目录 | | |-- *.class # 程序需要的 class 文件 | | `-- *.xml # 程序需要的 xml 文件 | |-- lib # 库文件夹 | | `-- *.jar # 程序需要的 jar 包 | `-- web.xml # Web应用程序的部署描述文件 |-- &lt;userdir&gt; # 自定义的目录 |-- &lt;userfiles&gt; # 自定义的资源文件webapp：工程发布文件夹。其实每个 war 包都可以视为 webapp 的压缩包。 META-INF：META-INF 目录用于存放工程自身相关的一些信息，元文件信息，通常由开发工具，环境自动生成。 WEB-INF：Java web应用的安全目录。所谓安全就是客户端无法访问，只有服务端可以访问的目录。 /WEB-INF/classes：存放程序所需要的所有 Java class 文件。 /WEB-INF/lib：存放程序所需要的所有 jar 文件。 /WEB-INF/web.xml：web 应用的部署配置文件。它是工程中最重要的配置文件，它描述了 servlet 和组成应用的其它组件，以及应用初始化参数、安全管理约束等。 具体可参考：Tomcat 快速入门 END","updated":"2020-07-23T07:20:26.394Z","categories":[{"name":"JavaWeb","slug":"JavaWeb","permalink":"http://yoursite.com/categories/JavaWeb/"}],"tags":[{"name":"Tomcat","slug":"Tomcat","permalink":"http://yoursite.com/tags/Tomcat/"}]},{"title":"Java JDK安装及环境变量配置（windows）","date":"2020-07-23T06:13:24.000Z","path":"2020/07/23/Java-JDK安装及环境变量配置（windows）/","text":"Hello World! 1、JDK jre-8uxxx-windows-x64.exe 下载 所有平台： http://www.oracle.com/technetwork/java/javase/downloads/jdk8-downloads-2133151.html 选择 “Accept License Agreement” 根据系统选择对应的安装文件，64位系统安装64位JDK 2、JDK安装过程 a、双击运行安装文件 jdk-8uxxx-windows-x64.exe b、指定jdk安装目录 C:\\Java\\jdk1.8.0_xxx 然后点击“下一步” c、指定JRE安装目录 C:\\Java\\jre1.8.0_xxx，点击“下一步” d、安装完成，点击“关闭” 3、JDK 环境变量配置 a、新建 JAVA_HOME 环境变量，JAVA_HOME=C:\\Java\\jdk1.8.0_144 b、修改 path 环境变量，在path变量尾部添加%JAVA_HOME%\\bin c、新建 classpath 环境变量 ，classpath=.;%JAVA_HOME%\\lib;%JAVA_HOME%\\lib\\dt.jar;%JAVA_HOME%\\tools.jar 说明：（jdk 需要配置三个环境变量； 1.5之后可以不再设置classpath，但建议保留classpath设置） 开始菜单 -&gt; “计算机” -&gt; 右键 -&gt; 属性 打开 “系统面板”点击 “高级系统设置” 打开 “系统属性”窗口，点击 “环境变量” 打开“系统环境变量”窗格连续点击“确定”，完成环境变量配置。 4、验证 java 和 javac 命令 a、打开cmd命令行窗口，输入 java ，回车执行 b、输入javac 命令，回车执行 弹出以上java 和javac命令输出，则表明jdk安装配置成功！ END","updated":"2020-07-23T07:20:19.760Z","categories":[{"name":"Java","slug":"Java","permalink":"http://yoursite.com/categories/Java/"}],"tags":[{"name":"JDK安装教程","slug":"JDK安装教程","permalink":"http://yoursite.com/tags/JDK%E5%AE%89%E8%A3%85%E6%95%99%E7%A8%8B/"}]},{"title":"setTimeout()方法实现延时执行其他功能","date":"2020-07-23T04:10:30.000Z","path":"2020/07/23/setTimeout-方法实现延时执行其他功能/","text":"Hello World! setTimeout() 方法setTimeout() 方法用于在指定的毫秒数后调用函数或计算表达式。 提示： 1000 毫秒= 1 秒。提示： 如果想重复执行可以使用 setInterval() 方法。提示： 使用 clearTimeout() 方法来阻止函数的执行。 语法 12setTimeout(code, milliseconds, param1, param2, ...)setTimeout(function, milliseconds, param1, param2, ...) setTimeout()方法参数 描述 code/function 必要部分，要调用一个代码串，也可以是一个函数 milliseconds 必要部分，执行或调用 code/function 需要等待的时间，以毫秒计，默认为 0 param1, param2, … 非必要部分，传给执行函数的其他参数（IE9 及其更早版本不支持该参数） return： 返回一个 ID（数字），可以将这个ID传递给 clearTimeout() 来取消执行。 clearTimeout() 方法clearTimeout() 方法可取消由 setTimeout() 方法设置的定时操作。 clearTimeout() 方法的参数必须是由 setTimeout() 返回的 ID 值。注意: 要使用 clearTimeout() 方法, 在创建执行定时操作时要使用全局变量 语法 1clearTimeout(id_of_settimeout); clearTimeout() 方法参数 描述 d_of_setinterval 调用 setTimeout() 函数时所获得的返回值，使用该返回标识符作为参数，可以取消该 setTimeout() 所设定的定时执行操作 return： return 0 应用实例1.5秒（3000 毫秒）后弹出 “Hello JavaScript !” 123456789var myVar;function myFunction() &#123; myVar = setTimeout(alertFunc, 5000);&#125;function alertFunc() &#123; alert(\"Hello JavaScript!\");&#125; 2.打开一个新窗口，5秒后将该窗口关闭 12345function openWin() &#123; var myWindow = window.open(\"color=red\", \"\", \"width=1920, height=1080\"); myWindow.document.write(\"&lt;p&gt;打开一个新窗口&lt;/p&gt;\"); setTimeout(function()&#123; myWindow.close() &#125;, 5000);&#125; 3.计数器功能 123&lt;button onclick=\"startCount()\"&gt;开始计数&lt;/button&gt;&lt;input type=\"text\" id=\"test\"&gt;&lt;button onclick=\"stopCount()\"&gt;停止计数&lt;/button&gt; 点击 “开始计数” 按钮开始执行计数程序。输入框从 0 开始计算。 点击 “停止计数” 按钮停止后，可以再次点击 “开始计数” 按钮会重新开始计数。 123456789101112131415161718192021var c = 0;var t;var timer_is_on = 0;function timedCount() &#123; document.getElementById(\"test\").value = c; c = c + 1; t = setTimeout(function()&#123; timedCount() &#125;, 1000);&#125;function startCount() &#123; if (!timer_is_on) &#123; timer_is_on = 1; timedCount(); &#125;&#125;function stopCount() &#123; clearTimeout(t); timer_is_on = 0;&#125; 4.显示当前时间 12&lt;!--在页面加载时执行startTime()--&gt;&lt;body onload=\"startTime()\"&gt; 123456789101112131415161718function startTime() &#123; var today = new Date(); var h = today.getHours(); var m = today.getMinutes(); var s = today.getSeconds(); // 在 numbers&lt;10 的数字前加上 0 m = checkTime(m); s = checkTime(s); document.getElementById(\"txt\").innerHTML = h + \":\" + m + \":\" + s; var t = setTimeout(function()&#123; startTime() &#125;, 500);&#125;function checkTime(i) &#123; if (i &lt; 10) &#123; i = \"0\" + i; &#125; return i;&#125; 5.传递参数给 Animal函数 123456789101112131415var myVar;function myStartFunction() &#123; // IE9 及其更早版本不支持 myVar = setTimeout(Animal, 5000, \"Cat\", \"Dog\"); //使用匿名函数，则所有浏览器都支持 myVar = setTimeout(function()&#123; Animal(\"Cat\", \"Dog\"); &#125;, 5000);&#125;function Animal(param1, param2) &#123; document.getElementById(\"demo1\").innerHTML += \"Hello \"; document.getElementById(\"demo2\").innerHTML = \"传递给 Animal() 的参数: &lt;br&gt;\" + param1 + \"&lt;br&gt;\" + param2 + \"&lt;br&gt;\";&#125; END","updated":"2020-07-23T07:21:15.562Z","categories":[{"name":"JavaWeb","slug":"JavaWeb","permalink":"http://yoursite.com/categories/JavaWeb/"}],"tags":[{"name":"JavaWeb","slug":"JavaWeb","permalink":"http://yoursite.com/tags/JavaWeb/"},{"name":"setTimeout()","slug":"setTimeout","permalink":"http://yoursite.com/tags/setTimeout/"}]},{"title":"JavaScript匿名函数理解及应用","date":"2020-07-23T04:10:06.000Z","path":"2020/07/23/JavaScript匿名函数理解及应用/","text":"Hello World! 匿名函数匿名函数顾名思义就是没有名字的函数，在实际开发中经常会用到，也是JavaScript的重点。匿名函数又叫立即执行函数。 由于这种函数是匿名的，所以它不能被调用。由于它不能被调用，所以如果它不立即执行的话就没有了意义。由于它需要立即执行，所以在执行完之后匿名函数就会被销毁。匿名自执行函数的作用就是用于闭包和创建独立的命名空间两个方面。 匿名函数的基本形式为(function(){…})(); 前面的括号包含函数体，后面的括号就是给匿名函数传递参数然后立即执行。 匿名函数的作用是避免全局变量的污染以及函数名的冲突。 匿名自执行函数的作用 1.匿名自执行函数最常见的作用是用于实现闭包的情况中。闭包:闭包是JavaScript的一种特性，我们可以通过闭包实现函数内外部的连接，并且可以使得函数的局部变量始终存在于内存中。 2.匿名自执行函数还可以用于在JavaScript中模拟创建块级作用域.使用匿名自执行函数将某些代码包裹起来可以实现块级作用域的效果，减少全局变量的数量，在匿名自执行函数执行结束后变量就会被内存释放掉，从而也会节省了内存。 小括号包着函数的小括号的作用：小括号能把我们的表达式组合分块，并且每一块，也就是每一对小括号，都有一个返回值。这个返回值实际上也就是小括号中表达式的返回值。所以，当我们用一对小括号把匿名函数包起来的时，实际上小括号对返回的，就是一个匿名函数的Function 对象。因此，小括号对加上匿名函数就如同有名字的函数般被我们取得它的引用位置了。所以如果在这个引用变量后面再加上参数列表，就会实现普通函数的调用形式。 小括号有返回值，就是小括号内的函数或者表达式的返回值，所以小括号内的function返回值等于小括号的返回值。 写法匿名函数的写法1.先定义一个普通函数Cat() 1234function Cat()&#123; alert(\"喵喵喵~~\");&#125; 2.去掉函数的名字构建匿名函数不包裹一个括号不符合语法要求，会报错！需要给匿名函数外边包裹一个括号才能运行。 1234(function ()&#123; alert(\"喵喵喵~~\");&#125;)() //()可省略 3.当匿名函数需要传值，将参数写到括号内 1234!(function (data)&#123; alert(\"喵喵喵~~\"+data);&#125;)(\"汪汪汪~~\") 4种实现方式 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253//常见匿名函数： //1，匿名函数的第一种实现方式 (function(cat)&#123; alert(cat); &#125;)(\"喵喵喵~~\"); //2.匿名自执行函数的第二种实现方式（常用）jQuery (function()&#123; alert(\"cat\"); &#125;()); //3.匿名自执行函数的第三种实现方式 !function(cat)&#123; alert(cat); &#125;(\"喵喵喵~~\"); //4.匿名自执行函数的第四种实现方式 var fun=function(cat)&#123; alert(cat); &#125;(\"喵喵喵~~\");//不常见匿名函数： ~(function()&#123; alert('cat'); &#125;)(); //效率最高 void function()&#123; alert('cat'); &#125;(); +function()&#123; alert('cat'); &#125;(); -function()&#123; alert('cat'); &#125;(); ~function()&#123; alert('cat'); &#125;(); !function()&#123; alert('cat'); &#125;(); //强制执行 (function()&#123; alert('cat'); &#125;()); 匿名函数的应用1.绑定事件 1234567&lt;input type=\"button\" value=\"点击\" id=\"btn\"&gt;```javascriptvar btn=document.querySelector(\"#btn\"); //querySelector是H5中新增的查找dom元素的方法 btn.οnclick=function()&#123; alert(\"\"); &#125; 2.应用对象 123456789101112131415var obj=&#123; animal:\"汤姆猫\", voice:\"喵喵喵~~\", CAT:function()&#123; return \"我是\"+this.animal+\"，我会\"+this.voice+\"叫！\"; &#125;&#125;;alert(obj.CAT()); 3.应用函数表达式 1234567//将匿名函数赋值给变量catvar cat=function()&#123; return \"喵喵喵~~\"&#125;//调用方式与调用普通函数一样alert(cat()); 4、回调函数的应用 1234setInterval(function()&#123; console.log(\"我是每5秒执行一次的回调函数\");&#125;,5000); 5、返回值 123456789101112function cat()&#123; //返回匿名函数 return function()&#123; return \"喵喵喵~~\"; &#125;&#125;//调用匿名函数alert(cat()());//或var mao=cat();alert(mao()); 6.链式调用 1234567(function(animal) &#123; alert(animal); return arguments.callee; &#125;)('cat')('dog')('pig'); END","updated":"2020-07-23T07:21:55.833Z","categories":[{"name":"JavaWeb","slug":"JavaWeb","permalink":"http://yoursite.com/categories/JavaWeb/"}],"tags":[{"name":"JavaWeb","slug":"JavaWeb","permalink":"http://yoursite.com/tags/JavaWeb/"},{"name":"js","slug":"js","permalink":"http://yoursite.com/tags/js/"}]},{"title":"聚光灯效果（css+html）","date":"2020-07-23T04:09:53.000Z","path":"2020/07/23/聚光灯效果（css-html）/","text":"Hello World! 最终效果： 实现code: 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657&lt;!DOCTYPE html&gt;&lt;html&gt; &lt;head&gt; &lt;meta charset=\"utf-8\"&gt; &lt;title&gt;聚光灯效果&lt;/title&gt; &lt;style&gt; *&#123; margin:0; padding:0; &#125; body&#123; background: #222; display: flex; justify-content: center; align-items: center; min-height: 100vh; &#125; h1&#123; color: #333; font-size: 8rem; position: relative; &#125; h1:after&#123; content: \"Hello JavaScript\"; color: transparent; position: absolute; left: 0; top: 0; background: -webkit-linear-gradient(left,#c23616,#192a56,#00d2d3,yellow,#6D214F,#2e86de,#4cd137,#e84118); background-clip: text; -webkit-background-clip:text; clip-path: circle(100px at 0% 50%); -webkit-clip-path: circle(100px at 0% 50%); animation: light 5s infinite; &#125; @keyframes light&#123; 0%&#123; clip-path: circle(100px at 0% 50%); -webkit-clip-path: circle(100px at 0% 50%); &#125; 50%&#123; clip-path: circle(100px at 100% 50%); -webkit-clip-path: circle(100px at 100% 50%); &#125; 100%&#123; clip-path: circle(100px at 0% 50%); -webkit-clip-path: circle(100px at 0% 50%); &#125; &#125; &lt;/style&gt; &lt;/head&gt; &lt;body&gt; &lt;div&gt;&lt;h1&gt;Hello JavaScript&lt;/h1&gt;&lt;/div&gt; &lt;/body&gt;&lt;/html&gt; END","updated":"2020-07-23T07:21:37.401Z","categories":[],"tags":[{"name":"JavaWeb","slug":"JavaWeb","permalink":"http://yoursite.com/tags/JavaWeb/"},{"name":"HTML","slug":"HTML","permalink":"http://yoursite.com/tags/HTML/"}]},{"title":"界面开发工具之HTML色彩表格工具","date":"2020-07-23T04:09:01.000Z","path":"2020/07/23/界面开发工具之HTML色彩表格工具-1/","text":"Hello World! 网址链接： HTML色彩表格工具 HTML色彩代码理论HTML代码格式：每一个HTML代码包含有“#”符号以及6个字幕和数字。这些数字都是十六进制的。比如“FF”在十六进制中代表十进制的数字255。 符号意义：HTML色彩代码中前两个符号表示红色的浓度。00指的是颜色最淡而FF则指的是颜色最浓。第三个和第四个符号表示绿色的浓度，第五个和第六个符号表示蓝色的浓度。由此，将各种浓度的红、绿、蓝三种颜色进行组合，我们可以调配出任何所需色彩 示例：#FF0000 - 利用这个HTML代码，我们让浏览器显示不掺杂任何绿色和蓝色成分的最鲜艳的红色。其结果当然就是纯红: #00FF00 - 这个HTML代码表示只有绿色且不掺杂任何红色和蓝色。其结果是: #0000FF - 这个HTML代码表示只有蓝色且不掺杂任何红色和绿色。其结果是: #FFFF00 - 红绿组合生成黄色: #CCEEFF - 一些红色、一点绿色以及最高浓度的蓝色，组合成天蓝色: END","updated":"2020-07-23T07:21:44.329Z","categories":[],"tags":[{"name":"JavaWeb","slug":"JavaWeb","permalink":"http://yoursite.com/tags/JavaWeb/"},{"name":"工具","slug":"工具","permalink":"http://yoursite.com/tags/%E5%B7%A5%E5%85%B7/"},{"name":"HTML","slug":"HTML","permalink":"http://yoursite.com/tags/HTML/"}]},{"title":"自动生成注释作者名字和日期等信息（IDEA Java类）","date":"2020-07-23T04:08:59.000Z","path":"2020/07/23/自动生成注释作者名字和日期等信息（IDEA-Java类）/","text":"Hello World! My Environment IDEA2018.3 JDK1.8 最终效果在创建java类后，自动生成定制的注释： 设置过程点击File-&gt;Settings-&gt;Editor-&gt;File and Code Templates在File Header中输入想要设置的信息如： 123456/**文件名: $&#123;NAME&#125;*创建者: your name*创建时间:$&#123;DATE&#125; $&#123;TIME&#125;*描述: 这是一个示例*/ 当然也可以参考下方的Description选择自己想要设置的完成创建时自动注释。|注释设置| 描述 ||–|–|| ${PACKAGE_NAME} | name of the package in which the new file is created || ${USER} | 创建者名称 || ${DATE} |当前日期 ||${TIME} | 当前时间 || ${YEAR} | 年 ||${MONTH} 月| || ${MONTH_NAME_SHORT} | 月缩写 || ${MONTH_NAME_FULL} |月全称 || ${DAY} | 天 || ${HOUR} | 时 || ${MINUTE} |分 || ${PROJECT_NAME} | 工程名 | END","updated":"2020-07-23T07:21:30.382Z","categories":[{"name":"JavaWeb","slug":"JavaWeb","permalink":"http://yoursite.com/categories/JavaWeb/"}],"tags":[{"name":"JavaWeb","slug":"JavaWeb","permalink":"http://yoursite.com/tags/JavaWeb/"},{"name":"Java","slug":"Java","permalink":"http://yoursite.com/tags/Java/"}]},{"title":"JavaWeb开发免费后台Html样式模板","date":"2020-07-23T04:08:57.000Z","path":"2020/07/23/JavaWeb开发免费后台Html样式模板/","text":"Hello World! 后台Html样式模板免费模板网（www.freemoban.com）提供大量的免费网站HTML网页模板,企业/响应式/自适应等免费网站模板源码，可以任意下载安装测试使用。链接: 免费模板 END","updated":"2020-07-23T07:21:21.894Z","categories":[{"name":"JavaWeb","slug":"JavaWeb","permalink":"http://yoursite.com/categories/JavaWeb/"}],"tags":[{"name":"JavaWeb","slug":"JavaWeb","permalink":"http://yoursite.com/tags/JavaWeb/"},{"name":"工具","slug":"工具","permalink":"http://yoursite.com/tags/%E5%B7%A5%E5%85%B7/"}]},{"title":"setInterval()方法实现周期调用函数来完成进度条等功能设计","date":"2020-07-23T04:08:22.000Z","path":"2020/07/23/setInterval-方法实现周期调用函数来完成进度条等功能设计/","text":"Hello World! setInterval() 方法setInterval() 方法可按照指定的周期（以毫秒计）来调用函数或计算表达式。一般与clearInterval()配合使用。 setInterval() 方法会不停地调用函数，直到==clearInterval() 被调用或窗口被关闭==。由 setInterval() 返回的 ID 值可用作 clearInterval() 方法的参数。提示： 1000 毫秒= 1 秒；如果你只想执行一次可以使用 setTimeout() 方法。 语法描述： 12setInterval(code, milliseconds);setInterval(function, milliseconds, param1, param2, ...) setInterval() 方法参数 描述 code/function 必要部分，要调用一个代码串，也可以是一个函数 milliseconds 必要部分，周期性执行或调用 code/function 之间的时间间隔，以毫秒计 param1, param2, … 非必要部分，传给执行函数的其他参数（IE9 及其更早版本不支持该参数） return:返回一个 ID（数字），可以将这个ID传递给clearInterval()，clearTimeout() 来取消执行setInterval() 。 clearInterval() 方法clearInterval() 方法可取消由 setInterval() 函数设定的定时执行操作。 clearInterval() 方法的参数必须是由 setInterval() 返回的 ID 值。注意: 要使用 clearInterval() 方法, 在创建执行定时操作时要使用==全局变量== 语法描述：|clearInterval() 方法| 描述 ||–|–||id_of_setinterval |必要部分，调用 setInterval() 函数时所获得的返回值，使用该返回标识符作为参数，可以取消该 setInterval() 所设定的定时执行操作 |return: return 0 方法应用实例1.显示当前时间( setInterval() 方法会每秒执行一次函数，类似手表功能) 12345678# 显示当前时间( setInterval() 方法会每秒执行一次函数，类似手表功能):var myVar = setInterval(function()&#123; myTimer() &#125;, 1000); function myTimer() &#123; var d = new Date(); var t = d.toLocaleTimeString(); document.getElementById(\"demo\").innerHTML = t;&#125; 2.使用 clearInterval() 来停止 setInterval 的执行 1234567891011var myVar = setInterval(function()&#123; myTimer() &#125;, 1000);function myTimer() &#123; var d = new Date(); var t = d.toLocaleTimeString(); document.getElementById(\"demo\").innerHTML = t;&#125;function myStopFunction() &#123; clearInterval(myVar);&#125; 3.使用 setInterval() 和 clearInterval()来创建动态进度条在javaweb中通过AJAX的get()方法和windows对象的setInterval()方法不断读取当前进度值来实现页面进度值的实时显示。 12345678910111213function move() &#123; var elem = document.getElementById(\"myBar\"); var width = 0; var myvar = setInterval(frame, 10); function frame() &#123; if (width == 100) &#123; clearInterval(myvar); &#125; else &#123; width++; elem.style.width = width + '%'; &#125; &#125;&#125; 4.每 5000 毫秒切换背景颜色 12345678910var myVar = setInterval(function()&#123; setColor() &#125;, 5000); function setColor() &#123; var x = document.body; x.style.backgroundColor = x.style.backgroundColor == \"red\" ? \"green\" : \"red\"; //x.style.backgroundColor = white&#125; function stopColor() &#123; clearInterval(myVar);&#125; ? : 是一个条件运算符,是一个整体,作用类似于if else 语句5.传递参数给 Animal 函数 12345678910111213141516171819var myVar;function myStartFunction() &#123; // IE9 及其更早版本不支持 myVar = setInterval(Animal, 2000, \"Cat\", \"Dog\"); //使用匿名函数，则所有浏览器都支持 myVar = setInterval(function()&#123; Animal(\"Cat\", \"Dog\"); &#125;, 2000);&#125;function Animal(param1, param2) &#123; document.getElementById(\"demo\").innerHTML += \"Animal \"; document.getElementById(\"demo2\").innerHTML = \"传递给 Animal() 的参数: &lt;br&gt;\" + param1 + \"&lt;br&gt;\" + param2 + \"&lt;br&gt;\";&#125;function myStopFunction() &#123; clearInterval(myVar);&#125; END","updated":"2020-07-23T07:22:01.946Z","categories":[{"name":"JavaWeb","slug":"JavaWeb","permalink":"http://yoursite.com/categories/JavaWeb/"}],"tags":[{"name":"JavaWeb","slug":"JavaWeb","permalink":"http://yoursite.com/tags/JavaWeb/"},{"name":"js","slug":"js","permalink":"http://yoursite.com/tags/js/"}]},{"title":"js中confirm弹框的确定按钮失效或无法传值解决办法","date":"2020-07-23T04:08:20.000Z","path":"2020/07/23/js中confirm弹框的确定按钮失效或无法传值解决办法/","text":"Hello World! 1.在项目中出现confirm弹框按钮失效，无法传布尔值，如果正常的话，使用以下代码即可完成传值： 1234567var result = window.confirm('是否XXXX?'); if (result == true)&#123; alert('终止操作！'); result = false; &#125;else&#123; alert('终止操作取消！'); result = false;&#125; 2.但是这个弹框中的按钮失效了，只能基于bootstrap重新创建一下，可以参考以下这种，直接在js中插入这段代码(亲测有效）： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150$(function () &#123;window.Ewin = function () &#123; var html = '&lt;div id=\"[Id]\" class=\"modal fade\" role=\"dialog\" aria-labelledby=\"modalLabel\"&gt;' + '&lt;div class=\"modal-dialog modal-sm\"&gt;' + '&lt;div class=\"modal-content\"&gt;' + '&lt;div class=\"modal-header\"&gt;' + '&lt;button type=\"button\" class=\"close\" data-dismiss=\"modal\"&gt;&lt;span aria-hidden=\"true\"&gt;×&lt;/span&gt;&lt;span class=\"sr-only\"&gt;Close&lt;/span&gt;&lt;/button&gt;' + '&lt;h4 class=\"modal-title\" id=\"modalLabel\"&gt;[Title]&lt;/h4&gt;' + '&lt;/div&gt;' + '&lt;div class=\"modal-body\"&gt;' + '&lt;p&gt;[Message]&lt;/p&gt;' + '&lt;/div&gt;' + '&lt;div class=\"modal-footer\"&gt;' + '&lt;button type=\"button\" class=\"btn btn-default cancel\" data-dismiss=\"modal\"&gt;[BtnCancel]&lt;/button&gt;' + '&lt;button type=\"button\" class=\"btn btn-primary ok\" data-dismiss=\"modal\"&gt;[BtnOk]&lt;/button&gt;' + '&lt;/div&gt;' + '&lt;/div&gt;' + '&lt;/div&gt;' + '&lt;/div&gt;'; var dialogdHtml = '&lt;div id=\"[Id]\" class=\"modal fade\" role=\"dialog\" aria-labelledby=\"modalLabel\"&gt;' + '&lt;div class=\"modal-dialog\"&gt;' + '&lt;div class=\"modal-content\"&gt;' + '&lt;div class=\"modal-header\"&gt;' + '&lt;button type=\"button\" class=\"close\" data-dismiss=\"modal\"&gt;&lt;span aria-hidden=\"true\"&gt;×&lt;/span&gt;&lt;span class=\"sr-only\"&gt;Close&lt;/span&gt;&lt;/button&gt;' + '&lt;h4 class=\"modal-title\" id=\"modalLabel\"&gt;[Title]&lt;/h4&gt;' + '&lt;/div&gt;' + '&lt;div class=\"modal-body\"&gt;' + '&lt;/div&gt;' + '&lt;/div&gt;' + '&lt;/div&gt;' + '&lt;/div&gt;'; var reg = new RegExp(\"\\\\[([^\\\\[\\\\]]*?)\\\\]\", 'igm'); var generateId = function () &#123; var date = new Date(); return 'mdl' + date.valueOf(); &#125; var init = function (options) &#123; options = $.extend(&#123;&#125;, &#123; title: \"操作提示\", message: \"提示内容\", btnok: \"确定\", btncl: \"取消\", width: 200, auto: false &#125;, options || &#123;&#125;); var modalId = generateId(); var content = html.replace(reg, function (node, key) &#123; return &#123; Id: modalId, Title: options.title, Message: options.message, BtnOk: options.btnok, BtnCancel: options.btncl &#125;[key]; &#125;); $('body').append(content); $('#' + modalId).modal(&#123; width: options.width, backdrop: 'static' &#125;); $('#' + modalId).on('hide.bs.modal', function (e) &#123; $('body').find('#' + modalId).remove(); &#125;); return modalId; &#125; return &#123; alert: function (options) &#123; if (typeof options == 'string') &#123; options = &#123; message: options &#125;; &#125; var id = init(options); var modal = $('#' + id); modal.find('.ok').removeClass('btn-success').addClass('btn-primary'); modal.find('.cancel').hide(); return &#123; id: id, on: function (callback) &#123; if (callback &amp;&amp; callback instanceof Function) &#123; modal.find('.ok').click(function () &#123; callback(true); &#125;); &#125; &#125;, hide: function (callback) &#123; if (callback &amp;&amp; callback instanceof Function) &#123; modal.on('hide.bs.modal', function (e) &#123; callback(e); &#125;); &#125; &#125; &#125;; &#125;, confirm: function (options) &#123; var id = init(options); var modal = $('#' + id); modal.find('.ok').removeClass('btn-primary').addClass('btn-success'); modal.find('.cancel').show(); return &#123; id: id, on: function (callback) &#123; if (callback &amp;&amp; callback instanceof Function) &#123; modal.find('.ok').click(function () &#123; callback(true); &#125;); modal.find('.cancel').click(function () &#123; callback(false); &#125;); &#125; &#125;, hide: function (callback) &#123; if (callback &amp;&amp; callback instanceof Function) &#123; modal.on('hide.bs.modal', function (e) &#123; callback(e); &#125;); &#125; &#125; &#125;; &#125;, dialog: function (options) &#123; options = $.extend(&#123;&#125;, &#123; title: 'title', url: '', width: 800, height: 550, onReady: function () &#123; &#125;, onShown: function (e) &#123; &#125; &#125;, options || &#123;&#125;); var modalId = generateId(); var content = dialogdHtml.replace(reg, function (node, key) &#123; return &#123; Id: modalId, Title: options.title &#125;[key]; &#125;); $('body').append(content); var target = $('#' + modalId); target.find('.modal-body').load(options.url); if (options.onReady()) options.onReady.call(target); target.modal(); target.on('shown.bs.modal', function (e) &#123; if (options.onReady(e)) options.onReady.call(target, e); &#125;); target.on('hide.bs.modal', function (e) &#123; $('body').find(target).remove(); &#125;); &#125; &#125; &#125;();&#125; 调用的话，在当前js中需要应用的按钮绑定的功能函数中进行调用： 1234567//e为布尔值Ewin.confirm(&#123; message: \"是否确认XXX？\" &#125;).on(function (e) &#123;if (e) &#123;alert('终止操作！'); //e=true&#125;else&#123;alert('终止操作取消！');&#125; //e!=true&#125;); 效果图（且对页面内容有遮罩层）： 1Ewin.alert(\"操作成功！\"); balabala… END","updated":"2020-07-23T07:21:50.032Z","categories":[{"name":"JavaWeb","slug":"JavaWeb","permalink":"http://yoursite.com/categories/JavaWeb/"}],"tags":[{"name":"JavaWeb","slug":"JavaWeb","permalink":"http://yoursite.com/tags/JavaWeb/"},{"name":"js","slug":"js","permalink":"http://yoursite.com/tags/js/"}]},{"title":"界面开发工具之HTML色彩表格工具","date":"2020-07-23T04:08:16.000Z","path":"2020/07/23/界面开发工具之HTML色彩表格工具/","text":"Hello World! 网址链接： HTML色彩表格工具 HTML色彩代码理论HTML代码格式：每一个HTML代码包含有“#”符号以及6个字幕和数字。这些数字都是十六进制的。比如“FF”在十六进制中代表十进制的数字255。 符号意义：HTML色彩代码中前两个符号表示红色的浓度。00指的是颜色最淡而FF则指的是颜色最浓。第三个和第四个符号表示绿色的浓度，第五个和第六个符号表示蓝色的浓度。由此，将各种浓度的红、绿、蓝三种颜色进行组合，我们可以调配出任何所需色彩 示例：#FF0000 - 利用这个HTML代码，我们让浏览器显示不掺杂任何绿色和蓝色成分的最鲜艳的红色。其结果当然就是纯红: #00FF00 - 这个HTML代码表示只有绿色且不掺杂任何红色和蓝色。其结果是: #0000FF - 这个HTML代码表示只有蓝色且不掺杂任何红色和绿色。其结果是: #FFFF00 - 红绿组合生成黄色: #CCEEFF - 一些红色、一点绿色以及最高浓度的蓝色，组合成天蓝色: END","updated":"2020-07-23T07:21:09.281Z","categories":[],"tags":[]},{"title":"PageHelper分页插件的整合与项目应用","date":"2020-07-22T11:31:56.000Z","path":"2020/07/22/PageHelper分页插件的整合与项目应用/","text":"Hello World! MyBatis 分页插件 PageHelper链接: PageHelper官网.分页插件支持任何复杂的单表、多表分页； 分页结果（结合了一点BootStrap）： My Environment IDEA2018.3 JDK1.8 SpringBoot2.3.0 360浏览器 Springboot整合PageHelper插件1. pom.xml引入PageHelper依赖123456&lt;!--引入pagehelper分页插件--&gt; &lt;dependency&gt; &lt;groupId&gt;com.github.pagehelper&lt;/groupId&gt; &lt;artifactId&gt;pagehelper-spring-boot-starter&lt;/artifactId&gt; &lt;version&gt;1.2.10&lt;/version&gt; &lt;/dependency&gt; 2. 配置application.properties/application.ymlapplication.properties: 12345# pagehelper分页插件配置pagehelper.helperDialect=mysqlpagehelper.reasonable=truepagehelper.supportMethodsArguments=truepagehelper.params=count=countSql application.yml: 123456# pagehelper分页插件配置pagehelper: helperDialect: mysql reasonable: true supportMethodsArguments: true pageSizeZero: false #pageSize=0 有关分页插件的基本配置就完成了（当然其他必要的基本配置也需要提前配置好）;也可以直接参考官网链接: 使用文档. SpringBoot结合Thymeleaf实现分页首先我们需要写一个查询数据库然后展示到前端界面的各层代码：Entity类： 12345678910111213141516171819202122232425package com.cjw.entity;import lombok.AllArgsConstructor;import lombok.NoArgsConstructor;import lombok.ToString;import lombok.Data;import lombok.experimental.Accessors;import java.util.Date;@Data@ToString@AllArgsConstructor@NoArgsConstructor@Accessors(chain = true) //链式调用public class Emp &#123; private String id; private String name; private Double salary; private Integer age; private Date bir;&#125; Dao层接口： 12345678910111213package com.cjw.dao;import com.cjw.entity.Emp;import org.springframework.stereotype.Repository;import java.util.List;@Repositorypublic interface EmpDao &#123; List&lt;Emp&gt; findAll();&#125; 数据库Mapper.xml文件： 1234567891011&lt;?xml version=\"1.0\" encoding=\"UTF-8\" ?&gt;&lt;!DOCTYPE mapper PUBLIC \"-//mybatis.org//DTD Mapper 3.0//EN\" \"http://mybatis.org/dtd/mybatis-3-mapper.dtd\"&gt;&lt;mapper namespace=\"com.cjw.dao.EmpDao\"&gt; &lt;!--查询所有--&gt; &lt;select id=\"findAll\" resultType=\"Emp\"&gt; select id,name,salary,age,bir from t_emp &lt;/select&gt;&lt;/mapper&gt; 服务层及其实现层： 123456789package com.cjw.service;import com.cjw.entity.Emp;import java.util.List;public interface EmpService &#123; List&lt;Emp&gt; findAll();&#125; 1234567891011121314151617181920212223package com.cjw.service.Impl;import com.cjw.dao.EmpDao;import com.cjw.entity.Emp;import com.cjw.service.EmpService;import org.springframework.beans.factory.annotation.Autowired;import org.springframework.stereotype.Service;import java.util.List;import java.util.UUID;@Servicepublic class EmpServiceImpl implements EmpService &#123; @Autowired private EmpDao empDao; @Override public List&lt;Emp&gt; findAll() &#123; return empDao.findAll(); &#125;&#125; 然后只需要在控制层中使用分页插件进行替换，并用model返回至前端：控制层： 12345678910111213141516171819@Controllerpublic class EmpController &#123; @Autowired private EmpService empService; @GetMapping(\"emp/findAll\") public String findAll(@RequestParam(defaultValue = \"1\") int pageNum, @RequestParam(defaultValue = \"5\") int pageSize, Model model)&#123; PageHelper.startPage(pageNum,pageSize);//关键 PageInfo&lt;Emp&gt; pageInfo = new PageInfo&lt;&gt;(empService.findAll()); model.addAttribute(\"pageInfo\",pageInfo);// List&lt;Emp&gt; emps = empService.findAll();// model.addAttribute(\"emps\",emps); return \"ems/emplist\"; &#125; 前端Html: 123456789101112131415161718192021222324252627282930313233343536373839404142434445&lt;table class=\"table\"&gt; &lt;tr class=\"table_header\"&gt; &lt;td&gt; ID &lt;/td&gt; &lt;td&gt; 用户名 &lt;/td&gt; &lt;td&gt; 收入 &lt;/td&gt; &lt;td&gt; 年龄 &lt;/td&gt; &lt;td&gt; 生日 &lt;/td&gt; &lt;td&gt; 操作 &lt;/td&gt; &lt;/tr&gt;&lt;tr th:class=\"$&#123;rowstate.odd&#125;?'row1':'row2'\" th:each=\"emp,rowstate:$&#123;pageInfo.list&#125;\" &gt; &lt;td&gt; &lt;span th:text=\"$&#123;emp.id&#125;\"&gt;&lt;/span&gt; &lt;/td&gt; &lt;td&gt; &lt;span th:text=\"$&#123;emp.name&#125;\"&gt;&lt;/span&gt; &lt;/td&gt; &lt;td&gt; &lt;span th:text=\"$&#123;emp.salary&#125;\"&gt;&lt;/span&gt; &lt;/td&gt; &lt;td&gt; &lt;span th:text=\"$&#123;emp.age&#125;\"&gt;&lt;/span&gt; &lt;/td&gt; &lt;td&gt; &lt;span th:text=\"$&#123;#dates.format(emp.bir,'yyyy-MM-dd')&#125;\"&gt;&lt;/span&gt; &lt;/td&gt; &lt;td&gt; &lt;!--&lt;a th:href=\"@&#123;/toSave&#125;\"&gt;新增&lt;/a&gt;&amp;nbsp;--&gt; &lt;a th:href=\"@&#123;/emp/update(id=$&#123;emp.id&#125;)&#125;\"&gt;更改&lt;/a&gt;&amp;nbsp; &lt;a th:href=\"@&#123;/emp/delete(id=$&#123;emp.id&#125;)&#125;\"&gt;删除&lt;/a&gt; &lt;/td&gt; &lt;/tr&gt; &lt;/table&gt; 分页部分： 12345678910111213&lt;div class=\"modal-footer no-margin-top\"&gt; &lt;ul class=\"pagination pagination-lg\"&gt; &lt;li class=\"page-item\"&gt;&lt;a class=\"page-link\"&gt;&lt;span&gt;当前页为：&lt;/span&gt;&lt;span th:text=\"第+$&#123;pageInfo.pageNum&#125;+页\"&gt;&lt;/span&gt;&lt;/a&gt;&lt;/li&gt; &lt;!--&lt;li class=\"page-item\"&gt;&lt;a class=\"page-link\" th:href=\"@&#123;/emp/findAll&#125;\"&gt;首页&lt;/a&gt;&lt;/li&gt;--&gt; &lt;li&gt;&lt;a th:href=\"@&#123;/emp/findAll?pageNum=0&#125;\"&gt;首页&lt;/a&gt;&lt;/li&gt; &lt;li class=\"page-item\"&gt;&lt;a class=\"page-link\" th:href=\"@&#123;/emp/findAll(pageNum=1)&#125;\"&gt;1&lt;/a&gt;&lt;/li&gt; &lt;li class=\"page-item\"&gt;&lt;a class=\"page-link\" th:href=\"@&#123;/emp/findAll(pageNum=2)&#125;\"&gt;2&lt;/a&gt;&lt;/li&gt; &lt;li class=\"page-item\"&gt;&lt;a class=\"page-link\" th:href=\"@&#123;/emp/findAll(pageNum=3)&#125;\"&gt;3&lt;/a&gt;&lt;/li&gt; &lt;li class=\"page-item\"&gt;&lt;a class=\"page-link\" th:href=\"@&#123;/emp/findAll(pageNum=$&#123;pageInfo.getNextPage()&#125;)&#125;\"&gt;下一页&lt;/a&gt;&lt;/li&gt; &lt;li class=\"page-item\"&gt;&lt;a class=\"page-link\"&gt;&lt;span th:text=\"共+$&#123;pageInfo.pageSize&#125;+页\"&gt;&lt;/span&gt;&lt;/a&gt;&lt;/li&gt; &lt;/ul&gt; &lt;/div&gt; END","updated":"2020-07-23T07:20:59.794Z","categories":[{"name":"SpringBoot","slug":"SpringBoot","permalink":"http://yoursite.com/categories/SpringBoot/"}],"tags":[{"name":"SpringBoot","slug":"SpringBoot","permalink":"http://yoursite.com/tags/SpringBoot/"},{"name":"PageHelper","slug":"PageHelper","permalink":"http://yoursite.com/tags/PageHelper/"}]},{"title":"SpringBoot项目热部署生效方法","date":"2020-07-22T11:31:36.000Z","path":"2020/07/22/SpringBoot项目热部署生效方法/","text":"Hello World! My Environment IDEA2018.3 JDK1.8 SpringBoot2.3.0 360浏览器 Springboot提供了热部署的方式，当发现有任何类发生了改变，马上通过JVM类加载的方式，加载最新的类到虚拟机中。 这样就不必重启也能看到改动后的效果了，只需在浏览器刷新页面即可更新显示内容，不需要再重启整个项目工程，提高了开发效率。 如果前端使用了thymeleaf，那么在properties或yml中配置关闭thymeleaf缓存： 1spring.thymeleaf.cache=false 如果修改的只是页面会自动刷新，如果是java类文件需要手动点击工具栏的build–&gt;Build-&gt;Modules ‘myProject’. Springboot版本也有可能导致热部署配置失败 1. pom.xml在pom文件中，引入如下依赖： 123456&lt;!--热部署插件--&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-devtools&lt;/artifactId&gt; &lt;scope&gt;runtime&lt;/scope&gt; &lt;/dependency&gt; 后，在插件中配置按如下配置： 12345678910111213&lt;build&gt; &lt;plugins&gt; &lt;plugin&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-maven-plugin&lt;/artifactId&gt; &lt;configuration&gt; &lt;!--fork : 必须配置，否则热部署不会生效，应用不会重置 --&gt; &lt;fork&gt;true&lt;/fork&gt; &lt;addResources&gt;true&lt;/addResources&gt; &lt;/configuration&gt; &lt;/plugin&gt; &lt;/plugins&gt; &lt;/build&gt; 或者直接在依赖中配置： 12345&lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-devtools&lt;/artifactId&gt; &lt;optional&gt;true&lt;/optional&gt; &lt;!--true时热部署生效 --&gt;&lt;/dependency&gt; 打开maven仓库查看配置和依赖是否引入完成。 2. IDEA中配置File中Settings打开顶部工具栏 File -&gt; Settings -&gt; Default Settings -&gt; Build -&gt; Compiler 然后勾选 Build project automatically 如下图所示：后点击Help中的Find Action —&gt;（Ctrl + Shift + A）后在搜索栏中输入Registry查找：点击确定后，勾选 Compiler autoMake allow when app running后保存设置： 3. 浏览器中配置打开浏览器按Fn + F12进入审查元素，选择Network后勾选【✅】Disable cache ： 确保以上均已完成配置，那么===================================================项目热部署配置完成，重新编译启动工程修改IDEA工程代码后刷新浏览器，不用再重新启动工程了! END","updated":"2020-07-23T07:18:55.927Z","categories":[{"name":"SpringBoot","slug":"SpringBoot","permalink":"http://yoursite.com/categories/SpringBoot/"}],"tags":[{"name":"热部署","slug":"热部署","permalink":"http://yoursite.com/tags/%E7%83%AD%E9%83%A8%E7%BD%B2/"}]},{"title":"Maven仓库导包慢的解决办法","date":"2020-07-22T11:31:15.000Z","path":"2020/07/22/Maven仓库导包慢的解决办法/","text":"Hello World! 故障原因原因：默认安装的maven使用官网地址下载依赖包，在国内访问比较慢。方法：将maven配置文件中下载依赖包地址修改成国内地址，一般都使用阿里的地址。 解决方法1，右键项目名，选择maven替换setting.xml文件中的这部分为如下样式： 1234567891011121314151617181920212223242526272829303132333435&lt;mirrors&gt; &lt;!-- mirror | Specifies a repository mirror site to use instead of a given repository. The repository that | this mirror serves has an ID that matches the mirrorOf element of this mirror. IDs are used | for inheritance and direct lookup purposes, and must be unique across the set of mirrors. | &lt;mirror&gt; &lt;id&gt;mirrorId&lt;/id&gt; &lt;mirrorOf&gt;repositoryId&lt;/mirrorOf&gt; &lt;name&gt;Human Readable Name for this Mirror.&lt;/name&gt; &lt;url&gt;http://my.repository.com/repo/path&lt;/url&gt; &lt;/mirror&gt; --&gt; &lt;!-- &lt;mirror&gt; --&gt; &lt;!-- &lt;id&gt;repo2&lt;/id&gt; --&gt; &lt;!-- &lt;mirrorOf&gt;central&lt;/mirrorOf&gt; --&gt; &lt;!-- &lt;name&gt;Human Readable Name for this Mirror.&lt;/name&gt; --&gt; &lt;!-- &lt;url&gt;http://repo2.maven.org/maven2/&lt;/url&gt; --&gt; &lt;!-- &lt;/mirror&gt; --&gt; &lt;mirror&gt; &lt;!--This sends everything else to /public --&gt; &lt;id&gt;nexus&lt;/id&gt; &lt;mirrorOf&gt;*&lt;/mirrorOf&gt; &lt;url&gt;http://maven.aliyun.com/nexus/content/groups/public/&lt;/url&gt; &lt;/mirror&gt; &lt;mirror&gt; &lt;!--This is used to direct the public snapshots repo in the profile below over to a different nexus group --&gt; &lt;id&gt;nexus-public-snapshots&lt;/id&gt; &lt;mirrorOf&gt;public-snapshots&lt;/mirrorOf&gt; &lt;url&gt;http://maven.aliyun.com/nexus/content/repositories/snapshots/&lt;/url&gt; &lt;/mirror&gt; &lt;/mirrors&gt; 2.打开本地maven位置，选择setting.xml文件，修改同上位置打开.xml文件后替换红框部分：重启idea后更新maven仓库，下载飞快。 END","updated":"2020-07-23T07:18:55.876Z","categories":[{"name":"JavaWeb","slug":"JavaWeb","permalink":"http://yoursite.com/categories/JavaWeb/"}],"tags":[{"name":"Maven","slug":"Maven","permalink":"http://yoursite.com/tags/Maven/"},{"name":"SpringBoot","slug":"SpringBoot","permalink":"http://yoursite.com/tags/SpringBoot/"}]},{"title":"SpringBoot的启动图案修改","date":"2020-07-22T11:30:53.000Z","path":"2020/07/22/SpringBoot的启动图案修改/","text":"Hello World! Springboot项目启动时，会出现大大的SpringBoot的图案：修改：首先创建springboot项目，首先在resources/目录下创建名为banner.txt的文件：点击链接：SpringBoot的启动图案修改 启动项目：无聊…..END","updated":"2020-07-23T07:18:56.052Z","categories":[{"name":"SpringBoot","slug":"SpringBoot","permalink":"http://yoursite.com/categories/SpringBoot/"}],"tags":[{"name":"启动图案修改","slug":"启动图案修改","permalink":"http://yoursite.com/tags/%E5%90%AF%E5%8A%A8%E5%9B%BE%E6%A1%88%E4%BF%AE%E6%94%B9/"}]},{"title":"Java Web之环境搭建（测试用）","date":"2020-07-22T11:19:02.000Z","path":"2020/07/22/Java-Web之环境搭建（测试用）/","text":"Hello World! Java Web之环境搭建1. Java Web介绍Java Web是用Java技术来解决web领域的技术，需要运行在特定的web服务器上，Java Web是跨平台的，可以在不同的平台上进行部署运行。需要掌握的技术1.前端方面的相关技术如：html、css、js等2.服务端先关技术如：java，jsp，服务器，ssh、ssm框架，等3.数据库相关：MySQL，Oracle等 2. 开发环境准备编辑器：Eclipse或Idea等java环境：JDK1.8服务器：Tomcat环境搭建完毕之后，就可以创建项目开始开发了。 环境搭建参考：Java Web之环境搭建.","updated":"2020-07-23T07:22:33.490Z","categories":[{"name":"JavaWeb","slug":"JavaWeb","permalink":"http://yoursite.com/categories/JavaWeb/"}],"tags":[{"name":"JavaWeb","slug":"JavaWeb","permalink":"http://yoursite.com/tags/JavaWeb/"}]},{"title":"springboot application.properties 配置及参数配置详情介绍","date":"2020-07-22T11:18:28.000Z","path":"2020/07/22/springboot-application-properties-配置及参数配置详情介绍/","text":"Hello World! application.properties： 12345678910111213141516171819#server.port=8080#server.servlet.context-path=/index #访问路径设置spring.datasource.url = jdbc:mysql://localhost:3306/ems?characterEncoding=UTF-8&amp;useSSL=true&amp;serverTimezone=UTCspring.datasource.username = rootspring.datasource.password = 123456spring.datasource.driverClassName = com.mysql.cj.jdbc.Driverspring.datasource.type = com.alibaba.druid.pool.DruidDataSourcemybatis.mapper-locations = classpath:mapper/*.xmlmybatis.type-aliases-package = com.dvms.entityspring.resources.static-locations = classpath:/templates/,classpath:/static/#pagehelper分页插件配置pagehelper.helperDialect=mysqlpagehelper.reasonable=truepagehelper.supportMethodsArguments=truepagehelper.params=count=countSql 查看参数配置：spring boot application.properties 配置参数详情： multipartmultipart.enabled 开启上传支持（默认：true） multipart.file-size-threshold: 大于该值的文件会被写到磁盘上 multipart.location 上传文件存放位置 multipart.max-file-size最大文件大小 multipart.max-request-size 最大请求大小 serverserver.address 服务器地址 server.port 服务器端口 server.context-parameters.[param name] 设置 servlet 上下文参数 server.context-path 应用上下文路径 Jsp-serveltserver.jsp-servelt.class-name 针对jsp 使用的 Servlet 类名（默认：org.apache.jasper.servlet.JspServlet） server.jsp-servlet.registered JspServelt 是否要注册到内嵌的 Servlet 容器里（默认 true） server.jsp-servlet.init-parameters[param name] 设置 Jsp Servlet 初始化参数 server.servlet-path主分发器 Servlet 的路径（默认：/） Sessionserver.session.cookie.domain 回话 Cookie 的域 server.session.cookie.comment Cookie 注释 server.session.cookie.max-age Cookie 最大保存时间（单位 s） server.session.cookie.name Cookie 名称 server.session.cookie.timeout 超时时间 tomcatserver.tomcat.accesslog.directory 创建日志文件的目录 server.tomcat.accesslog.enabled 是否开启访问日志（默认：false） server.tomcat.accesslog.pattern 访问日志的格式（默认：common） server.tomcat.accesslog.prefix日志名前缀（默认：access_log） server.tomcat.accesslog.suffix 日志名后缀（默认：.log） server.tomcat.max-http-header-sizeHttp 消息头最大字节数（默认：0） server.tomcat.uri-encoding 用来解码 URI 的字符编码 Cachespring.cache.cache-names 如果底层缓存管理器支持缓存名的话，可以在这里指定要创建的缓存名列表，用逗号分 隔。通常这会禁用运行时创建其他额外缓存的能力。 spring.cache.config 用来初始化 EhCache 的配置文件位置 spring.cache.guava.spec 用来创建缓存 Spec spring.cache.hazelcast.config 用来初始化 Hazeleast 的配置文件位置 spring.cache.infinispan.config 用来初始化 Infinispan 配置文件位置 spring.cache.jcache.config用来初始化缓存管理器的配置文件的位置，配置文件依赖于底层的缓存实现 spring.cache.jcache.provider CachingProvider 实现的全限定类名，用来获取 JSR-107 兼容的缓存管理器，仅在 Classpath 里有不只一个 JSR-107 实现时才需要这个属性。 spring.cache.type 缓存类型，默认根据环境自动检测 Dataspring.data.jpa.repositories.enabled 开启 JPA 仓库（默认：true） spring.data.mongodb.authentication-database 身份认证数据库名 spring.data.mongodb.database 数据库名 spring.data.mongodb.field-naming-strategy 要使用的 FieldNamingStrategy 的全限定名。 spring.data.mongodb.grid.fs.database GridFS 数据库名称 spring.data.mongodb.host MongoDB 服务器地址 spring.data.mongodb.username MongoDB 账号 spring.data.mongodb.passwordMongoDB 密码 spring.data.mongodb.port 端口号 spring.data.mongodb.repositories.enabled 开启 Mongo 仓库（默认值：true） spring.data.mongodb.uri Mongo 数据库 URI。设置了该属性后就主机和端口号会被忽略。（默认值： mongodb:// localhost/test） spring.data.rest.base-path 用于发布仓库资源的基本路径 spring.data.rest.default-page-size 分页数据的默认页大小（默认：20） spring.data.rest.limit-param-name用于标识一次返回多少记录的 URL 查询字符串参数名。（默认值： size ） spring.data.rest.max-page-sieze: 最大分页大小（默认：1000） spring.data.rest.page-param-name URL 查询字符串参数的名称，用来标识返回哪一页。（默认值： page ） spring.data.rest.return-body-on-create 在创建实体后是否返回一个响应体（默认：false） spring.data.rest.return-body-on-update 在更新实体后是否返回一个响应体（默认：false） spring.data.rest.sort-param-name URL 查询字符串参数的名称，用来表示结果排序的方向（默认：name） spring.data.solr.host Solr 的主机地址。如果设置了 zk-host 则忽略该属性。（默认值： http://127.0.0.1: 8983/solr ） spring.data.solr.repositories.enabled 开启 solr 仓库（默认：true） spring.data.solr.zk-host zk 主机地址，格式为 “主机 - 端口” spring.datasource.allow-pool-suspension 是否允许池暂停（pool suspension）。在开启池暂停后会有性能会受到一定影响，除非你 真的需要这个功能（例如在冗余的系统下），否则不要开启它。该属性只在使用 Hikari 数 据库连接池时有用。（默认值： false 。） DataSourcespring.datasource.name 数据源的名称。 spring.datasource.username 数据库的登录用户名。 spring.datasource.password 数据库的登录密码。 spring.datasource.url 数据库的 JDBC URL。 spring.datasource.jdbc-url 用来创建连接的 JDBC URL。 spring.datasource.driver-class-name JDBC 驱动的全限定类名。默认根据 URL 自动检测。 spring.datasource.pool-name 连接池名称。 spring.datasource.max-active 连接池中的最大活跃连接数。 spring.datasource.connection-timeout连接超时（单位毫秒） spring.datasource.max-age 连接池中连接的最长寿命。 spring.datasource.max-idle 连接池中的最大空闲连接数。 spring.datasource.max-lifetime 连接池中连接的最长寿命（单位为毫秒）。 spring.datasource.max-open-prepared-statements 开启状态的 PreparedStatement 的数量上限。 spring.datasource.max-wait 连接池在等待返回连接时，最长等待多少毫秒再抛出异常。 spring.datasource.maximum-pool-size 连接池能达到的最大规模，包含空闲连接的数量和使用中的连接数量。 spring.datasource.min-evictable-idle-time-millis 一个空闲连接被空闲连接释放器（如果存在的话）优雅地释放前，最短会在连接池里停 留多少时间。 spring.datasource.min-idle 连接池里始终应该保持的最小连接数。（用于 DBCP 和 Tomcat 连接池。） spring.datasource.minimum-idle: HikariCP 试图在连接池里维持的最小空闲连接数。 spring.datasource.alternate-username-allowed 是否允许其它用户名 spring.datasource.auto-commit 更新操作是否自动提交 spring.datasource.abandon-when-percentage-full 一个百分比形势的阈值，超过该阈值则关闭并报告被弃用的连接 spring.datasource.catalog 默认的 Catalog 名称 spring.datasource.commit-on-return 在连接归还时，连接池是否要提交挂起的事务 spring.datasource.connection-init-sql 在所有新连接创建时都会执行的 SQL 语句，该语句会在连接加入连接池前执行。 spring.datasource.connection-init-sqls 在物理连接第一次创建时执行的 SQL 语句列表。（用于 DBCP 连接池。） spring.datasource.connection-properties.[key] 设置创建连接时使用的属性。（用于 DBCP 连接池。） spring.datasource.continue-on-error 初始化数据库时发生错误不要终止。（默认值： false） spring.datasource.data 指向数据（数据库操纵语言，Data Manipulation Language，DML）脚本资源的引用。 spring.datasource.data-source-class-name 用于获取连接的数据源的全限定类名。 spring.datasource.data-source-jndi 用于获取连接的数据源的 JNDI 位置。 spring.datasource.data-source-properties.[key] 设置创建数据源时使用的属性。（用于 Hikari 连接池。） spring.datasource.db-properties 设置创建数据源时使用的属性。（用于 Tomcat 连接池。） spring.datasource.default-auto-commit 连接上的操作是否自动提交。 spring.datasource.default-catalog 连接的默认 Catalog。 spring.datasource.default-read-only 连接的默认只读状态。 spring.datasource.default-transaction-isolation 连接的默认事务隔离级别。 spring.datasource.fair-queue 是否以 FIFO 方式返回连接。 spring.datasource.health-check-properties.[key] 设置要纳入健康检查的属性。（用于 Hikari 连接池。） spring.datasource.idle-timeout 连接池中的连接能保持闲置状态的最长时间，单位为毫秒。（默认值： 10 。） spring.datasource.ignore-exception-on-pre-load 初始化数据库连接池时是否要忽略连接。 spring.datasource.init-sql在连接第一次创建时运行的自定义查询。 spring.datasource.initial-size 在连接池启动时要建立的连接数。 spring.datasource.initialization-fail-fast 在连接池创建时，如果达不到最小连接数是否要抛出异常。（默认值： true 。） spring.datasource.initialize 使用 data.sql 初始化数据库。（默认值： true 。） spring.datasource.isolate-internal-queries 是否要隔离内部请求。（默认值： false 。） spring.datasource.jdbc-interceptors 一个分号分隔的类名列表，这些类都扩展了 JdbcInterceptor 类。这些拦截器会插入 java.sql.Connection 对象的操作链里。（用于 Tomcat 连接池。） spring.datasource.jmx-enabled 开启 JMX 支持（如果底层连接池提供该功能的话）。（默认值： false 。） spring.datasource.jndi-name 数据源的 JNDI 位置。设置了该属性则忽略类、URL、用户名和密码属性。 spring.datasource.leak-detection-threshold 用来检测 Hikari 连接池连接泄露的阈值，单位为毫秒。 spring.datasource.log-abandoned 是否针对弃用语句或连接的应用程序代码记录下跟踪栈。用于 DBCP 连接池。（默认值： false 。） spring.datasource.log-validation-errors 在使用 Tomcat 连接池时是否要记录验证错误。 spring.datasource.login-timeout 连接数据库的超时时间（单位为秒）。 spring.datasource.num-tests-per-eviction-run 空闲对象释放器线程（如果存在的话）每次运行时要检查的对象数。 spring.datasource.platform 在 Schema 资源（schema-${platform}.sql）里要使用的平台。（默认值： all 。） spring.datasource.pool-prepared-statements 是否要将 Statement 放在池里。 spring.datasource.propagate-interrupt-state 对于等待连接的中断线程，是否要传播中断状态。 spring.datasource.read-only 在使用 Hikari 连接池时将数据源设置为只读。 spring.datasource.register-mbeans Hikari 连接池是否要注册 JMX MBean。 spring.datasource.remove-abandoned 被弃用的连接在到达弃用超时后是否应该被移除。 spring.datasource.remove-abandoned-timeout 连接在多少秒后应该考虑弃用。 spring.datasource.rollback-on-return 在连接归还连接池时，是否要回滚挂起的事务。 spring.datasource.schema Schema（数据定义语言，Data Definition Language，DDL）脚本资源的引用。 spring.datasource.separator SQL 初始化脚本里的语句分割符。（默认值： ; 。） spring.datasource.sql-script-encoding SQL 脚本的编码。 spring.datasource.suspect-timeout 在记录一个疑似弃用连接前要等待多少秒。 spring.datasource.test-on-borrow 从连接池中借用连接时是否要进行测试。 spring.datasource.test-on-connect 在建立连接时是否要进行测试。 spring.datasource.test-on-return 在将连接归还到连接池时是否要进行测试。 spring.datasource.test-while-idle 在连接空闲时是否要进行测试。 spring.datasource.time-between-eviction-runs-millis 在两次空闲连接验证、弃用连接清理和空闲池大小调整之间睡眠的毫秒数。 spring.datasource.transaction-isolation 在使用 Hikari 连接池时设置默认事务隔离级别。 spring.datasource.use-disposable-connection-facade 连接是否要用一个门面（facade）封装起来，在调用了 Connection.close() 后就不能 再使用这个连接了。 spring.datasource.use-equals 在比较方法名时是否使用 String.equals() 来代替 == 。 spring.datasource.use-lock 在操作连接对象时是否要加锁。 spring.datasource.validation-interval 执行连接验证的间隔时间，单位为毫秒。 spring.datasource.validation-query 在连接池里的连接返回给调用者或连接池时，要执行的验证 SQL 查询。 spring.datasource.validation-query-timeout 在连接验证查询执行失败前等待的超时时间，单位为秒。 spring.datasource.validation-timeout 在连接验证失败前等待的超时时间，单位为秒。（用于 Hikari 连接池。） spring.datasource.validator-class-name 可选验证器类的全限定类名，用于执行测试查询。 spring.datasource.xa.data-source-class-name XA 数据源的全限定类名。 spring.datasource.xa.properties 要传递给 XA 数据源的属性。 FreeMarkerspring.freemarker.allow-request-override HttpServletRequest 的属性是否允许覆盖（隐藏）控制器生成的同名模型属性。 spring.freemarker.allow-session-override HttpSession 的属性是否允许覆盖（隐藏）控制器生成的同名模型属性。 spring.freemarker.cache 开启模板缓存。 spring.freemarker.charset 模板编码。 spring.freemarker.check-template-location 检查模板位置是否存在。 spring.freemarker.content-type Content-Type 的值。 spring.freemarker.enabled 开启 FreeMarker 的 MVC 视图解析。 spring.freemarker.expose-request-attributes 在模型合并到模板前，是否要把所有的请求属性添加到模型里。 spring.freemarker.expose-session-attributes 在模型合并到模板前，是否要把所有的 HttpSession 属性添加到模型里。 spring.freemarker.expose-spring-macro-helpers 是否发布供 Spring 宏程序库使用的 RequestContext ，并将命其名为 springMacro- RequestContext spring.freemarker.prefer-file-system-access 加载模板时优先通过文件系统访问。文件系统访问能够实时检测到模板变更。（默认值： true 。） spring.freemarker.prefix 在构建 URL 时添加到视图名称前的前缀。 spring.freemarker.request-context-attribute 在所有视图里使用的 RequestContext 属性的名称。 spring.freemarker.settings 要传递给 FreeMarker 配置的各种键。 spring.freemarker.suffix 在构建 URL 时添加到视图名称后的后缀。 spring.freemarker.template-loader-path 模板路径列表，用逗号分隔。（默认值： [“classpath:/templates/”] 。） spring.freemarker.view-names 可解析的视图名称的白名单。 Groovyspring.groovy.template.allow-request-override HttpServletRequest 的属性是否允许覆盖（隐藏）控制器生成的同名模型属性。 spring.groovy.template.allow-session-override HttpSession 的属性是否允许覆盖（隐藏）控制器生成的同名模型属性。 spring.groovy.template.cache 开启模板缓存。 spring.groovy.template.charset 模板编码。 spring.groovy.template.check-template-location 检查模板位置是否存在。 spring.groovy.template.configuration.auto-escape 模型变量在模板里呈现时是否要做转义。（默认值： false 。） spring.groovy.template.configuration.auto-indent 模板是否要自动呈现缩进。（默认值： false 。） spring.groovy.template.configuration.auto-indent-string 开启自动缩进时用于缩进的字符串，可以是 SPACES ，也可以是 TAB 。（默认值： SPACES 。） spring.groovy.template.configuration.auto-new-line 模板里是否要呈现新的空行。（默认值： false 。） spring.groovy.template.configuration.base-template-class 模板基类。 spring.groovy.template.configuration.cache-templates 模板是否应该缓存。（默认值： true 。） spring.groovy.template.configuration.declaration-encoding 用来写声明头的编码。 spring.groovy.template.configuration.expand-empty-elements 没有正文的元素该用短形式（例如， ）还是扩展形式（例如， ）来书 写。（默认值： false） spring.groovy.template.configuration.locale 设置模板地域。 spring.groovy.template.configuration.new-line-string 在自动空行开启后用来呈现空行的字符串。（默认为系统的 line.separator 属性值。） spring.groovy.template.configuration.resource-loader-path Groovy 模板的路径。（默认值： classpath:/templates/ 。） spring.groovy.template.configuration.use-double-quotes 属性是该用双引号还是单引号。（默认值： false 。） spring.groovy.template.content-type Content-Type 的值。 spring.groovy.template.enabled 开启 Groovy 模板的 MVC 视图解析。 spring.groovy.template.expose-request-attributes 在模型合并到模板前，是否要把所有的请求属性添加到模型里。 spring.groovy.template.expose-session-attributes 在模型合并到模板前，是否要把所有的 HttpSession 属性添加到模型里。 spring.groovy.template.expose-spring-macro-helpers 是否发布供 Spring 宏程序库使用的 RequestContext ，并将其命名为 springMacro- RequestContext spring.groovy.template.prefix 在构建 URL 时，添加到视图名称前的前缀。 spring.groovy.template.request-context-attribute 所有视图里使用的 RequestContext 属性的名称。 spring.groovy.template.resource-loader-path 模板路径（默认值： classpath:/ templates/ 。） spring.groovy.template.suffix 在构建 URL 时，添加到视图名称后的后缀。 spring.groovy.template.view-names 可解析的视图名称白名单。 H2spring.h2.console.enabled 开启控制台。（默认值： false 。） spring.h2.console.path 可以找到控制台的路径。（默认值： /h2-console 。） Hornetq spring.hornetq.embedded.cluster-password 集群密码。默认在启动时随机生成。 spring.hornetq.embedded.data-directory 日志文件目录。如果关闭了持久化功能则不需要该属性。 spring.hornetq.embedded.enabled 如果有 HornetQ 服务器 API，则开启嵌入模式。（默认值： true 。） spring.hornetq.embedded.persistent 开启持久化存储。（默认值： false 。） spring.hornetq.embedded.queues 启动时要创建的队列列表，用逗号分隔。（默认值： [] 。） spring.hornetq.embedded.server-id 服务器 ID。默认使用自增长计数器。（默认值： 0 。） spring.hornetq.embedded.topics 启动时要创建的主题列表，用逗号分隔。（默认值： [] 。） spring.hornetq.host HornetQ 的主机。（默认值： localhost 。） spring.hornetq.mode HornetQ 的部署模式，默认为自动检测。可以显式地设置为 native 或 embedded 。 spring.hornetq.port HornetQ 的端口。（默认值： 5445 。） Httpspring.http.converters.preferred-json-mapper HTTP 消息转换时优先使用 JSON 映射器。 spring.http.encoding.charset HTTP 请求和响应的字符集。如果没有显式地指定 Content-Type 头，则将该属性值作为 这个头的值。（默认值： UTF-8 。） spring.http.encoding.enabled 开启 HTTP 编码支持。（默认值： true 。） spring.http.encoding.force 强制将 HTTP 请求和响应编码为所配置的字符集。（默认值： true 。） Jacksonspring.jackson.date-format 日期格式字符串（yyyy-MM-dd HH:mm:ss）或日期格式类的全限定类名。 spring.jackson.deserialization 影响 Java 对象反序列化的 Jackson on/off 特性。 spring.jackson.generator 用于生成器的 Jackson on/off 特性。 spring.jackson.joda-date-time-format Joda 日期时间格式字符串（yyyy-MM-dd HH:mm:ss）。如果没有配置，而 date-format 又配置了一个格式字符串的话，会将它作为降级配置。 spring.jackson.locale 用于格式化的地域值。 spring.jackson.mapper Jackson 的通用 on/off 特性。 spring.jackson.parser 用于解析器的 Jackson on/off 特性。 spring.jackson.property-naming-strategy Jackson 的 PropertyNamingStrategy 中的一个常量（ CAMEL_CASE_TO_LOWERCASE WITH_UNDERSCORES ）。也可以设置 PropertyNamingStrategy 的子类的全限定类名。 spring.jackson.serialization 影响 Java 对象序列化的 Jackson on/off 特性。 spring.jackson.serialization-inclusion 控制序列化时要包含哪些属性。可选择 Jackson 的 JsonInclude.Include 枚举里的某个值。 spring.jackson.time-zone 格式化日期时使用的时区。可以配置各种可识别的时区标识符，比如 America/Los_ Angeles 或者 GMT+10 。 Jerseyspring.jersey.filter.order Jersey 过滤器链的顺序。（默认值： 0 。） spring.jersey.init 通过 Servlet 或过滤器传递给 Jersey 的初始化参数。 spring.jersey.type Jersey 集成类型。可以是 servlet 或者 filter 。 Jmsspring.jms.jndi-name 连接工厂的 JNDI 名字。设置了该属性，则优先于其他自动配置的连接工厂。 spring.jms.listener.acknowledge-mode 容器的应答模式（acknowledgment mode）。默认情况下，监听器使用自动应答。 spring.jms.listener.auto-startup 启动时自动启动容器。（默认值： true 。） spring.jms.listener.concurrency 并发消费者的数量下限。 spring.jms.listener.max-concurrency 并发消费者的数量上限。 spring.jms.pub-sub-domain 如果是主题而非队列，指明默认的目的地类型是否支持 Pub/Sub。（默认值： false 。） Jmxspring.jmx.default-domain JMX 域名。 spring.jmx.enabled 将管理 Bean 发布到 JMX 域里。（默认值： true 。） spring.jmx.server MBeanServer 的 Bean 名称。（默认值： mbeanServer 。） Jpaspring.jpa.database 要操作的目标数据库，默认自动检测。也可以通过 databasePlatform 属性进行设置。 spring.jpa.database-platform 要操作的目标数据库，默认自动检测。也可以通过 Database 枚举来设置。 spring.jpa.generate-ddl 启动时要初始化 Schema。（默认值： false 。） spring.jpa.hibernate.ddl-auto DDL 模式（ none 、 validate 、 update 、 create 和 create-drop ）。这是 hibernate. hbm2ddl.auto 属性的一个快捷方式。在使用嵌入式数据库时，默认为 create-drop , 其他情况下默认为 none 。 spring.jpa.hibernate.naming-strategy Hibernate 命名策略的全限定类名。 spring.jpa.open-in-view 注册 OpenEntityManagerInViewInterceptor ，在请求的整个处理过程中，将一个 JPA EntityManager 绑定到线程上。（默认值： true） spring.jpa.propertiesJPA 提供方要设置的额外原生属性。 spring.jpa.show-sql 在使用 Bitronix Transaction Manager 时打开 SQL 语句日志。（默认值： false 。） Jtaspring.jta.allow-multiple-lrc 在使用 Bitronix Transaction Manager 时，事务管理器是否应该允许一个事务涉及多个 LRC 资源。（默认值： false） spring.jta.asynchronous2-pc 在使用 Bitronix Transaction Manager 时，是否异步执行两阶段提交。（默认值： false 。） spring.jta.background-recovery-interval在使用 Bitronix Transaction Manager 时，多久运行一次恢复过程，单位为分钟。（默认值： 1 ） spring.jta.background-recovery-interval-seconds 在使用 Bitronix Transaction Manager 时，多久运行一次恢复过程，单位为秒。（默认值： 60 ） spring.jta.current-node-only-recovery 在使用 Bitronix Transaction Manager 时，恢复是否要滤除不包含本 JVM 唯一 ID 的 XID。（默认值： true ） spring.jta.debug-zero-resource-transaction 在使用 Bitronix Transaction Manager 时，对于没有涉及任何资源的事务，是否要跟踪并记 录它们的创建和提交调用栈。（默认值： false） spring.jta.default-transaction-timeout 在使用 Bitronix Transaction Manager 时，默认的事务超时时间，单位为秒。（默认值： 60 。） spring.jta.disable-jmx 在使用 Bitronix Transaction Manager 时，是否要禁止注册 JMX MBean。（默认值： false 。） spring.jta.enabled 开启 JTA 支持。（默认值： true 。） spring.jta.exception-analyzer 在使用 Bitronix Transaction Manager 时用到的异常分析器。设置为 null 时使用默认异常分析器，也可以设置自定义异常分析器的全限定类名。 spring.jta.filter-log-status 在使用 Bitronix Transaction Manager 时，是否只记录必要的日志。开启该参数时能减少分 段（fragment）空间用量，但调试更复杂了。（默认值： false） spring.jta.force-batching-enabled 在使用 Bitronix Transaction Manager 时，是否批量输出至磁盘。禁用批处理会严重降低事 务管理器的吞吐量。（默认值： true 。） spring.jta.forced-write-enabled 在使用 Bitronix Transaction Manager 时，日志是否强制写到磁盘上。在生产环境里不要设 置为 false ，因为不强制写到磁盘上无法保证完整性。（默认值： true） spring.jta.graceful-shutdown-interval 在使用 Bitronix Transaction Manager 时，要关闭的话，事务管理器在放弃事务前最多等它 多少秒。（默认值： 60） spring.jta.jndi-transaction-synchronization-registry-name 在使用 Bitronix Transaction Manager 时，事务同步注册表应该绑定到哪个 JNDI 下。（默认 值： java:comp/TransactionSynchronizationRegistry） spring.jta.jndi-user-transaction-name 在使用 Bitronix Transaction Manager 时，用户事务应该绑定到哪个 JNDI 下。（默认值： java:comp/UserTransaction 。） spring.jta.journal 在使用 Bitronix Transaction Manager 时，要用的日志名。可以是 disk 、 null 或者全限定类 名。（默认值： disk 。） spring.jta.log-dir 事务日志目录。 spring.jta.log-part1-filename 日志分段文件 1 的名称。（默认值： btm1.tlog 。） spring.jta.log-part2-filename 日志分段文件 2 的名称。（默认值： btm2.tlog 。） spring.jta.max-log-size-in-mb 在使用 Bitronix Transaction Manager 时，日志分段文件的最大兆数。日志越大，事务就被 允许在未终结状态停留越长时间。但是，如果文件大小限制得太小，事务管理器在分段 满了的时候就会暂停更长时间。（默认值： 2 。） spring.jta.resource-configuration-filename Bitronix Transaction Manager 的配置文件名。 spring.jta.server-id 唯一标识 Bitronix Transaction Manager 实例的 ID。 spring.jta.skip-corrupted-logs 是否跳过损坏的日志文件。（默认值： false 。） spring.jta.transaction-manager-id 事务管理器的唯一标识符。 spring.jta.warn-about-zero-resource-transaction 在使用 Bitronix Transaction Manager 时，是否要对执行时没有涉及任何资源的事务作出告 警。（默认值： true 。） Mailspring.mail.default-encoding 默认的 MimeMessage 编码。（默认值： UTF-8 。） spring.mail.host SMTP 服务器主机地址。 spring.mail.jndi-name会话的 JNDI 名称。设置之后，该属性的优先级要高于其他邮件设置。 spring.mail.password SMTP 服务器的登录密码。 spring.mail.port SMTP 服务器的端口号。 spring.mail.properties 附加的 JavaMail 会话属性。 spring.mail.protocol SMTP 服务器用到的协议。（默认值： smtp 。） spring.mail.test-connection 在启动时测试邮件服务器是否可用。（默认值： false 。） spring.mail.username SMTP 服务器的登录用户名。 Messagesspring.messages.basename 逗号分隔的基本名称列表，都遵循 ResourceBundle 的惯例。本质上这就是一个全限定 的 Classpath 位置，如果不包含包限定符（比如 org.mypackage ），就会从 Classpath 的根部开始解析。（默认值： messages 。） spring.messages.cache-seconds 加载的资源包文件的缓存失效时间，单位为秒。在设置为 -1 时，包会永远缓存。（默认值： -1 。） spring.messages.encoding消息包的编码。（默认值： UTF-8 。） Mobilespring.mobile.devicedelegatingviewresolver.enable-fallback 开启降级解析支持。（默认值： false 。） spring.mobile.devicedelegatingviewresolver.enabled 开启设备视图解析器。（默认值： false 。） spring.mobile.devicedelegatingviewresolver.mobile-prefix 添加到移动设备视图名前的前缀。（默认值： mobile/ 。） spring.mobile.devicedelegatingviewresolver.mobile-suffix 添加到移动设备视图名后的后缀。 spring.mobile.devicedelegatingviewresolver.normal-prefix 添加到普通设备视图名前的前缀。 spring.mobile.devicedelegatingviewresolver.normal-suffix 添加到普通设备视图名后的后缀。 spring.mobile.devicedelegatingviewresolver.tablet-prefix添加到平板设备视图名前的前缀。（默认值： tablet/ 。） spring.mobile.devicedelegatingviewresolver.tablet-suffix 添加到平板设备视图名后的后缀。 spring.mobile.sitepreference.enabled 开启 SitePreferenceHandler 。（默认值： true 。） Mongodbspring.mongodb.embedded.features要开启的特性列表，用逗号分隔。 spring.mongodb.embedded.version 要使用的 Mongo 版本。（默认值： 2.6.10 。） Mustachespring.mustache.cache 开启模板缓存。 spring.mustache.charset 模板编码。 spring.mustache.check-template-location 检查模板位置是否存在。 spring.mustache.content-type Content-Type 的值。 spring.mustache.enabled 开启 Mustache 的 MVC 视图解析。 spring.mustache.prefix添加到模板名前的前缀。（默认值： classpath:/ templates/ 。） spring.mustache.suffix 添加到模板名后的后缀。（默认值： .html 。） spring.mustache.view-names 可解析的视图名称的白名单。 Mvcspring.mvc.async.request-timeout 异步请求处理超时前的等待时间（单位为毫秒）。如果没有设置该属性，则使用底层实现 的默认超时时间，比如，Tomcat 上使用 Servlet 3 时超时时间为 10 秒。 spring.mvc.date-format 要使用的日期格式（比如 dd/MM/yyyy ）。 spring.mvc.favicon.enabled 开启 favicon.ico 的解析。（默认值： true 。） spring.mvc.ignore-default-model-on-redirect 在重定向的场景下，是否要忽略“默认”模型对象的内容。（默认值： true 。） spring.mvc.locale 要使用的地域配置。 spring.mvc.message-codes-resolver-format 消息代码格式（ PREFIX_ERROR_CODE 、 POSTFIX_ERROR_CODE ）。 spring.mvc.view.prefix Spring MVC 视图前缀。 spring.mvc.view.suffix Spring MVC 视图后缀。 Mybatismybatis.mapper-locations mybatis 映射文件位置。mybatis.type-aliases-package 别名包位置。 Rabbitmqspring.rabbitmq.addresses 客户端应该连接的地址列表，用逗号分隔。 spring.rabbitmq.dynamic 创建一个 AmqpAdmin Bean。（默认值： true 。） spring.rabbitmq.host RabbitMQ 主机地址。（默认值： localhost 。） spring.rabbitmq.listener.acknowledge-mode 容器的应答模式。 spring.rabbitmq.listener.auto-startup 启动时自动开启容器。（默认值： true 。） spring.rabbitmq.listener.concurrency 消费者的数量下限。 spring.rabbitmq.listener.max-concurrency 消费者的数量上限。 spring.rabbitmq.listener.prefetch 单个请求里要处理的消息数。该数值不应小于事务数（如果用到的话）。 spring.rabbitmq.listener.transaction-size 一个事务里要处理的消息数。为了保证效果，应该不大于预先获取的数量。 spring.rabbitmq.password进行身份验证的密码。 spring.rabbitmq.port RabbitMQ 端口。（默认值： 5672 。） spring.rabbitmq.requested-heartbeat 请求心跳超时，单位为秒； 0 表示不启用心跳。 spring.rabbitmq.ssl.enabled 开启 SSL 支持。（默认值： false 。） spring.rabbitmq.ssl.key-store 持有 SSL 证书的 KeyStore 路径。 spring.rabbitmq.ssl.key-store-password 访问 KeyStore 的密码。 spring.rabbitmq.ssl.trust-store 持有 SSL 证书的 TrustStore。 spring.rabbitmq.ssl.trust-store-password 访问 TrustStore 的密码。 spring.rabbitmq.username 进行身份验证的用户名。 spring.rabbitmq.virtual-host 在连接 RabbitMQ 时的虚拟主机。 Redisspring.redis.database 连接工厂使用的数据库索引。（默认值： 0 。） spring.redis.host Redis 服务器主机地址。（默认值： localhost 。） spring.redis.passwordRedis 服务器的登录密码。 spring.redis.pool.max-active连接池在指定时间里能分配的最大连接数。负数表示无限制。（默认值： 8 。） spring.redis.pool.max-idle 连接池里的最大空闲连接数。负数表示空闲连接数可以是无限大。（默认值： 8 。） spring.redis.pool.max-wait当连接池被耗尽时，分配连接的请求应该在抛出异常前被阻塞多长时间（单位为秒）。负 数表示一直阻塞。（默认值： -1 。） spring.redis.pool.min-idle 连接池里要维持的最小空闲连接数。该属性只有在设置为正数时才有效。（默认值： 0 。） spring.redis.port Redis 服务器端口。（默认值： 6379 。） spring.redis.sentinel.master Redis 服务器的名字。 spring.redis.sentinel.nodes形如“主机: 端口”配对的列表，用逗号分隔。 spring.redis.timeout 连接超时时间，单位为秒。（默认值： 0 。） Resourcesspring.resources.add-mappings 开启默认资源处理。（默认值： true 。） spring.resources.cache-period 资源处理器对资源的缓存周期，单位为秒。 spring.resources.chain.cache 对资源链开启缓存。（默认值： true 。） spring.resources.chain.enabled 开启 Spring 资源处理链。（默认关闭的，除非至少开启了一个策略。） spring.resources.chain.html-application-cache 开启 HTML5 应用程序缓存证明重写。（默认值： false 。） spring.resources.chain.strategy.content.enabled 开启内容版本策略。（默认值： false 。） spring.resources.chain.strategy.content.paths 要运用于版本策略的模式列表，用逗号分隔。（默认值： [/**] 。） spring.resources.chain.strategy.fixed.enabled开启固定版本策略。（默认值： false 。） spring.resources.chain.strategy.fixed.paths要运用于固定版本策略的模式列表，用逗号分隔。 spring.resources.chain.strategy.fixed.version 用于固定版本策略的版本字符串。 spring.resources.static-locations 静态资源位置。默认为 classpath: [/META-INF/resources/, /resources/, /static/, /public/] 加上 context:/（Servlet 上下文的根目录）。 SendGridspring.sendgrid.password SendGrid 密码。 spring.sendgrid.proxy.host SendGrid 代理主机地址。 spring.sendgrid.proxy.port SendGrid 代理端口。 spring.sendgrid.username SendGrid 用户名。 Socialspring.social.auto-connection-views 针对所支持的提供方开启连接状态视图。（默认值： false 。） spring.social.facebook.app-id 应用程序 ID。 spring.social.facebook.app-secret 应用程序的密钥。 spring.social.linkedin.app-id 应用程序 ID。 spring.social.linkedin.app-secret 应用程序的密钥。 spring.social.twitter.app-id 应用程序 ID。 spring.social.twitter.app-secret 应用程序的密钥。 Thymeleafspring.thymeleaf.cache开启模板缓存。（默认值： true 。） spring.thymeleaf.check-template-location 检查模板位置是否存在。（默认值： true 。） spring.thymeleaf.content-type Content-Type 的值。（默认值： text/html 。） spring.thymeleaf.enabled 开启 MVC Thymeleaf 视图解析。（默认值： true 。） spring.thymeleaf.encoding模板编码。（默认值： UTF-8 。） spring.thymeleaf.excluded-view-names 要被排除在解析之外的视图名称列表，用逗号分隔。 spring.thymeleaf.mode 要运用于模板之上的模板模式。另见 StandardTemplate- ModeHandlers 。（默认值： HTML5 。） spring.thymeleaf.prefix 在构建 URL 时添加到视图名称前的前缀。（默认值： classpath:/templates/ 。） spring.thymeleaf.suffix 在构建 URL 时添加到视图名称后的后缀。（默认值： .html 。） spring.thymeleaf.template-resolver-order Thymeleaf 模板解析器在解析器链中的顺序。默认情况下，它排在第一位。顺序从 1 开始只有在定义了额外的 TemplateResolver Bean 时才需要设置这个属性。 spring.thymeleaf.view-names 可解析的视图名称列表，用逗号分隔。 Velocityspring.velocity.allow-request-override HttpServletRequest 的属性是否允许覆盖（隐藏）控制器生成的同名模型属性。 spring.velocity.allow-session-override HttpSession` 的属性是否允许覆盖（隐藏）控制器生成的同名模型属性。 spring.velocity.cache 开启模板缓存。 spring.velocity.charset 模板编码。 spring.velocity.check-template-location 检查模板位置是否存在。 spring.velocity.content-type Content-Type 的值。 spring.velocity.date-tool-attribute DateTool 辅助对象在视图的 Velocity 上下文里呈现的名字。 spring.velocity.enabled 开启 Velocity 的 MVC 视图解析。 spring.velocity.expose-request-attributes 在模型合并到模板前，是否要把所有的请求属性添加到模型里。 spring.velocity.expose-session-attributes 在模型合并到模板前，是否要把所有的 HttpSession 属性添加到模型里。 spring.velocity.expose-spring-macro-helpers 是否发布供 Spring 宏程序库使用的 RequestContext ，并将其名命为 springMacro- RequestContext 。 spring.velocity.number-tool-attribute NumberTool 辅助对象在视图的 Velocity 上下文里呈现的名字。 spring.velocity.prefer-file-system-access 加载模板时优先通过文件系统访问。文件系统访问能够实时检测到模板变更。（默认值： true 。） spring.velocity.prefix在构建 URL 时添加到视图名称前的前缀。 spring.velocity.properties 额外的 Velocity 属性。 spring.velocity.request-context-attribute所有视图里使用的 Request- Context 属性的名称。 spring.velocity.resource-loader-path 模板路径。（默认值： classpath:/ templates/ 。） spring.velocity.suffix 在构建 URL 时添加到视图名称后的后缀。 spring.velocity.toolbox-config-location Velocity Toolbox 的配置位置，比如 /WEB-INF/toolbox.xml。自动加载 Velocity Tools 工具定 义文件，将所定义的全部工具发布到指定的作用域内。 spring.velocity.view-names可解析的视图名称白名单。 Viewspring.view.prefix Spring MVC 视图前缀。 spring.view.suffixSpring MVC 视图后缀。 其它spring.aop.auto 添加 @EnableAspectJAutoProxy(默认：true) spring.application.admin.enabled开启应用程序的管理功能 (默认：false) spring.artemis.embedded.cluster-password 集群密码。默认在启东市随机生成 spring.artemis.embedded.persistent开启持久化存储 (默认：false) spring.autoconfigure.exclude 要排除的自动配置类 END","updated":"2020-07-23T07:19:23.027Z","categories":[{"name":"JavaWeb","slug":"JavaWeb","permalink":"http://yoursite.com/categories/JavaWeb/"},{"name":"Springboot","slug":"JavaWeb/Springboot","permalink":"http://yoursite.com/categories/JavaWeb/Springboot/"}],"tags":[{"name":"JavaWeb","slug":"JavaWeb","permalink":"http://yoursite.com/tags/JavaWeb/"},{"name":"Springboot","slug":"Springboot","permalink":"http://yoursite.com/tags/Springboot/"},{"name":"application","slug":"application","permalink":"http://yoursite.com/tags/application/"}]},{"title":"SpringBoot项目打包为jar包","date":"2020-07-22T11:18:02.000Z","path":"2020/07/22/SpringBoot项目打包为jar包/","text":"Hello World! My Environment IDEA2018.3 JDK1.8 SpringBoot2.3.0 360浏览器项目部署一般是两种方式：一种是打包成 jar 包直接执行，另一种是打包成 war 包放到 Tomcat 服务器下，SpringBoot一般情况下默认为jar包方式。pom.xml：&lt; packaging&gt;jar&lt; /packaging&gt; （默认）&lt; packaging&gt;war&lt; /packaging&gt; 打jar包选择 File -&gt; Project Structure-&gt;Artifacts-&gt;Jar-&gt;Form modules with dependencies后点ok:根据 下图内容创建 jar。如图所示，选择项目，入口类等。最后一项 META-INF，默认放到 src\\main\\java 目录里，如果使用默认值，没有进行其他配置，生成的 jar 有可能不会包含 META-INF 目录，导致运行 jar 出错。最好放在 src\\main\\resource目录中。点击ok保存。按下图所示配置：点击ok会出现如图所示信息:生成jar包点击idea菜单栏中的build，依次选择：点Build:在保存路经中查找所打包的jar包如果存在则说明打包成功。运行jar包开始运行jar包，打开cmd进入jar所在的路径，输入java -jar xxx.jar (jar名称) ，点击回车按键。 1234567891011121314151617181920212223242526272829303132333435363738Microsoft Windows [版本 10.0.18362.959](c) 2019 Microsoft Corporation。保留所有权利。C:\\Users\\92895&gt;D:D:\\&gt;cd D:\\data_view\\out\\artifacts\\data_view_jarD:\\data_view\\out\\artifacts\\data_view_jar&gt;Java -jar data_view_jarError: Unable to access jarfile data_view_jarD:\\data_view\\out\\artifacts\\data_view_jar&gt;java -jar data_view_jarError: Unable to access jarfile data_view_jarD:\\data_view\\out\\artifacts\\data_view_jar&gt;java -jar data_view.jar_________ ____.__ __\\_ ___ \\ | / \\ / \\/ \\ \\/ | \\ \\/\\/ /\\ \\____/\\__| |\\ / \\______ /\\________| \\__/\\ / \\/ \\/2020-07-20 09:51:27.016 INFO 12564 --- [ restartedMain] com.dvms.DataViewApplication : Starting DataViewApplication on 4C501 with PID 12564 (D:\\data_view\\out\\artifacts\\data_view_jar\\data_view.jar started by 92895 in D:\\data_view\\out\\artifacts\\data_view_jar)2020-07-20 09:51:27.020 INFO 12564 --- [ restartedMain] com.dvms.DataViewApplication : No active profile set, falling back to default profiles: default2020-07-20 09:51:27.068 INFO 12564 --- [ restartedMain] .e.DevToolsPropertyDefaultsPostProcessor : Devtools property defaults active! Set 'spring.devtools.add-properties' to 'false' to disable2020-07-20 09:51:27.068 INFO 12564 --- [ restartedMain] .e.DevToolsPropertyDefaultsPostProcessor : For additional web related logging consider setting the 'logging.level.web' property to 'DEBUG'2020-07-20 09:51:28.817 INFO 12564 --- [ restartedMain] o.s.b.w.embedded.tomcat.TomcatWebServer : Tomcat initialized with port(s): 8080 (http)2020-07-20 09:51:28.831 INFO 12564 --- [ restartedMain] o.apache.catalina.core.StandardService : Starting service [Tomcat]2020-07-20 09:51:28.832 INFO 12564 --- [ restartedMain] org.apache.catalina.core.StandardEngine : Starting Servlet engine: [Apache Tomcat/9.0.35]2020-07-20 09:51:28.896 INFO 12564 --- [ restartedMain] o.a.c.c.C.[Tomcat].[localhost].[/] : Initializing Spring embedded WebApplicationContext2020-07-20 09:51:28.896 INFO 12564 --- [ restartedMain] o.s.web.context.ContextLoader : Root WebApplicationContext: initialization completed in 1827 ms2020-07-20 09:51:29.631 INFO 12564 --- [ restartedMain] o.s.s.web.DefaultSecurityFilterChain : Creating filter chain: any request, [org.springframework.security.web.context.request.async.WebAsyncManagerIntegrationFilter@56cf4f3a, org.springframework.security.web.context.SecurityContextPersistenceFilter@45e169c9, org.springframework.security.web.header.HeaderWriterFilter@26d4eefe, org.springframework.security.web.authentication.logout.LogoutFilter@f17fdd6, org.springframework.security.web.authentication.UsernamePasswordAuthenticationFilter@5f33f6b3, org.springframework.security.web.authentication.ui.DefaultLoginPageGeneratingFilter@70ffa278, org.springframework.security.web.authentication.ui.DefaultLogoutPageGeneratingFilter@109a14b8, org.springframework.security.web.savedrequest.RequestCacheAwareFilter@54857a49, org.springframework.security.web.servletapi.SecurityContextHolderAwareRequestFilter@423bad4c, org.springframework.security.web.authentication.rememberme.RememberMeAuthenticationFilter@7e8ca12a, org.springframework.security.web.authentication.AnonymousAuthenticationFilter@3ee5e690, org.springframework.security.web.session.SessionManagementFilter@7139411a, org.springframework.security.web.access.ExceptionTranslationFilter@1ec9ee0a, org.springframework.security.web.access.intercept.FilterSecurityInterceptor@bf4c490]2020-07-20 09:51:29.711 INFO 12564 --- [ restartedMain] o.s.s.concurrent.ThreadPoolTaskExecutor : Initializing ExecutorService 'applicationTaskExecutor'2020-07-20 09:51:29.929 INFO 12564 --- [ restartedMain] o.s.b.d.a.OptionalLiveReloadServer : LiveReload server is running on port 357292020-07-20 09:51:29.967 INFO 12564 --- [ restartedMain] o.s.b.w.embedded.tomcat.TomcatWebServer : Tomcat started on port(s): 8080 (http) with context path ''2020-07-20 09:51:29.976 INFO 12564 --- [ restartedMain] com.dvms.DataViewApplication : Started DataViewApplication in 3.27 seconds (JVM running for 3.828)2020-07-20 09:51:44.774 INFO 12564 --- [nio-8080-exec-1] o.a.c.c.C.[Tomcat].[localhost].[/] : Initializing Spring DispatcherServlet 'dispatcherServlet'2020-07-20 09:51:44.775 INFO 12564 --- [nio-8080-exec-1] o.s.web.servlet.DispatcherServlet : Initializing Servlet 'dispatcherServlet'2020-07-20 09:51:44.782 INFO 12564 --- [nio-8080-exec-1] o.s.web.servlet.DispatcherServlet : Completed initialization in 5 ms2020-07-20 09:51:56.052 INFO 12564 --- [nio-8080-exec-5] com.alibaba.druid.pool.DruidDataSource : &#123;dataSource-1&#125; init 浏览器输入：localhost8080:/index（根据实际项目）显示网页说明打包成功！！！","updated":"2020-07-23T07:22:18.859Z","categories":[{"name":"SpringBoot","slug":"SpringBoot","permalink":"http://yoursite.com/categories/SpringBoot/"}],"tags":[{"name":"jar包","slug":"jar包","permalink":"http://yoursite.com/tags/jar%E5%8C%85/"}]},{"title":"jar包和war包区别及理解","date":"2020-07-22T11:17:33.000Z","path":"2020/07/22/jar包和war包区别及理解/","text":"Hello World! 在开发阶段不适合使用war包，因为在开发阶段，经常需要添加或删除Web应用程序的内容，更新 Servlet类文件，而每一次改动后，重新建立war包将是一件浪费时间的事情。在产品发布阶段，使用war文件比较合适的，因为在这个时候，几乎不需要再做什么改动了。 jar包jar是类的归档文件JAR（Java Archive，Java 归档文件）是与平台无关的文件格式，它允许将许多文件组合成一个压缩文件，为 J2EE 应用程序创建的jar文件是 EAR 文件（企业 jar文件），jar文件格式以流行的 ZIP 文件格式为基础。与 ZIP 文件不同的是，jar文件不仅用于压缩和发布，而且还用于部署和封装库、组件和插件程序，并可被像编译器和 JVM 这样的工具直接使用。在 jar中包含特殊的文件，如 manifests 和部署描述符，用来指示工具如何处理特定的 jar。通常是开发时要引用通用类，打成jar包便于存放管理，当你使用某些功能时就需要这些jar包的支持，需要导入jar包。jar包就是java的类进行编译生成的class文件打包的压缩包，包里面就是一些class文件。当我们自己使用Maven写一些java程序，进行打包生成jar包。同时在可以在其他的工程下使用，但是我们在这个工程依赖的jar包，在其他工程使用该JAR包也要导入。 war包war包是一个Web应用程序一个web程序进行打包便于部署的压缩包，里面包含我们web程序需要的一些东西，其中包括web.xml的配置文件，前端的页面文件，以及依赖的jar。便于我们部署工程，直接放到tomcat的webapps目录下，直接启动tomcat即可。同时，可以使用WinRAR查看war包，直接将后缀.war改成.rar。 Web存档(war)文件包含Web应用程序的所有内容。它减少了传输文件所需要的时间。 jar包和war包区别jar是java普通项目打包，通常是开发时要引用通用类，打成jar包便于存放管理。当你使用某些功能时就需要这些jar包的支持，需要导入jar包。war是java web项目打包，web网站完成后，打成war包部署到服务器，目的是为了节省资源，提供效率。 jar文件（扩展名为. Jar，Java Application Archive）包含Java类的普通库、资源（resources）、辅助文件（auxiliary files）等。通常是开发时要引用的通用类，打成包便于存放管理。简单来说，jar包就是别人已经写好的一些类，然后对这些类进行打包。可以将这些jar包引入到你的项目中，可以直接使用这些jar包中的类和属性，这些jar包一般放在lib目录下。 war文件（扩展名为.War,Web Application Archive）包含全部Web应用程序。在这种情形下，一个Web应用程序被定义为单独的一组文件、类和资源，用户可以对jar文件进行封装，并把它作为小型服务程序（servlet）来访问。 war包是一个可以直接运行的web模块，通常用于网站，打成包部署到容器中。以Tomcat来说，将war包放置在其\\webapps\\目录下,然后启动Tomcat，这个包就会自动解压，就相当于发布了。war包是Sun提出的一种web应用程序格式，与jar类似，是很多文件的压缩包。war包中的文件按照一定目录结构来组织。根据其根目录下包含有html和jsp文件，或者包含有这两种文件的目录，另外还有WEB-INF目录。通常在WEB-INF目录下含有一个web.xml文件和一个classes目录，web.xml是这个应用的配置文件，而classes目录下则包含编译好的servlet类和jsp，或者servlet所依赖的其他类（如JavaBean）。通常这些所依赖的类也可以打包成jar包放在WEB-INF下的lib目录下。 Ear文件（扩展名为.Ear,Enterprise Application Archive）包含全部企业应用程序。在这种情形下，一个企业应用程序被定义为多个jar文件、资源、类和Web应用程序的集合。 SpringBoot项目既可以打成war包发布，也可以找成jar包发布。jar包：直接通过内置Tomcat运行，不需要额外安装Tomcat。如需修改内置Tomcat的配置，只需要在SpringBoot的配置文件中配置。内置Tomcat没有自己的日志输出，全靠jar包应用输出日志。但是比较方便，快速，比较简单。war包：传统的应用交付方式，需要安装Tomcat，然后放到wabapps目录下运行war包，可以==灵活选择Tomcat版本==，可以直接修改Tomcat的配置，有自己的Tomcat日志输出，可以灵活配置安全策略,相对打成jar包来说没那么快速方便。 END","updated":"2020-07-23T07:18:55.904Z","categories":[{"name":"JavaWeb","slug":"JavaWeb","permalink":"http://yoursite.com/categories/JavaWeb/"}],"tags":[{"name":"SpringBoot","slug":"SpringBoot","permalink":"http://yoursite.com/tags/SpringBoot/"},{"name":"jar包","slug":"jar包","permalink":"http://yoursite.com/tags/jar%E5%8C%85/"}]},{"title":"MANIFEST.MF文件属性总结理解","date":"2020-07-22T11:15:57.000Z","path":"2020/07/22/MANIFEST-MF文件属性总结理解/","text":"Hello World! MANIFEST.MF定义了与扩展和包相关的数据；打开Java的JAR文件我们经常可以看到文件中包含着一个META-INF目录， 这个目录下会有一些文件，其中必有一个MANIFEST.MF，这个文件描述了该Jar文件的很多信息。 MANIFEST.MF文件属性 一. 一般属性 Manifest-Version用来定义manifest文件的版本，例如：Manifest-Version: 1.0 Created-By声明该文件的生成者，一般该属性是由jar命令行工具生成的，例如：Created-By: Apache Ant 1.5.1 Signature-Version定义jar文件的签名版本 Class-Path应用程序或者类装载器使用该值来构建内部的类搜索路径 二. 应用程序相关属性 Main-Class定义jar文件的入口类，该类必须是一个可执行的类，一旦定义了该属性即可通过 java -jar x.jar来运行该jar文件。 三. 小程序(Applet)相关属性 Extendsion-List该属性指定了小程序需要的扩展信息列表，列表中的每个名字对应以下的属性 -Extension-Name -Specification-Version -Implementation-Version -Implementation-Vendor-Id -Implementation-URL 四. 扩展标识属性 Extension-Name该属性定义了jar文件的标识，例如Extension-Name: Struts Framework 五. 包扩展属性 Implementation-Title 定义了扩展实现的标题 Implementation-Version 定义扩展实现的版本 Implementation-Vendor 定义扩展实现的组织 Implementation-Vendor-Id 定义扩展实现的组织的标识 Implementation-URL : 定义该扩展包的下载地址(URL) Specification-Title 定义扩展规范的标题 Specification-Version 定义扩展规范的版本 Specification-Vendor 声明了维护该规范的组织 Sealed 定义jar文件是否封存，值可以是true或者false (这点我还不是很理解) 六. 签名相关属性 签名方面的属性我们可以来参照JavaMail所提供的mail.jar中的一段 Name: javax/mail/Address.classDigest-Algorithms: SHA MD5SHA-Digest: AjR7RqnN//cdYGouxbd06mSVfI4=MD5-Digest: ZnTIQ2aQAtSNIOWXI1pQpw== 这段内容定义类签名的类名、计算摘要的算法名以及对应的摘要内容(使用BASE方法进行编码) 七.自定义属性 除了前面提到的一些属性外，你也可以在MANIFEST.MF中增加自己的属性以及响应的值，例如J2ME程序jar包中就可能包含着如下信息 MicroEdition-Configuration: CLDC-1.0MIDlet-Name: J2ME_MOBBER Midlet SuiteMIDlet-Info-URL: http://www.javayou.comMIDlet-Icon: /icon.pngMIDlet-Vendor: Midlet Suite VendorMIDlet-1: mobber,/icon.png,mobberMIDlet-Version: 1.0.0MicroEdition-Profile: MIDP-1.0MIDlet-Description: Communicator其他可参考：MANIFEST.MF文件详解 END","updated":"2020-07-23T07:18:56.004Z","categories":[{"name":"JavaWeb","slug":"JavaWeb","permalink":"http://yoursite.com/categories/JavaWeb/"},{"name":"SpringBoot","slug":"JavaWeb/SpringBoot","permalink":"http://yoursite.com/categories/JavaWeb/SpringBoot/"}],"tags":[{"name":"MANIFEST.MF","slug":"MANIFEST-MF","permalink":"http://yoursite.com/tags/MANIFEST-MF/"}]},{"title":"Maven仓库安装配置教程(windows)","date":"2020-07-21T11:42:28.000Z","path":"2020/07/21/Maven仓库安装配置教程-windows/","text":"Hello World! 1. 安装本地Maven点此进入maven官网下载 2.配置环境变量系统变量:MAVEN_HOME = D:\\apache-maven-3.6.1系统变量:path = %MAVEN_HOME%\\bin 3. 验证安装然后win+R 运行cmd 输入 mvn -version，如图所示则配置成功！！！ 4. 配置settings文件在D:\\apache-maven-3.6.1\\conf下可以找到settings文件找到第52行，这里是maven默认的仓库，复制第53行/path/to/local/repo将它拿到注释外并将中间的内容改成你需要的路径:(不改也行) 1&lt;localRepository&gt;D:/repository&lt;/localRepository&gt; 这里的路径随便设置，注意这里是正斜杠因为国外的服务器下载jar包很慢所以我们改为阿里云服务器（大约在150行左右），这两个仓库只用选一个(根据大家反馈建议使用第一个，第二个在有的版本可能会出现warning) alimaven central aliyun maven http://maven.aliyun.com/nexus/content/repositories/central/ 或者 nexus-aliyun * Nexus aliyun http://maven.aliyun.com/nexus/content/groups/public 在最后配置jdk，也要夹在两个profiles标签之间（不改也没事） jdk-1.8 true 1.8 &lt;properties&gt; &lt;maven.compiler.source&gt;1.8&lt;/maven.compiler.source&gt; &lt;maven.compiler.target&gt;1.8&lt;/maven.compiler.target&gt; &lt;maven.compiler.compilerVersion&gt;1.8&lt;/maven.compiler.compilerVersion&gt; &lt;/properties&gt; 配置完成，在命令行输入mvn help:system测试，看到下载链接里面是ailiyun的链接表示配置成功： END","updated":"2020-07-23T07:22:25.946Z","categories":[{"name":"JavaWeb","slug":"JavaWeb","permalink":"http://yoursite.com/categories/JavaWeb/"},{"name":"SpringBoot","slug":"JavaWeb/SpringBoot","permalink":"http://yoursite.com/categories/JavaWeb/SpringBoot/"}],"tags":[{"name":"Maven","slug":"Maven","permalink":"http://yoursite.com/tags/Maven/"}]},{"title":"SpringBoot整合Mybatis","date":"2020-07-21T11:20:32.000Z","path":"2020/07/21/SpringBoot整合Mybatis/","text":"Hello World! My Environment IDEA2018.3 JDK1.8 SpringBoot2.3.0 360浏览器整合过程 新建一个Spring Initializr项目 创建项目的文件结构以及jdk的版本 选择项目所需要的依赖 修改项目名，点击完成 选择自动导入依赖pom,xml文件 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081&lt;?xml version=\"1.0\" encoding=\"UTF-8\"?&gt;&lt;project xmlns=\"http://maven.apache.org/POM/4.0.0\" xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\" xsi:schemaLocation=\"http://maven.apache.org/POM/4.0.0 https://maven.apache.org/xsd/maven-4.0.0.xsd\"&gt; &lt;modelVersion&gt;4.0.0&lt;/modelVersion&gt; &lt;parent&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-parent&lt;/artifactId&gt; &lt;version&gt;2.3.1.RELEASE&lt;/version&gt; &lt;relativePath/&gt; &lt;!-- lookup parent from repository --&gt; &lt;/parent&gt; &lt;groupId&gt;com.cjw&lt;/groupId&gt; &lt;artifactId&gt;demo&lt;/artifactId&gt; &lt;version&gt;0.0.1-SNAPSHOT&lt;/version&gt; &lt;name&gt;demo&lt;/name&gt; &lt;description&gt;Demo project for Spring Boot&lt;/description&gt; &lt;properties&gt; &lt;java.version&gt;1.8&lt;/java.version&gt; &lt;/properties&gt; &lt;dependencies&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-jdbc&lt;/artifactId&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-security&lt;/artifactId&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-thymeleaf&lt;/artifactId&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-web&lt;/artifactId&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.mybatis.spring.boot&lt;/groupId&gt; &lt;artifactId&gt;mybatis-spring-boot-starter&lt;/artifactId&gt; &lt;version&gt;2.1.3&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;mysql&lt;/groupId&gt; &lt;artifactId&gt;mysql-connector-java&lt;/artifactId&gt; &lt;scope&gt;runtime&lt;/scope&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.projectlombok&lt;/groupId&gt; &lt;artifactId&gt;lombok&lt;/artifactId&gt; &lt;optional&gt;true&lt;/optional&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-test&lt;/artifactId&gt; &lt;scope&gt;test&lt;/scope&gt; &lt;exclusions&gt; &lt;exclusion&gt; &lt;groupId&gt;org.junit.vintage&lt;/groupId&gt; &lt;artifactId&gt;junit-vintage-engine&lt;/artifactId&gt; &lt;/exclusion&gt; &lt;/exclusions&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.security&lt;/groupId&gt; &lt;artifactId&gt;spring-security-test&lt;/artifactId&gt; &lt;scope&gt;test&lt;/scope&gt; &lt;/dependency&gt; &lt;/dependencies&gt; &lt;build&gt; &lt;plugins&gt; &lt;plugin&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-maven-plugin&lt;/artifactId&gt; &lt;/plugin&gt; &lt;/plugins&gt; &lt;/build&gt;&lt;/project&gt; 6.修改配置文件 12345678910111213#server.port=8080#server.servlet.context-path=/index #访问路径设置spring.datasource.url = jdbc:mysql://localhost:3306/ems?characterEncoding=UTF-8&amp;useSSL=true&amp;serverTimezone=UTCspring.datasource.username = rootspring.datasource.password = 123456spring.datasource.driverClassName = com.mysql.cj.jdbc.Driverspring.datasource.type = com.alibaba.druid.pool.DruidDataSourcemybatis.mapper-locations = classpath:mapper/*.xmlmybatis.type-aliases-package = com.dvms.entityspring.resources.static-locations = classpath:/templates/,classpath:/static/ 这里使用application.properties文件，也可以使用更加简洁的application.yml文件，须要将resource文件夹下原有的application.properties文件删除，染回创建application.yml配置文件（备注：其实SpringBoot底层会把application.yml文件解析为application.properties）7.实现业务流程创建包controller、entity、mapper、service。resources下创建mapper文件夹，用于写sql语句，也可以用注解的方式直接写在mapper文件里。最终框架结构:完成以上，下面在启动类里加上注解用于给出需要扫描的dao文件路径@MapperScan(“com.dvms.dao”) //扫描dao接口,mybatis扫描路径，针对的是接口Mapper类最后启动，浏览器输入地址：http://localhost:8080/index(根据实际项目)显示出对应界面即可。END","updated":"2020-07-23T07:22:07.786Z","categories":[{"name":"SpringBoot","slug":"SpringBoot","permalink":"http://yoursite.com/categories/SpringBoot/"},{"name":"JavaWeb","slug":"SpringBoot/JavaWeb","permalink":"http://yoursite.com/categories/SpringBoot/JavaWeb/"}],"tags":[{"name":"Mybatis","slug":"Mybatis","permalink":"http://yoursite.com/tags/Mybatis/"}]},{"title":"SSM框架下各层的解释说明（Controller等）","date":"2020-07-21T11:04:12.000Z","path":"2020/07/21/SSM框架下各层的解释说明（Controller等）/","text":"Hello World! SSM框架SSM框架是spring MVC ，Spring和Mybatis框架的整合，是标准的MVC模式，将整个系统划分为表现层（web），controller层，service层，dao层四层,使用spring MVC负责请求的转发和视图管理。Spring实现业务对象管理，Mybatis作为数据对象的持久化引擎。表现层（web）：通俗讲就是展现给用户的界面，即用户在使用一个系统的时候他的所见所得。业务逻辑层（service）：针对具体问题的操作，也可以说是对数据层的操作，对数据业务逻辑处理。数据访问层（dao）：该层所做事务直接操作数据库，针对数据的增添、删除、修改、更新、查找等。DataBase ===&gt; Entity ===&gt; Mapper.xml ===&gt; Dao.Java ===&gt; Service.java ===&gt; Controller.java ===&gt; html css js（thymeleaf） 各层解释说明用IDEA创建一个maven项目结构如左图所示,在该项目中,有五个包,分别是controller、dao、entity、service和serviceimpl：|层| 描述 ||–|–|| 实体层 | 数据库在项目中的类，主要用于定义与数据库对象应的属性，提供get/set方法,tostring方法,有参无参构造函数。 ||持久层 | 与数据库交互，dao层首先会创建dao接口，接着就可以在配置文件中定义该接口的实现类；接着就可以在模块中调用dao的接口进行数据业务的处理，而不用关注此接口的具体实现类是哪一个类，dao层的数据源和数据库连接的参数都是在配置文件中进行配置的。 ||业务层 |控制业务,业务模块的逻辑应用设计，和dao层一样都是先设计接口，再创建要实现的类，然后在配置文件中进行配置其实现的关联。接下来就可以在service层调用接口进行业务逻辑应用的处理。 || 实现层 |实现service接口的所有方法，整合service和dao ||控制层 | controller层主要调用Service层里面的接口控制具体的业务流程，控制的配置也要在配置文件中进行。Controller和Service的区别是：Controller负责具体的业务模块流程的控制；Service层负责业务模块的逻辑应用设计 | entity层（model层） 实体层用于存放我们的实体类，与数据库中的属性值基本保持一致，实现set和get的方法。 1.导入lombok小辣椒驱动依赖,用来生成get/set方法依赖： 12345678910111213141516171819202122232425package com.dvms.entity;import lombok.AllArgsConstructor;import lombok.Data;import lombok.NoArgsConstructor;import lombok.ToString;import lombok.experimental.Accessors;import java.util.Date;@Data@ToString@AllArgsConstructor@NoArgsConstructor@Accessors(chain = true) //链式调用public class Emp &#123; private String id; private String name; private Double salary; private Integer age; private Date bir;&#125; 2.传统方式 123456789101112131415161718192021222324252627282930313233343536373839404142package com.umf.entity;import java.io.Serializable;public class UpdataSettingEntity implements Serializable &#123; private static final long serialVersionUID = 1L; // private Integer id = 1; // private int updataflag; /** * 设置： */ public void setId(Integer id) &#123; this.id = id; &#125; /** * 获取： */ public Integer getId() &#123; return id; &#125; /** * 设置： */ public void setUpdataflag(int updataflag) &#123; this.updataflag = updataflag; &#125; /** * 获取： */ public int getUpdataflag() &#123; return updataflag; &#125;&#125; dao层（mapper层）dao层（接口类）对数据库进行数据持久化操作，他的方法语句是直接针对数据库操作的，主要实现一些增删改查操作，在Mybatis中方法主要与与xxxDao（Mapper）.xml内相互一一映射。Mybatis可以用.xml进行数据操作，也可以在dao层用注解的方式，也可以采取xml和dao层接口组合使用的方法（常用）。 12345678910111213141516171819202122232425262728package com.dvms.dao;import com.dvms.entity.User;import org.apache.ibatis.annotations.Param;import org.springframework.stereotype.Repository;import java.util.List;@Repositorypublic interface UserDao &#123; //登录 User login(@Param(\"username\") String username, @Param(\"password\") String password);// 在mybatis中传递多个参数要做参数的绑定 //新增用户(注册) void save(User user); //查询所有用户 List&lt;User&gt; findAlluser(); //删除用户 void delete(String id); //修改用户信息（先查再改） User update(String id); void add(User user);&#125; xxxDao（Mapper）.xml：关键： &lt; mapper namespace=”com.dvms.dao.UserDao“&gt;前提：基本数据库语法 123456789101112131415161718192021222324252627282930313233&lt;?xml version=\"1.0\" encoding=\"UTF-8\" ?&gt;&lt;!DOCTYPE mapper PUBLIC \"-//mybatis.org//DTD Mapper 3.0//EN\" \"http://mybatis.org/dtd/mybatis-3-mapper.dtd\"&gt;&lt;mapper namespace=\"com.dvms.dao.UserDao\"&gt;&lt;!--注册/新增用户--&gt; &lt;insert id=\"save\" parameterType=\"User\"&gt; insert into user (id,username,password,sex,phone,email,role) values (#&#123;id&#125;,#&#123;username&#125;,#&#123;password&#125;,#&#123;sex&#125;,#&#123;phone&#125;,#&#123;email&#125;,#&#123;role&#125;) &lt;/insert&gt;&lt;!--登录验证--&gt; &lt;select id=\"login\" resultType=\"User\"&gt; select id,username,password,sex,phone,email,role from user where username =#&#123;username&#125; and password =#&#123;password&#125; &lt;/select&gt;&lt;!--查询所有用户--&gt; &lt;select id=\"findAlluser\" resultType=\"User\"&gt; select id,username,password,sex,phone,email,role from user &lt;/select&gt;&lt;!--删除用户--&gt; &lt;delete id=\"delete\" parameterType=\"String\"&gt; delete from user where id=#&#123;id&#125; &lt;/delete&gt;&lt;!--修改用户信息--&gt; &lt;!--查到要修改的用户信息--&gt; &lt;select id=\"update\" parameterType=\"String\" resultType=\"User\"&gt; select id,username,password,sex,phone,email,role from user where id=#&#123;id&#125; &lt;/select&gt; &lt;!--修改用户信息--&gt; &lt;update id=\"add\" parameterType=\"User\"&gt; update user set username=#&#123;username&#125;,password=#&#123;password&#125;,sex=#&#123;sex&#125;,phone=#&#123;phone&#125;,email=#&#123;email&#125;,role=#&#123;role&#125; where id=#&#123;id&#125; &lt;/update&gt;&lt;/mapper&gt; 在dao层用注解的方式： 12345public interface StudentDao &#123; @Select(\"select * from student where stu_id=#&#123;stuId&#125;\") public Student queryById(int stuId);&#125; service层service层（接口类）为controller层的类提供接口进行调用,一般就是自己写的方法封装起来，具体实现在serviceImpl中。service层是建立在dao层之上的，建立了dao层后才可以建立service层，而service层又是在controller层之下的，因而service层应该既调用dao层的接口，又要提供接口给Controller层的类来进行调用，它刚好处于一个中间层的位置。每个模型都有一个service接口，每个接口分别封装各自的业务处理方法。 12345678910111213141516171819202122232425package com.dvms.service;import com.dvms.entity.User;import java.util.List;public interface UserService &#123; //新增用户 void save(User user); //登录 User login(String username, String password); //查询所有用户 List&lt;User&gt; findAlluser(); //删除用户 void delete(String id); //修改用户信息 User update(String id); void add(User user);&#125; servicedmpl（实现service层，整合service和dao）（导入dao层）（接口实现类） 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253package com.dvms.service.Impl;import com.dvms.dao.UserDao;import com.dvms.entity.User;import com.dvms.service.UserService;import org.springframework.beans.factory.annotation.Autowired;import org.springframework.stereotype.Service;import java.util.List;import java.util.UUID;@Servicepublic class UserServiceImpl implements UserService &#123; @Autowired private UserDao userDao; @Override public void save(User user) &#123; user.setId(UUID.randomUUID().toString()); userDao.save(user); &#125; @Override public User login(String username, String password) &#123; return userDao.login(username,password); &#125; @Override public List&lt;User&gt; findAlluser() &#123; return userDao.findAlluser(); &#125; @Override public void delete(String id) &#123; userDao.delete(id); &#125; @Override public User update(String id) &#123; return userDao.update(id); &#125; @Override public void add(User user) &#123; userDao.add(user); &#125;&#125; Controller层（web 层）负责具体模块的业务流程控制（获取参数（前端传过来）返回响应（前端或数据库或一个指定路径）），需要调用service逻辑设计层的接口来控制业务流程（导入service层）。 1234567891011121314151617181920212223242526272829303132package com.dvms.controller;import com.dvms.entity.Emp;.....@Controllerpublic class EmpController &#123; @Autowired private EmpService empService; @GetMapping(\"emp/findAll\") public String findAll(@RequestParam(defaultValue = \"1\") int pageNum, @RequestParam(defaultValue = \"5\") int pageSize, Model model)&#123; PageHelper.startPage(pageNum,pageSize);// PageInfo&lt;Emp&gt; pageInfo = new PageInfo&lt;&gt;(empService.findAll()); model.addAttribute(\"pageInfo\",pageInfo);// List&lt;Emp&gt; emps = empService.findAll();// model.addAttribute(\"emps\",emps); return \"ems/tables\"; &#125; @RequestMapping(\"/emp/save\") public String save(Emp emp)&#123; empService.save(emp); return \"redirect:/emp/findAll\"; &#125;&#125; Controller层调用了Service层的接口方法，Service层调用Dao层的方法，其中调用的参数是使用Entity层进行传递的。View层与Controller层协同工作,主要负责界面展示。","updated":"2020-07-23T07:18:55.976Z","categories":[{"name":"JavaWeb","slug":"JavaWeb","permalink":"http://yoursite.com/categories/JavaWeb/"}],"tags":[{"name":"JavaWeb","slug":"JavaWeb","permalink":"http://yoursite.com/tags/JavaWeb/"},{"name":"SSM框架","slug":"SSM框架","permalink":"http://yoursite.com/tags/SSM%E6%A1%86%E6%9E%B6/"}]},{"title":"MyBatis映射标签resultMap与resultType、parameterMap与 parameterType","date":"2020-07-21T10:49:06.000Z","path":"2020/07/21/MyBatis映射标签resultMap与resultType、parameterMap与-parameterType/","text":"Hello World! MyBatis映射标签1234567&lt;?xml version=\"1.0\" encoding=\"UTF-8\" ?&gt;&lt;!DOCTYPE mapper PUBLIC \"-//mybatis.org//DTD Mapper 3.0//EN\" \"http://mybatis.org/dtd/mybatis-3-mapper.dtd\"&gt;&lt;mapper namespace=\"com.dvms.dao.UserDao\"&gt;....&lt;/mapper&gt; 123456789101112131415161718192021222324252627282930313233&lt;?xml version=\"1.0\" encoding=\"UTF-8\" ?&gt;&lt;!DOCTYPE mapper PUBLIC \"-//mybatis.org//DTD Mapper 3.0//EN\" \"http://mybatis.org/dtd/mybatis-3-mapper.dtd\"&gt;&lt;mapper namespace=\"com.dvms.dao.UserDao\"&gt;&lt;!--注册/新增用户--&gt; &lt;insert id=\"save\" parameterType=\"User\"&gt; insert into user (id,username,password,sex,phone,email,role) values (#&#123;id&#125;,#&#123;username&#125;,#&#123;password&#125;,#&#123;sex&#125;,#&#123;phone&#125;,#&#123;email&#125;,#&#123;role&#125;) &lt;/insert&gt;&lt;!--登录验证--&gt; &lt;select id=\"login\" resultType=\"User\"&gt; select id,username,password,sex,phone,email,role from user where username =#&#123;username&#125; and password =#&#123;password&#125; &lt;/select&gt;&lt;!--查询所有用户--&gt; &lt;select id=\"findAlluser\" resultType=\"User\"&gt; select id,username,password,sex,phone,email,role from user &lt;/select&gt;&lt;!--删除用户--&gt; &lt;delete id=\"delete\" parameterType=\"String\"&gt; delete from user where id=#&#123;id&#125; &lt;/delete&gt;&lt;!--修改用户信息--&gt; &lt;!--查到要修改的用户信息--&gt; &lt;select id=\"update\" parameterType=\"String\" resultType=\"User\"&gt; select id,username,password,sex,phone,email,role from user where id=#&#123;id&#125; &lt;/select&gt; &lt;!--修改用户信息--&gt; &lt;update id=\"add\" parameterType=\"User\"&gt; update user set username=#&#123;username&#125;,password=#&#123;password&#125;,sex=#&#123;sex&#125;,phone=#&#123;phone&#125;,email=#&#123;email&#125;,role=#&#123;role&#125; where id=#&#123;id&#125; &lt;/update&gt;&lt;/mapper&gt; 在MyBatis中，输入与输出都是相对于数据库而言，我们通过parameterType完成输入映射(指将值映射到sql语句的占位符中，值的类型与dao层响应方法的参数类型一致)，通过resultType完成输出映射(从数据库中输出，通过dao层的方法查询到的数据输出到pojo对象（实体类entity）中)。 1. 输入映射（往数据库输入）parameterMap（不常用）与 parameterType（常用） ParameterMap和resultMap类似，表示将查询结果集中列值的类型一一映射到java对象属性的类型上，在开发过程中不推荐这种方式。 一般使用parameterType直接将查询结果列值类型自动对应到java对象属性类型上，不再配置映射关系一一对应。 2. 输出映射（从数据库输出）resultMap与resultType（常用） 两者都是表示查询结果集与java对象之间的一种关系，处理查询结果集，映射到java对象。 resultMap表示将查询结果集中的列一一映射到bean对象的各个属性。映射的查询结果集中的列标签可以根据需要灵活变化，并且，在映射关系中，还可以通过typeHandler设置实现查询结果值的类型转换，比如布尔型与0/1的类型转换。 #{}和${}的使用resultMap和ParameterMap书写拼写要使用#{}，resultType 和parameterType类型使用${}，（一般是用#{}）使用例子如下： Select ID，COMMAND from Message where COMMAND=#{command} Select ID，COMMAND from Message where COMMAND=‘${command}’ 前者解析为： Select ID，COMMAND from Message where COMMAND=？具有预编译效果后者解析为： Select ID，COMMAND from Message where COMMAND=段子 不具有预编译效果 在Mybatis中传递多个参数要做参数的绑定（@Param）不写parameterType也可以运行,因为Mybatis能自动识别，但返回值类型不能不写!!Mybatis自动识别入参对象, 传入单个map或单个对象,无需写@Param注解 如@Param(“map”) Map&lt;String, Object&gt; map那么什么时候必须在mapper接口上写@Param注解呢, mapper接口中有多个参数(每个对象或参数都要加@Param注解), 或一个 String, 必须使用@Param注解,END","updated":"2020-07-23T07:22:13.135Z","categories":[{"name":"SpringBoot","slug":"SpringBoot","permalink":"http://yoursite.com/categories/SpringBoot/"},{"name":"JavaWeb","slug":"SpringBoot/JavaWeb","permalink":"http://yoursite.com/categories/SpringBoot/JavaWeb/"}],"tags":[{"name":"MyBatis","slug":"MyBatis","permalink":"http://yoursite.com/tags/MyBatis/"}]},{"title":"Spring框架常用注解","date":"2020-07-21T10:17:34.000Z","path":"2020/07/21/Spring框架常用注解/","text":"Hello World! Spring常用注解 @Controller@Controller 用来响应页面，表示当前的类为控制器。在SpringMVC 中，控制器Controller 负责处理由DispatcherServlet 分发的请求，它把用户请求的数据经过业务处理层处理之后封装成一个Model ，然后再把该Model 返回给对应的View 进行展示。在SpringMVC 中提供了一个非常简便的定义Controller 的方法，你无需继承特定的类或实现特定的接口，只需使用@Controller 标记一个类是Controller ，然后使用@RequestMapping 和@RequestParam 等一些注解用以定义URL 请求和Controller 方法之间的映射，这样的Controller 就能被外界访问到。此外Controller 不会直接依赖于HttpServletRequest 和HttpServletResponse 等HttpServlet 对象，它们可以通过Controller 的方法参数灵活的获取到。@Controller 用于标记在一个类上，使用它标记的类就是一个SpringMVC Controller 对象。分发处理器将会扫描使用了该注解的类的方法，并检测该方法是否使用了@RequestMapping 注解。@Controller 只是定义了一个控制器类，而使用@RequestMapping 注解的方法才是真正处理请求的处理器。单单使用@Controller 标记在一个类上还不能真正意义上的说它就是SpringMVC 的一个控制器类，因为这个时候Spring 还不认识它。那么要如何做Spring 才能认识它呢?这个时候就需要我们把这个控制器类交给Spring 来管理。 @RestControllerSpring4之后新加入的注解，原来返回json需要@ResponseBody和@Controller配合，表明当前类是控制器且返回的是一组数据，不是页面。@RestController是@ResponseBody和@Controller的组合注解，推荐直接使用@RestController注解来处理http请求。 12345678@RestControllerpublic class HelloController &#123; @RequestMapping(value=\"/hello\",method= RequestMethod.GET) public String sayHello()&#123; return \"hello\"; &#125;&#125; 123456789@Controller@ResponseBodypublic class HelloController &#123; @RequestMapping(value=\"/hello\",method= RequestMethod.GET) public String sayHello()&#123; return \"hello\"; &#125;&#125; @Autowired@Autowired的作用是将其他的类，接口引入，类似于之前的类的初始化等，用这个注解，类中或接口的方法就可以直接调用了。@Autowired顾名思义，就是自动装配，其作用是为了消除代码Java代码里面的getter/setter与bean属性中的property。当然，getter看个人需求，如果私有属性需要对外提供的话，应当予以保留。@Resource的作用相当于@Autowired @ResponseBody作用: 该注解用于将Controller的方法返回的对象，通过适当的HttpMessageConverter转换为指定格式后，写入到Response对象的body数据区。当返回的数据不是html标签的页面，而是其他某种格式的数据时(如json、xml等)时使用。 @RequestMapping （配置url映射）@RequestMapping如果没有指定请求方式，将接收Get,Post,Head,Options等所有的请求方式。@RequestMapping此注解即可以作用在控制器的某个方法上，也可以作用在此控制器类上。当前台界面调用Controller处理数据时候告诉控制器怎么操作有3种情形：1.当控制器在类级别上添加@RequestMapping注解时，这个注解会应用到控制器的所有处理器方法上。处理器方法上的@RequestMapping注解会对类级别上的@RequestMapping的声明进行补充。2.@RequestMapping作用在处理器方法上。3.@RequestMapping同时作用在类级别和处理器方法上。所响应的url=localhost:8080/updata_setting/updata @RequestMapping注解属性作用：简化常用的HTTP方法的映射，并更好地表达被注解方法的语义。RequestMapping注解有六个属性：1、 value， method; value: 指定请求的实际地址，指定的地址可以是URI Template 模式(后面将会说明); method: 指定请求的method类型， GET、POST、PUT、DELETE等;常用： GET、POST组合注解： @GetMapping @RequestMapping(method = RequestMethod.GET)的简写作用：对应查询，表明是一个查询URL映射 @PostMapping @RequestMapping(method =RequestMethod.POST)的简写作用：对应增加，表明是一个增加URL映射 @PutMapping@RequestMapping(method = RequestMethod.PUT)的简写作用：对应更新，表明是一个更新URL映射 @DeleteMapping @RequestMapping(method = RequestMethod.DELETE)的简写作用：对应删除，表明是一个删除URL映射 2、consumes，produces consumes: 指定处理请求的提交内容类型(Content-Type)，例如application/json, text/html; produces: 指定返回的内容类型，仅当request请求头中的(Accept)类型中包含该指定类型才返回; 3、params，headers params: 指定request中必须包含某些参数值是，才让该方法处理。 headers: 指定request中必须包含某些指定的header值，才能让该方法处理请求。 @PathVaribale通过@PathVariable注解来获取URL中的参数时的前提条件是我们知道url的格式时怎么样的。只有知道url的格式，我们才能在指定的方法上通过相同的格式获取相应位置的参数值。1.获取url中的单个参数（如id） 12345678@RestControllerpublic class HelloController &#123; @RequestMapping(value=\"/hello/&#123;id&#125;\",method= RequestMethod.GET) public String sayHello(@PathVariable(\"id\") Integer id)&#123; return \"id:\"+id; &#125;&#125; 2.获取url有多个参数 12345678@RestControllerpublic class HelloController &#123; @RequestMapping(value=\"/hello/&#123;id&#125;/&#123;name&#125;\",method= RequestMethod.GET) public String sayHello(@PathVariable(\"id\") Integer id,@PathVariable(\"name\") String name)&#123; return \"id:\"+id+\" name:\"+name; &#125;&#125; @RequestParam作用：获取请求参数的值@RequestParam注解给允许用户不输入参数时，使用默认值； @RequestBody如果传输的是单层json对象，我们后台可以直接用 @RequestParam接收。如果传输的是多层嵌套json对象，这个时候会就会出现数据丢失问题，@ResponseBody很好的解决了这个问题，它会把前台传输过来的json转化为后台对应的对象；@RequestBody接收的是一个Json对象的字符串，而不是一个Json对象。（易出错）然而在ajax请求往往传的都是Json对象，用JSON.stringify(data)的方式就能将对象变成字符串。同时ajax请求的时候也要指定dataType: “json”,contentType:”application/json” 这样就可以轻易的将一个对象或者List传到Java端，使用@RequestBody即可绑定对象或者List。 12345678910111213141516171819var vm = new Vue(&#123; el: '#updata', data: &#123; updata_setting: &#123;&#125; &#125;, methods: &#123; Save:function(ev)&#123; var url = \"../updata_setting/updata\"; $.ajax(&#123; type: \"POST\", url: url, data: JSON.stringify(vm.updata_setting), success: function(r)&#123; alert('操作成功！'); &#125; &#125;); &#125; &#125;&#125;); @Service用于标注业务层组件，位于service实现层：形如：@Service(“xxxService”) @Override@Override是伪代码,表示重写(当然不写也可以),不过写上有如下好处:1、可以当注释用,方便阅读。2、编译器可以给你验证@Override下面的方法名是否是你父类中所有的,如果没有则报错。比如你如果没写@Override而你下面的方法名又写错了,这时你的编译器是可以编译通过的(它以为这个方法是你的子类中自己增加的方法)。 @Repository@Repository用于标注数据访问组件，即dao层如果 Web 应用程序采用了经典的三层分层结构的话，最好在持久层、业务层和控制层分别采用上述注解对分层中的类进行注释。@Component泛指组件，当组件不好归类的时候，我们可以使用这个注解进行标注。 END","updated":"2020-07-23T07:18:55.952Z","categories":[{"name":"JavaWeb","slug":"JavaWeb","permalink":"http://yoursite.com/categories/JavaWeb/"}],"tags":[{"name":"Spring框架","slug":"Spring框架","permalink":"http://yoursite.com/tags/Spring%E6%A1%86%E6%9E%B6/"}]}]