[{"title":"数据库日常之修改MySQL数据库密码的方法","date":"2020-07-23T06:14:46.000Z","path":"2020/07/23/数据库日常之修改MySQL数据库密码的方法/","text":"Hello World! 1.windows下利用CMD命令修改开始时如果用户user没有密码，则 -p 旧密码 一项就可以省略；修改格式： 1mysql -hlocalhost -u root -p 旧密码 password 新密码 修改步骤：(按回车键Enter执行命令行）1.首先在DOS下进入目录mysql\\binC: \\Users\\Adninistrator&gt;D:D:&gt;cd D:\\mysql-5.7.22-win32\\bin2.然后输入以下命令：D:\\mysql-5.7.22-win32\\bin&gt;mysql -hlocalhost -u root -p 111111 password 123456 2.在MySQL环境中修改MySQL命令结束后都带一个分号作为命令结束符修改格式： 1UPDATE mysql.user SET password=PASSWORD('123456') WHERE User='root'; (按回车键Ctrl+Shift+Enter执行命令行）mysql&gt; UPDATE mysql.user SET password=PASSWORD(‘123456’) WHERE User=’root’;运行完这行之后会提示下面的信息：Query OK, 0 rows affected (0.00 sec)Rows matched: 2 Changed: 0 Warnings: 0这时候还需要运行下面一句，否则密码不会被修改： 1FLUSH PRIVILEGES; 下面运行结果代表修改成功：Query OK, 0 rows affected (0.16 sec)然后显示当前的user： 1SELECT USER(); 3.在MySQL和Navicat中直接修改3.1 MySQL Workbench3.2 Navicat1.连接初始进入2.点击用户3.右键编辑root用户4.修改密码，授权数据库操作权限5.将链接密码修改为以上设置的密码即可（右键连接属性） END","updated":"2020-07-23T07:16:15.593Z","categories":[{"name":"MySQL","slug":"MySQL","permalink":"http://yoursite.com/categories/MySQL/"}],"tags":[{"name":"密码修改","slug":"密码修改","permalink":"http://yoursite.com/tags/%E5%AF%86%E7%A0%81%E4%BF%AE%E6%94%B9/"},{"name":"数据库","slug":"数据库","permalink":"http://yoursite.com/tags/%E6%95%B0%E6%8D%AE%E5%BA%93/"}]},{"title":"数据库学习与应用之利用cmd命令操纵数据库(下）","date":"2020-07-23T06:14:44.000Z","path":"2020/07/23/数据库学习与应用之利用cmd命令操纵数据库-下）/","text":"Hello World! 1. 数据库用户的权限控制：（数据表级的权限控制 : 将某个库中的某个表的控制权赋予某个用户） 1Grant all ON db_name.table_name TO user_name [ indentified by ‘password’ ]; 2. 修改数据库表中结构操作：2.1 增加一个表中的字段格式： 1alter table table_name add column (字段名 字段类型); 2.2 指定表中的字段插入的位置： 1alter table table_name add column 字段名 字段类型 after 某字段； 2.3 删除一个表中的字段： 1alter table table_name drop字段名; 2.4 修改表中字段名称/类型 1alter table table_name change 旧字段名 新字段名 新字段的类型; 2.5 改表的名字 1alter table table_name rename to table_new; 2.6 一次性清空表中的所有数据 1truncate table table_name; 2.7 数据库表字段更新: 123update table_name-&gt; set sex='不详' -&gt; where name_id=1; 3. 显示当前数据库版本和日期 ： 1select version(),current_date; 退出操作 1exit; END","updated":"2020-07-23T07:18:56.026Z","categories":[{"name":"MySQL","slug":"MySQL","permalink":"http://yoursite.com/categories/MySQL/"}],"tags":[{"name":"工具","slug":"工具","permalink":"http://yoursite.com/tags/%E5%B7%A5%E5%85%B7/"},{"name":"cmd","slug":"cmd","permalink":"http://yoursite.com/tags/cmd/"}]},{"title":"数据库学习与应用之利用cmd命令操纵数据库(上）","date":"2020-07-23T06:14:43.000Z","path":"2020/07/23/数据库学习与应用之利用cmd命令操纵数据库-上）/","text":"Hello World! 1.在DOS下进入目录mysql\\binC: \\Users\\Adninistrator&gt;D:D:&gt;cd D:\\mysql-5.7.22-win32\\bin 2.然后输入以下命令来操纵数据库： 2.1 连接数据库 1D:\\mysql-5.7.22-win32\\bin&gt;mysql -h localhost -u root -p123456 2.2 显示本地所有数据库（==所有的命令都以;结束==）： 1SHOW DATABASES; 2.3创建和删除数据库：创建和删除时可先判断是否存在，可写成 :create/drop database if exits db_name ，数据库中表的创建同理； 12create database 数据库名;drop database 数据库名; 2.4 操作数据库中的数据表：2.4.1 选择当前要操作的主数据库： 1USE 数据库名; 2.4.2 显示当前主数据库的所有数据表： 1SHOW TABLES; 2.4.3 查询表 显示表中的所有记录，* (表示所有字段)： 1SELECT * FROM table_name; 2.4.4 查询指定字段的数据 : 1select 字段1 , 字段2 from table_name; 2.4.5 查看表的结构： 123DESC table_name;Describe table_name;show columns from table_name; 2.4.6 删除整个表中的所以信息 : 1delete from table_name; 2.4.7 显示数据表创建时的全部信息 1show create table table_name; 2.5 创建和删除表：2.5.1 创建表 1CREATE TABLE table_name(字段名1 字段类型 字段的约束（可省略）, 字段名1 字段类型 字段的约束（可省略）,……); 例：create table cjw (id int , username char(20));2.5.2 删除表 1DROP TABLE table_name; 2.6 插入数据操作：如果向表中的每个字段都插入一个值,那么前面 [ ] 括号内字段名可写也可以不写 1Insert into table_name [(字段1 , 字段2 , ….)] values (值1 , 值2 , …..); 例如：insert into cjw (id,username) values (0,’tree’);2.7 更新（修改）和删除数据操作：2.7.1 更新指定数据 , 更新某一个字段的数据（不是更新字段名） 1Update table_name set 字段名=’修改值’ [, 字段2 =’修改值’ , …..][where id=id_num] [order by 字段 顺序] 例如 : update cjw set username=’marry’ where id=0;2.7.2 删除表中指定条件的语句 :在删除全部记录的同时将自增id的增长量也一并清零条件删除：DELETE FROM 表名 WHERE 条件where中的条件: [ 字段名 运算符 字段值 ]构成运算符:= != &lt;&gt; &gt; &lt; &gt;= &lt;= is null / is not null多个条件: and表示且 条件1 and 条件2，or 表示或，not 表示非 1delete from table_name where 条件语句 ; 例如：delete from cjw where id=0; 2.8 创建数据库用户 一次创建一个或多个数据库用户 1CREATE USER username1 identified BY ‘password’ , username2 IDENTIFIED BY ‘password’…. 例如：CREATE USER root identified BY ‘123456’ , cjw IDENTIFIED BY ‘5201314’…. Contiue……","updated":"2020-07-23T07:20:08.026Z","categories":[{"name":"MySQL","slug":"MySQL","permalink":"http://yoursite.com/categories/MySQL/"}],"tags":[{"name":"工具","slug":"工具","permalink":"http://yoursite.com/tags/%E5%B7%A5%E5%85%B7/"},{"name":"cmd","slug":"cmd","permalink":"http://yoursite.com/tags/cmd/"}]},{"title":"数据库学习与应用之什么是数据库","date":"2020-07-23T06:14:41.000Z","path":"2020/07/23/数据库学习与应用之什么是数据库/","text":"Hello World! 数据库数据库，是一个长期存储在计算机内的、有组织的、有共享的、统一管理的数据集合。 常用的数据库有Access、Oracle、Mysql、SQL Server、SQLite等； 数据库中的数据都有一定规律结构，相同类型的数据放在一起，不同类型的数据之间相互隔离；数据库由统一的规则来读写，有SQL语言专门用来读写数据库，一般都是用程序来读写数据库的内容。 数据库支持的软件模式：B/S：Browser/Server （浏览器/服务器）（淘宝）C/S：Client/Server （客户端/服务器）（QQ、微信） 常用的数据库 数据库应用 描述 MySQL数据库 小型数据库管理系统的数据库，由瑞典MySQLAB公司开发。MySQL被广泛地应用在Internet上的中小型网站当中 SqlServer数据库 中型数据库软件，真正的客户/服务器体系结构，图形化的用户界面，数据库管理方式更加直观和简单 Oracle数据库 大型企业级数据库，这是一款比较典型的客户/服务器(CLIENT/SERVER)或B/S体系结构的数据库之一，目前世界上使用最为广泛的数据库管理系统 Access数据库 小型的数据库，关联式数据序管理型系统的数据库，通常是被用来开发Web应用程序 数据库可视化管理工具1. MySQL WorkbenchMySQL Workbench为数据库管理员、程序开发者和系统规划师提供可视化设计、模型建立、以及数据库管理功能。它包含了用于创建复杂的数据建模ER模型，正向和逆向数据库工程，也可以用于执行通常需要花费大量时间和需要的难以变更和管理的文档任务。MySQL工作台可在Windows，Linux和Mac上使用；2. NavicatNavicat是一个桌面版MySQL数据库管理和开发工具。Navicat使用图形化的用户界面，可以让用户使用和管理更为轻松。支持中文，有免费版本提供；3. MySQLDumperMySQLDumper使用PHP开发的MySQL数据库备份恢复程序，解决了使用PHP进行大数据库备份和恢复的问题，数百兆的数据库都可以方便的备份恢复，不用担心网速太慢导致中间中断的问题，非常方便易用； 数据库访问方式利用数据库管理工具或者编写程序来访问数据库。当然，数据库和访问数据库可以跨空间进行（本地和远程）连接：数据库管理工具、编程语言（Java、PyThon等） END","updated":"2020-07-23T07:19:50.410Z","categories":[{"name":"MySQL","slug":"MySQL","permalink":"http://yoursite.com/categories/MySQL/"}],"tags":[{"name":"工具","slug":"工具","permalink":"http://yoursite.com/tags/%E5%B7%A5%E5%85%B7/"}]},{"title":"数据库学习与应用之SQL语法及常用操作","date":"2020-07-23T06:14:39.000Z","path":"2020/07/23/数据库学习与应用之SQL语法及常用操作/","text":"Hello World! SQL语法SQL：Structed Query Language 结构化查询语句 注意： 在数据库操作中，所有的命令和关键字以及自定义名称都==不区分大小写==，但是一般我们：关键字部分使用全部大写，自定义名称（数据库名、数据库表名、字段名）用小写字母开头； 字符串使用单引号或者双引号，一般使用单引号，方便在java/PHP/HTML程序和代码字符串类型的参数进行嵌套； 所有的符号都必须是英文状态的符号，数据库高版本可以直接使用双引号； 部分参数含义： 参数名 缩写 描述 host -h 服务器IP地址 port -P 服务器端口号 user -u 数据库用户名 pasword -p 数据库的密码 — # SQL语句 数据库创建 : Create database db_name; ———————————————————————– 创建时可先判断是否存在 : Create database if not exits db_name 数据库删除 : Drop database db_name; ———————————————————————– 删除时可先判断是否存在 : drop database if exits db_name ———————————————————————– 数据库表创建 : create table table_name (字段1 数据类型 , 字段2 数据类型); eg : create table demo (id int , name varchar(20)); ———————————————————————– 数据库表删除 : drop table table_name; eg: drop table demo; ———————————————————————– 数据库表插入数据 : Insert into 表名 [(字段1 , 字段2 , ….)] values (值1 , 值2 , …..); 如果向表中的每个字段都插入一个值,那么前面 [ ] 括号内字段名可写也可不写 eg : insert into demo (id,username) values (0,’cjw’); ———————————————————————– 查询数据库表中所有数据 : select * from table_name; 查询数据库表中指定字段的数据 : select 字段1 , 字段2 from table_name; eg : select id,username from demo where id=1 order by desc; ———————————————————————– 更新数据库表中指定字段的数据： Update table_name set 字段名=’新值’ [, 字段2 =’新值’ , …..][where id=id_num] [order by 字段 顺序] eg : update demo set username=’cjw’ where id=1; Where和order语句也可用于查询select 与删除delete 删除整个数据库表中的信息 : delete from table_name; 删除数据库表中指定条件的语句 : delete from table_name where 条件语句 ; 条件语句如 : id=1; ———————————————————————– 创建一个数据库用户: CREATE USER username1 identified BY ‘password’ 创建多个数据库用户: CREATE USER root identified BY ‘password’ , user1 IDENTIFIED BY ‘password’…. ———————————————————————– 用户的权限控制：grant 库，表级的权限控制 : 将某个库中的某个表的控制权赋予某个用户 Grant all ON db_name.table_name TO user_name [ indentified by ‘password’ ]; ———————————————————————– 数据库表中增加一个字段： alter table table_name add column (字段名 字段类型); 数据库表中指定字段插入的位置： alter table table_name add column 字段名 字段类型 after 某字段； 数据库表中删除一个字段： alter table table_name drop字段名; 数据库表中修改字段名称/类型 alter table table_name change 旧字段名 新字段名 新字段的类型; ———————————————————————– 修改数据库表名： alter table table_name rename to new_table_name; ———————————————————————– 清空数据库表中的所有数据 ： truncate table table_name; ———————————————————————– 增加主键，外键，约束，索引： 约束（主键Primary key、唯一性Unique、非空Not Null） 自动增张 auto_increment 外键Foreign key—–与reference table_name(col_name列名)配合使用，建表时单独使用 删除多个表中有关联的数据—-设置foreign key 为set null ———————————————————————– 查看数据库当前引擎： SHOW CREATE TABLE table_name; 修改数据库引擎 ： ALTER TABLE table_name ENGINE=MyISAM InnoDB; SQL常用操作 create database name; 创建数据库 use databasename; 选择数据库 drop databasename 直接删除数据库，不提示 mysqladmin drop databasename 删除数据库前，有提示 show tables; 显示数据库表 describe（DESC） tablename; 数据库表的详细描述 select * from tablename; 查询数据库表 查询数据库表的记录总数(三种方法) select count() from tablename;或者 select count() as num from tablename;或者 select count(*) as total from tablename; select 中加上distinct去除重复字段 select version(),current_date; 显示当前mysql版本和当前日期mysql的启动与停止 启动MySQL服务 net start mysqlversion停止MySQL服务 net stop mysqlversion show status;数据库状态信息参数解析(数据库连接后输入） alter table users character set GBK;解决中文乱码（utf-8） SQL语句运用举例: ——————————————————建表 —————————————————————- 1create table users (id int primary key auto_increment,nikename varchar(20) not null unique,password varchar(100) not null,address varchar(200), reg_date timestamp not null default CURRENT_TIMESTAMP); ———————————————–建表时设置外键———————————————————- 1create table demo (id int primary key auto_increment,content longtext not null,userid int,constraint foreign key (userid) references users(id) on delete set null); ———————————————–建表时不设置外键———————————————————- 1create table demo (id int primary key auto_increment,content longtext not null,userid int); ———————————————–给demo表设置外键 ——————————————————- 1alter table demo add constraint foreign key (userid) references users(id) on delete set null; ———————————————向表中同时插入多条数据 ————————————————— insert into users (id,name,password,address) values (1,’tom’,’123456’,null),(4,’li’,’654321’,’天津’),(null,’韩梅梅’,’456789’, ‘山西’);———————————————多表查询指定字段所有信息 ———————————————— 1select demo.id,demo.content,users.* from users,demo where users.id=1 and demo.userid=users.id order by demo.id desc; END","updated":"2020-07-23T07:20:13.955Z","categories":[{"name":"MySQL","slug":"MySQL","permalink":"http://yoursite.com/categories/MySQL/"}],"tags":[{"name":"sql语法","slug":"sql语法","permalink":"http://yoursite.com/tags/sql%E8%AF%AD%E6%B3%95/"}]},{"title":"MySQL数据库范围、模糊、时间范围（时间段）查询语句","date":"2020-07-23T06:14:38.000Z","path":"2020/07/23/MySQL数据库范围、模糊、时间范围（时间段）查询语句/","text":"Hello World! MySQL数据库范围、模糊、时间范围查询语句My Environment MySQL5.46 1. 模糊查询语句1SELECT 字段 FROM TABLENAME WHERE 某字段 Like 条件 其中条件有四种匹配方式：1、%：表示任意0个或多个字符。可匹配任意类型和长度的字符，如果是中文，使用两个百分号（%%）来表示。 eg:SELECT * FROM TABLENAME WHERE NAME LIKE ‘%aa%’功能：找出NAME中含有aa的所有记录eg:SELECT * FROM TABLENAME WHERE NAME LIKE ‘%aa%’ AND NAME LIKE ‘%bb%’功能：找出NAME中既有“aa”又有“bb”的所有记录eg:SELECT * FROM TABLENAME WHERE NAME LIKE ‘%aa%bb%’功能：找出 NAME中形如aabbcc,不能找出bbaacc 2、_： 表示任意单个字符。匹配单个任意字符，常用来限制表达式的字符长度语句 eg: SELECT * FROM TABLENAME WHERE NAME LIKE ‘aa‘功能：找出 NAME中形如找出bbaacc,也就是aa位于中间的所有记录eg: SELECT * FROM TABLENAME WHERE NAME LIKE ‘aa__’;功能：找出 NAME中形如aabbcc,不能找出bbaacc,只能找出以aa开头的所有记录 3、[ ]：表示括号内所列字符中的一个（类似正则表达式）。指定一个字符、字符串或范围，要求所匹配对象为它们中的任一个。 eg: SELECT * FROM TABLENAME WHERE NAME LIKE ‘[abc]d’功能：找出 NAME中形如ad、bd、cd的所有记录当 [ ] 内有一系列字符（01234、abcde之类的）则可略写为“0-4”、“a-e”eg:SELECT * FROM TABLENAME WHERE NAME LIKE ‘a[a-e]’功能：找出 NAME中形如aa、ab、ac、ad、ae的所有记录 4、[^ ] ：表示不在括号所列之内的单个字符。其取值和 [] 相同，要求所匹配对象为指定字符以外的任一个字符。 eg:SELECT * FROM TABLENAME WHERE NAME LIKE ‘[^abc]d’功能：找出 NAME中除了形如ad、bd、cd的所有记录eg:SELECT * FROM TABLENAME WHERE NAME LIKE ‘d[^abc]’其中abc也可以写成a-c功能：找出 NAME中除了形如da、db、dc的所有记录 范围查询语句between：between限制查询数据范围时包括了边界值between and 包含时间界限，这就相当于&gt;= &lt;=，而&gt; &lt;不包含not between不包括的数据范围 eg: SELECT * FROM TABLENAME WHERE time BETWEEN time1 AND time2功能：找出==在==time1 和 time2范围内的所有记录 eg: SELECT * FROM TABLENAME WHERE A NOT BETWEEN num1 AND num2功能：找出==不在== num1 和 num2范围内的所有记录 时间范围（时间段）查询语句eg: SELECT * FROM TABLENAME WHERE time BETWEEN ‘2020-06-13 00:00:00’ and ‘2020-06-13 18:30:59’功能：找出==在== 2020-06-13 00:00:00 和 2020-06-13 18:30:59范围内的所有记录 END","updated":"2020-07-23T07:20:48.061Z","categories":[{"name":"MySQL","slug":"MySQL","permalink":"http://yoursite.com/categories/MySQL/"}],"tags":[{"name":"sql语法","slug":"sql语法","permalink":"http://yoursite.com/tags/sql%E8%AF%AD%E6%B3%95/"}]},{"title":"MySQL数据库安装教程(windows)","date":"2020-07-23T06:13:31.000Z","path":"2020/07/23/MySQL数据库安装教程-windows/","text":"Hello World! 1. 下载及配置环境变量⦁ 解压mysql安装包：将mysql-5.7.22-win32的zip解压缩到一个位置，在这里我们假设其被解压缩到D盘⦁ 解压完后的mysql-5.7.22-win32文件夹如图2.1所示，在mysql-5.7.22-win32文件夹下新建一个叫data的文件夹和一个ini格式的叫my.ini的文件（用记事本新建一个txt，再将其另存为成my.ini）my.ini内容： 12345678910111213141516[mysql] # 设置mysql客户端默认字符集 default-character-set=utf8 [mysqld] #设置3306端口port = 3306 # 设置mysql的安装目录 basedir=D:\\mysql-5.7.22-win32# 设置mysql数据库的数据的存放目录 datadir=D:\\mysql-5.7.22-win32\\data # 允许最大连接数 max_connections=200 # 服务端使用的字符集默认为8比特编码的latin1字符集 character-set-server=utf8 # 创建新表时将使用的默认存储引擎 default-storage-engine=INNODB 配置环境变量：右键点击“我的电脑”，选择“属性”，得到如图3.1所示界面，选择“高级系统设置”；进入“环境变量”后，在下边的系统变量里选择“新建”，在弹出的对话框里“变量名”一栏里填mysql_home，变量值里填MySQL的bin文件夹的路径，本例中为D:\\mysql-5.7.22-win32\\bin。 之后再环境变量path中添加mysql的环境变量，选择Path的环境变量，之后点击编辑——右上角新建——填写”%环境变量名称%\\bin”，图中划横线的地方填写的是上一步第一个输入框的名称，所以我这是%mysql_home%\\bin；如果是windows7的可以在Path后追加“;%mysql_home%\\bin”。 2. 配置MySQL数据库1.以管理员身份运行cmd（按照C:\\Windows\\System32的路径找到cmd.exe，右键点击，选择“以管理员身份运行”），之后输入D:（即MySQL所在的盘），然后再输入cd mysql-5.7.22-win32\\bin（即MySQL的bin文件夹的路径）;2.这样就通过cmd进入MySQL的bin文件夹了。之后再输入mysqld –install，完成对MySQL的安装;3.再输入mysqld -–initialize，完成对MySQL的初始化，这一步骤会有一段时间;4.data文件夹会出现一些文件，其中.err的文件中有生成的MySQL初始密码，该密码为随机产生的，因此务必记住；5.启动 MySQL 服务：进入 MySQL 的 bin 目录(经过前面的步骤，此时正处于 MySQL 的 bin目录下)，输入：net start mysql登录MySQL，输入mysql -u root –p，当出现Enter password：就输入刚才随机生成的初始密码（==注意：初始密码无法复制，必须手动输入==）6.若觉得初始密码太过难记，则可修改密码，输入set password for root@localhost=password(‘123456’);其中括号里的就是修改后的密码，（现在我们的密码是：123456，必须加分号）进行上述步骤后，我们已经可以使用MySQL了，只要进行第5、6步就可以，但是这样的MySQL很不直观，因此我们有必要再安装MySQL的可视化文件MySQL workbench。 1234567891011121314151617181920212223242526272829C:\\Windows\\system32&gt;D:D:\\&gt;cd mysql-5.7.22-win32\\binD:\\mysql-5.7.22-win32\\bin&gt;mysqld -installService successfully installed.D:\\mysql-5.7.22-win32\\bin&gt;mysqld --initializeD:\\mysql-5.7.22-win32\\bin&gt;net start mysqlMySQL 服务正在启动 .MySQL 服务已经启动成功。D:\\mysql-5.7.22-win32\\bin&gt;mysql -u root -pEnter password: ************Welcome to the MySQL monitor. Commands end with ; or \\g.Your MySQL connection id is 2Server version: 5.7.22Copyright (c) 2000, 2018, Oracle and/or its affiliates. All rights reserved.Oracle is a registered trademark of Oracle Corporation and/or itsaffiliates. Other names may be trademarks of their respectiveowners.Type 'help;' or '\\h' for help. Type '\\c' to clear the current input statement.mysql&gt; set password for root@localhost=password('123456');Query OK, 0 rows affected, 1 warning (0.00 sec) 常见错误解决办法：1.未以管理员身份运行cmd执行mysqld -install时，出现Install/Remove of the Service Denied!进入系统盘找到C:\\Windows\\System32\\cmd.exe（文件较多，可以快速搜索找到cmd.exe）右键以管理员身份运行 再次进入相应目录执行.2.mysql解压目录下没有my.ini配置文件mysqld: [ERROR] Found option without preceding group in config file D:\\mysql-5.7.22-win32\\my.ini at line 1!mysqld: [ERROR] Fatal error in defaults handling. Program aborted!3.弹出：由于找不到MSVCR120.dll,无法继续执行代码.重新安装程序可能会解决此问题！（未安装 vcredist 引起的）下载 vcredist 地址：链接: vcredist安装刚才下载的那个软件，位置默认即可（会有一个安装不成功，不影响），然后重新进行安装，成功解决这个问题！ 3.安装可视化文件MySQL workbench本文中安装的workbench的文件名为：mysql-workbench-community-6.3.10-winx64.msi可能会出现如下情况，系统缺少“Visual C++2015 Redistributable Package”。此时运行文件夹下的vc_进行安装。双击后点击next按钮，之后我们可以选择workbench的安装路径，这里我们使用默认路径，再点击next，因为workbench并不大，因此我们选择完全安装，点击next，进入安装界面，点击Install即可安装等待安装完成后，点击Finish即可完成安装。安装完成后我们打开workbench，点击Local instance MySQL，输入我们设置的MySQL密码即可连接数据库：数据库可视化界面如下： END","updated":"2020-07-23T07:20:53.242Z","categories":[{"name":"MySQL","slug":"MySQL","permalink":"http://yoursite.com/categories/MySQL/"}],"tags":[{"name":"数据库安装教程","slug":"数据库安装教程","permalink":"http://yoursite.com/tags/%E6%95%B0%E6%8D%AE%E5%BA%93%E5%AE%89%E8%A3%85%E6%95%99%E7%A8%8B/"}]},{"title":"pom.xml解析","date":"2020-07-23T06:13:29.000Z","path":"2020/07/23/pom-xml解析/","text":"Hello World! pom.xmlpom.xml文件是Maven进行工作的主要配置文件。在这个文件中我们可以配置Maven项目的groupId、artifactId和version等Maven项目必须的元素；可以配置Maven项目需要使用的远程仓库；可以定义Maven项目打包的形式；可以定义Maven项目的资源依赖关系等等。 pom.xml标签12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273 &lt;!--project是pom.xml的根元素，包含了一些约束的信息，比如xlms,xsi--&gt;&lt;project&gt; &lt;!--指定了当前pom的版本--&gt; &lt;modelVersion&gt;4.0.0&lt;/modelVersion&gt; &lt;!--maven2.0必须是这样写，现在是maven2唯一支持的版本--&gt; &lt;!-- 基础设置 --&gt; &lt;groupId&gt;反写公司的网址+项目名称&lt;/groupId&gt; &lt;artifactId&gt;项目名称+模块名&lt;/artifactId&gt; &lt;version&gt;当前项目版本号&lt;/version&gt; &lt;!-- 默认是jar，还可以打包成war/zip/pom--&gt; &lt;packaging&gt;...&lt;/packaging&gt; &lt;!-- 项目描述名，一般是写项目文档的时候才使用 --&gt; &lt;name&gt;...&lt;/name&gt; &lt;!-- 项目的地址--&gt; &lt;url&gt;...&lt;/url&gt; &lt;!-- 项目的描述 --&gt; &lt;description&gt;...&lt;/description&gt; &lt;!-- 开发人员的列表 --&gt; &lt;developers&gt;...&lt;/developers&gt; &lt;!-- 许可证的信息 --&gt; &lt;licenses&gt;...&lt;/licenses&gt; &lt;!-- 组织信息 --&gt; &lt;organization&gt;...&lt;/organization&gt; &lt;!-- 依赖列表，下面可以包含多个依赖项dependency--&gt; &lt;dependencies&gt; &lt;dependency&gt; &lt;!-- 指定坐标确定依赖项的位置 --&gt; &lt;groupId&gt;&lt;/groupId&gt; &lt;artifactId&gt;&lt;/artifactId&gt; &lt;version&gt;&lt;/version&gt; &lt;type&gt;&lt;/type&gt; &lt;!-- 依赖包的依赖范围--&gt; &lt;scope&gt;&lt;/scope&gt; &lt;!-- 这个标签只有true和false两个值，是用来设置依赖是否可选 --&gt; &lt;optional&gt;&lt;/optional&gt; &lt;!-- 排除依赖传递列表 --&gt; &lt;exclusions&gt; &lt;exclusion&gt; &lt;/exclusion&gt; &lt;/exclusions&gt; &lt;/dependency&gt; &lt;/dependencies&gt; &lt;!-- 依赖管理，里面包含多个依赖，但是它并不会被运行，即不会被引用到实际的依赖中--&gt; &lt;!--这个标签主要是用来定义在父模块中，供子模块继承用 --&gt; &lt;dependencyManagement&gt; &lt;dependencies&gt; &lt;dependency&gt; &lt;/dependency&gt; &lt;/dependencies&gt; &lt;/dependencyManagement&gt; &lt;!-- 常用于给构件的行为提供相应的支持 --&gt; &lt;build&gt; &lt;!-- 插件列表 --&gt; &lt;plugins&gt; &lt;plugin&gt; &lt;groupId&gt;&lt;/groupId&gt; &lt;artifactId&gt;&lt;/artifactId&gt; &lt;version&gt;&lt;/version&gt; &lt;/plugin&gt; &lt;/plugins&gt; &lt;/build&gt; &lt;!-- 用于在子模块中对父模块的pom的继承 --&gt; &lt;parent&gt;...&lt;/parent&gt; &lt;!-- 用来聚合多个模块，让多个模块进行编译，不用一个一个来 --&gt; &lt;modules&gt; &lt;module&gt; &lt;/module&gt; &lt;/modules&gt;&lt;/project&gt; 如： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117&lt;?xml version=\"1.0\" encoding=\"UTF-8\"?&gt;&lt;project xmlns=\"http://maven.apache.org/POM/4.0.0\" xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\" xsi:schemaLocation=\"http://maven.apache.org/POM/4.0.0 https://maven.apache.org/xsd/maven-4.0.0.xsd\"&gt; &lt;modelVersion&gt;4.0.0&lt;/modelVersion&gt; &lt;parent&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-parent&lt;/artifactId&gt; &lt;version&gt;2.3.0.RELEASE&lt;/version&gt; &lt;relativePath/&gt; &lt;!-- lookup parent from repository --&gt; &lt;/parent&gt; &lt;groupId&gt;com.dvms&lt;/groupId&gt; &lt;artifactId&gt;data_view&lt;/artifactId&gt; &lt;version&gt;0.0.1-SNAPSHOT&lt;/version&gt; &lt;name&gt;data_view&lt;/name&gt; &lt;description&gt;Demo project for Spring Boot&lt;/description&gt; &lt;properties&gt; &lt;java.version&gt;1.8&lt;/java.version&gt; &lt;/properties&gt; &lt;dependencies&gt; &lt;!--导入Thymeleaf依赖，基于3.x开发--&gt; &lt;dependency&gt; &lt;groupId&gt;org.thymeleaf&lt;/groupId&gt; &lt;artifactId&gt;thymeleaf-spring5&lt;/artifactId&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-web&lt;/artifactId&gt; &lt;/dependency&gt; &lt;!--导入springboot和mybatis依赖 包含mybatis的核心--&gt; &lt;dependency&gt; &lt;groupId&gt;org.mybatis.spring.boot&lt;/groupId&gt; &lt;artifactId&gt;mybatis-spring-boot-starter&lt;/artifactId&gt; &lt;version&gt;2.1.0&lt;/version&gt; &lt;/dependency&gt; &lt;!--导入druid依赖，基于3.x开发--&gt; &lt;dependency&gt; &lt;groupId&gt;com.alibaba&lt;/groupId&gt; &lt;artifactId&gt;druid&lt;/artifactId&gt; &lt;version&gt;1.1.22&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;mysql&lt;/groupId&gt; &lt;artifactId&gt;mysql-connector-java&lt;/artifactId&gt; &lt;scope&gt;runtime&lt;/scope&gt; &lt;/dependency&gt; &lt;!--导入lombok小辣椒驱动依赖,用来生成get/set方法依赖--&gt; &lt;dependency&gt; &lt;groupId&gt;org.projectlombok&lt;/groupId&gt; &lt;artifactId&gt;lombok&lt;/artifactId&gt; &lt;!--&lt;optional&gt;true&lt;/optional&gt;--&gt; &lt;version&gt;1.18.12&lt;/version&gt; &lt;scope&gt;provided&lt;/scope&gt;&lt;!--自动生成有参无参构造--&gt; &lt;/dependency&gt; &lt;!--热部署插件--&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-devtools&lt;/artifactId&gt; &lt;scope&gt;runtime&lt;/scope&gt; &lt;/dependency&gt; &lt;!--引入pagehelper分页插件--&gt; &lt;dependency&gt; &lt;groupId&gt;com.github.pagehelper&lt;/groupId&gt; &lt;artifactId&gt;pagehelper-spring-boot-starter&lt;/artifactId&gt; &lt;version&gt;1.2.10&lt;/version&gt; &lt;/dependency&gt; &lt;!--kaptcha 框架--&gt; &lt;dependency&gt; &lt;groupId&gt;com.github.penggle&lt;/groupId&gt; &lt;artifactId&gt;kaptcha&lt;/artifactId&gt; &lt;version&gt;2.3.2&lt;/version&gt; &lt;/dependency&gt; &lt;!--安全框架--&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-security&lt;/artifactId&gt; &lt;/dependency&gt; &lt;!--Thymeleaf整合security--&gt; &lt;dependency&gt; &lt;groupId&gt;org.thymeleaf.extras&lt;/groupId&gt; &lt;artifactId&gt;thymeleaf-extras-springsecurity5&lt;/artifactId&gt; &lt;version&gt;3.0.4.RELEASE&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-test&lt;/artifactId&gt; &lt;scope&gt;test&lt;/scope&gt; &lt;exclusions&gt; &lt;exclusion&gt; &lt;groupId&gt;org.junit.vintage&lt;/groupId&gt; &lt;artifactId&gt;junit-vintage-engine&lt;/artifactId&gt; &lt;/exclusion&gt; &lt;/exclusions&gt; &lt;/dependency&gt; &lt;/dependencies&gt; &lt;build&gt; &lt;plugins&gt; &lt;plugin&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-maven-plugin&lt;/artifactId&gt; &lt;configuration&gt; &lt;!--fork : 如果没有该项配置，devtools不会起作用，即应用不会restart --&gt; &lt;fork&gt;true&lt;/fork&gt; &lt;addResources&gt;true&lt;/addResources&gt; &lt;/configuration&gt; &lt;/plugin&gt; &lt;/plugins&gt; &lt;/build&gt;&lt;/project&gt; END","updated":"2020-07-23T07:20:42.201Z","categories":[{"name":"JavaWeb","slug":"JavaWeb","permalink":"http://yoursite.com/categories/JavaWeb/"}],"tags":[{"name":"pom.xml","slug":"pom-xml","permalink":"http://yoursite.com/tags/pom-xml/"}]},{"title":"Tomcat安装教程","date":"2020-07-23T06:13:28.000Z","path":"2020/07/23/Tomcat安装教程/","text":"Hello World! 1. 下载Tomcat首先确定你Windows系统是64位，还是32位(现在大部分是64位)及JDK版本（Tomcat在 JDK1.8 环境下能够正常运行）下载地址：Tomcat官网. 2. 安装Tomcat解压压缩包，放在想要放在的盘符(最好不要是C盘，可能会出现拒绝访问)如安装在D盘，那就解压出来放在D盘下就行，里面的文件名不要改动，或者放在D盘某一文件夹下，路径不要包含中文和特殊字符！ 3.配置环境变量在变量名中填写：CATALINA_HOME(不要留空格)变量值就是你解压后的路径，你可以直接进入解压后的文件夹，复制这个路径到变量值之后再找到系统变量中的Path，在最后面追加 %CATALINA_HOME%\\bin; 4.Tomcat启动和验证配置环境变量到你解压的tomcat文件夹下的bin目录中点击startup.bat之后出现了Tomcat的启动窗口之后验证环境变量是否配置成功，浏览器输入一下 http://localhost:8080 弹出页面：链接: http://localhost:8080 配置成功！！！END","updated":"2020-07-23T07:20:34.564Z","categories":[{"name":"JavaWeb","slug":"JavaWeb","permalink":"http://yoursite.com/categories/JavaWeb/"}],"tags":[{"name":"Tomcat","slug":"Tomcat","permalink":"http://yoursite.com/tags/Tomcat/"}]},{"title":"Tomcat入门学习","date":"2020-07-23T06:13:26.000Z","path":"2020/07/23/Tomcat入门学习/","text":"Hello World! TomcatTomcat 是由 Apache 开发的一个 Servlet 容器，实现了对 Servlet 和 JSP 的支持，并提供了作为Web服务器的一些特有功能，如Tomcat管理和控制平台、安全域管理和Tomcat阀等。由于 Tomcat 本身也内含了一个 HTTP 服务器，它也可以被视作一个单独的 Web 服务器。但是，不能将 Tomcat 和 Apache HTTP 服务器混淆，Apache HTTP 服务器是一个用 C 语言实现的 HTTP Web 服务器；这两个 HTTP web server 不是捆绑在一起的。Tomcat 包含了一个配置管理工具，也可以通过编辑XML格式的配置文件来进行配置。 Tomcat 重要目录/bin - Tomcat 脚本存放目录（如启动、关闭脚本）。 *.sh 文件用于 Unix 系统； *.bat 文件用于 Windows 系统;/conf - Tomcat 配置文件目录;/logs - Tomcat 默认日志目录;/webapps - webapp 运行的目录;web 工程发布目录结构 一般 web 项目路径结构|– webapp # 站点根目录 |– META-INF # META-INF 目录 | `– MANIFEST.MF # 配置清单文件 |-- WEB-INF # WEB-INF 目录 | |-- classes # class文件目录 | | |-- *.class # 程序需要的 class 文件 | | `-- *.xml # 程序需要的 xml 文件 | |-- lib # 库文件夹 | | `-- *.jar # 程序需要的 jar 包 | `-- web.xml # Web应用程序的部署描述文件 |-- &lt;userdir&gt; # 自定义的目录 |-- &lt;userfiles&gt; # 自定义的资源文件webapp：工程发布文件夹。其实每个 war 包都可以视为 webapp 的压缩包。 META-INF：META-INF 目录用于存放工程自身相关的一些信息，元文件信息，通常由开发工具，环境自动生成。 WEB-INF：Java web应用的安全目录。所谓安全就是客户端无法访问，只有服务端可以访问的目录。 /WEB-INF/classes：存放程序所需要的所有 Java class 文件。 /WEB-INF/lib：存放程序所需要的所有 jar 文件。 /WEB-INF/web.xml：web 应用的部署配置文件。它是工程中最重要的配置文件，它描述了 servlet 和组成应用的其它组件，以及应用初始化参数、安全管理约束等。 具体可参考：Tomcat 快速入门 END","updated":"2020-07-23T07:20:26.394Z","categories":[{"name":"JavaWeb","slug":"JavaWeb","permalink":"http://yoursite.com/categories/JavaWeb/"}],"tags":[{"name":"Tomcat","slug":"Tomcat","permalink":"http://yoursite.com/tags/Tomcat/"}]},{"title":"Java JDK安装及环境变量配置（windows）","date":"2020-07-23T06:13:24.000Z","path":"2020/07/23/Java-JDK安装及环境变量配置（windows）/","text":"Hello World! 1、JDK jre-8uxxx-windows-x64.exe 下载 所有平台： http://www.oracle.com/technetwork/java/javase/downloads/jdk8-downloads-2133151.html 选择 “Accept License Agreement” 根据系统选择对应的安装文件，64位系统安装64位JDK 2、JDK安装过程 a、双击运行安装文件 jdk-8uxxx-windows-x64.exe b、指定jdk安装目录 C:\\Java\\jdk1.8.0_xxx 然后点击“下一步” c、指定JRE安装目录 C:\\Java\\jre1.8.0_xxx，点击“下一步” d、安装完成，点击“关闭” 3、JDK 环境变量配置 a、新建 JAVA_HOME 环境变量，JAVA_HOME=C:\\Java\\jdk1.8.0_144 b、修改 path 环境变量，在path变量尾部添加%JAVA_HOME%\\bin c、新建 classpath 环境变量 ，classpath=.;%JAVA_HOME%\\lib;%JAVA_HOME%\\lib\\dt.jar;%JAVA_HOME%\\tools.jar 说明：（jdk 需要配置三个环境变量； 1.5之后可以不再设置classpath，但建议保留classpath设置） 开始菜单 -&gt; “计算机” -&gt; 右键 -&gt; 属性 打开 “系统面板”点击 “高级系统设置” 打开 “系统属性”窗口，点击 “环境变量” 打开“系统环境变量”窗格连续点击“确定”，完成环境变量配置。 4、验证 java 和 javac 命令 a、打开cmd命令行窗口，输入 java ，回车执行 b、输入javac 命令，回车执行 弹出以上java 和javac命令输出，则表明jdk安装配置成功！ END","updated":"2020-07-23T07:20:19.760Z","categories":[{"name":"Java","slug":"Java","permalink":"http://yoursite.com/categories/Java/"}],"tags":[{"name":"JDK安装教程","slug":"JDK安装教程","permalink":"http://yoursite.com/tags/JDK%E5%AE%89%E8%A3%85%E6%95%99%E7%A8%8B/"}]},{"title":"setTimeout()方法实现延时执行其他功能","date":"2020-07-23T04:10:30.000Z","path":"2020/07/23/setTimeout-方法实现延时执行其他功能/","text":"Hello World! setTimeout() 方法setTimeout() 方法用于在指定的毫秒数后调用函数或计算表达式。 提示： 1000 毫秒= 1 秒。提示： 如果想重复执行可以使用 setInterval() 方法。提示： 使用 clearTimeout() 方法来阻止函数的执行。 语法 12setTimeout(code, milliseconds, param1, param2, ...)setTimeout(function, milliseconds, param1, param2, ...) setTimeout()方法参数 描述 code/function 必要部分，要调用一个代码串，也可以是一个函数 milliseconds 必要部分，执行或调用 code/function 需要等待的时间，以毫秒计，默认为 0 param1, param2, … 非必要部分，传给执行函数的其他参数（IE9 及其更早版本不支持该参数） return： 返回一个 ID（数字），可以将这个ID传递给 clearTimeout() 来取消执行。 clearTimeout() 方法clearTimeout() 方法可取消由 setTimeout() 方法设置的定时操作。 clearTimeout() 方法的参数必须是由 setTimeout() 返回的 ID 值。注意: 要使用 clearTimeout() 方法, 在创建执行定时操作时要使用全局变量 语法 1clearTimeout(id_of_settimeout); clearTimeout() 方法参数 描述 d_of_setinterval 调用 setTimeout() 函数时所获得的返回值，使用该返回标识符作为参数，可以取消该 setTimeout() 所设定的定时执行操作 return： return 0 应用实例1.5秒（3000 毫秒）后弹出 “Hello JavaScript !” 123456789var myVar;function myFunction() &#123; myVar = setTimeout(alertFunc, 5000);&#125;function alertFunc() &#123; alert(\"Hello JavaScript!\");&#125; 2.打开一个新窗口，5秒后将该窗口关闭 12345function openWin() &#123; var myWindow = window.open(\"color=red\", \"\", \"width=1920, height=1080\"); myWindow.document.write(\"&lt;p&gt;打开一个新窗口&lt;/p&gt;\"); setTimeout(function()&#123; myWindow.close() &#125;, 5000);&#125; 3.计数器功能 123&lt;button onclick=\"startCount()\"&gt;开始计数&lt;/button&gt;&lt;input type=\"text\" id=\"test\"&gt;&lt;button onclick=\"stopCount()\"&gt;停止计数&lt;/button&gt; 点击 “开始计数” 按钮开始执行计数程序。输入框从 0 开始计算。 点击 “停止计数” 按钮停止后，可以再次点击 “开始计数” 按钮会重新开始计数。 123456789101112131415161718192021var c = 0;var t;var timer_is_on = 0;function timedCount() &#123; document.getElementById(\"test\").value = c; c = c + 1; t = setTimeout(function()&#123; timedCount() &#125;, 1000);&#125;function startCount() &#123; if (!timer_is_on) &#123; timer_is_on = 1; timedCount(); &#125;&#125;function stopCount() &#123; clearTimeout(t); timer_is_on = 0;&#125; 4.显示当前时间 12&lt;!--在页面加载时执行startTime()--&gt;&lt;body onload=\"startTime()\"&gt; 123456789101112131415161718function startTime() &#123; var today = new Date(); var h = today.getHours(); var m = today.getMinutes(); var s = today.getSeconds(); // 在 numbers&lt;10 的数字前加上 0 m = checkTime(m); s = checkTime(s); document.getElementById(\"txt\").innerHTML = h + \":\" + m + \":\" + s; var t = setTimeout(function()&#123; startTime() &#125;, 500);&#125;function checkTime(i) &#123; if (i &lt; 10) &#123; i = \"0\" + i; &#125; return i;&#125; 5.传递参数给 Animal函数 123456789101112131415var myVar;function myStartFunction() &#123; // IE9 及其更早版本不支持 myVar = setTimeout(Animal, 5000, \"Cat\", \"Dog\"); //使用匿名函数，则所有浏览器都支持 myVar = setTimeout(function()&#123; Animal(\"Cat\", \"Dog\"); &#125;, 5000);&#125;function Animal(param1, param2) &#123; document.getElementById(\"demo1\").innerHTML += \"Hello \"; document.getElementById(\"demo2\").innerHTML = \"传递给 Animal() 的参数: &lt;br&gt;\" + param1 + \"&lt;br&gt;\" + param2 + \"&lt;br&gt;\";&#125; END","updated":"2020-07-23T07:21:15.562Z","categories":[{"name":"JavaWeb","slug":"JavaWeb","permalink":"http://yoursite.com/categories/JavaWeb/"}],"tags":[{"name":"JavaWeb","slug":"JavaWeb","permalink":"http://yoursite.com/tags/JavaWeb/"},{"name":"setTimeout()","slug":"setTimeout","permalink":"http://yoursite.com/tags/setTimeout/"}]},{"title":"JavaScript匿名函数理解及应用","date":"2020-07-23T04:10:06.000Z","path":"2020/07/23/JavaScript匿名函数理解及应用/","text":"Hello World! 匿名函数匿名函数顾名思义就是没有名字的函数，在实际开发中经常会用到，也是JavaScript的重点。匿名函数又叫立即执行函数。 由于这种函数是匿名的，所以它不能被调用。由于它不能被调用，所以如果它不立即执行的话就没有了意义。由于它需要立即执行，所以在执行完之后匿名函数就会被销毁。匿名自执行函数的作用就是用于闭包和创建独立的命名空间两个方面。 匿名函数的基本形式为(function(){…})(); 前面的括号包含函数体，后面的括号就是给匿名函数传递参数然后立即执行。 匿名函数的作用是避免全局变量的污染以及函数名的冲突。 匿名自执行函数的作用 1.匿名自执行函数最常见的作用是用于实现闭包的情况中。闭包:闭包是JavaScript的一种特性，我们可以通过闭包实现函数内外部的连接，并且可以使得函数的局部变量始终存在于内存中。 2.匿名自执行函数还可以用于在JavaScript中模拟创建块级作用域.使用匿名自执行函数将某些代码包裹起来可以实现块级作用域的效果，减少全局变量的数量，在匿名自执行函数执行结束后变量就会被内存释放掉，从而也会节省了内存。 小括号包着函数的小括号的作用：小括号能把我们的表达式组合分块，并且每一块，也就是每一对小括号，都有一个返回值。这个返回值实际上也就是小括号中表达式的返回值。所以，当我们用一对小括号把匿名函数包起来的时，实际上小括号对返回的，就是一个匿名函数的Function 对象。因此，小括号对加上匿名函数就如同有名字的函数般被我们取得它的引用位置了。所以如果在这个引用变量后面再加上参数列表，就会实现普通函数的调用形式。 小括号有返回值，就是小括号内的函数或者表达式的返回值，所以小括号内的function返回值等于小括号的返回值。 写法匿名函数的写法1.先定义一个普通函数Cat() 1234function Cat()&#123; alert(\"喵喵喵~~\");&#125; 2.去掉函数的名字构建匿名函数不包裹一个括号不符合语法要求，会报错！需要给匿名函数外边包裹一个括号才能运行。 1234(function ()&#123; alert(\"喵喵喵~~\");&#125;)() //()可省略 3.当匿名函数需要传值，将参数写到括号内 1234!(function (data)&#123; alert(\"喵喵喵~~\"+data);&#125;)(\"汪汪汪~~\") 4种实现方式 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253//常见匿名函数： //1，匿名函数的第一种实现方式 (function(cat)&#123; alert(cat); &#125;)(\"喵喵喵~~\"); //2.匿名自执行函数的第二种实现方式（常用）jQuery (function()&#123; alert(\"cat\"); &#125;()); //3.匿名自执行函数的第三种实现方式 !function(cat)&#123; alert(cat); &#125;(\"喵喵喵~~\"); //4.匿名自执行函数的第四种实现方式 var fun=function(cat)&#123; alert(cat); &#125;(\"喵喵喵~~\");//不常见匿名函数： ~(function()&#123; alert('cat'); &#125;)(); //效率最高 void function()&#123; alert('cat'); &#125;(); +function()&#123; alert('cat'); &#125;(); -function()&#123; alert('cat'); &#125;(); ~function()&#123; alert('cat'); &#125;(); !function()&#123; alert('cat'); &#125;(); //强制执行 (function()&#123; alert('cat'); &#125;()); 匿名函数的应用1.绑定事件 1234567&lt;input type=\"button\" value=\"点击\" id=\"btn\"&gt;```javascriptvar btn=document.querySelector(\"#btn\"); //querySelector是H5中新增的查找dom元素的方法 btn.οnclick=function()&#123; alert(\"\"); &#125; 2.应用对象 123456789101112131415var obj=&#123; animal:\"汤姆猫\", voice:\"喵喵喵~~\", CAT:function()&#123; return \"我是\"+this.animal+\"，我会\"+this.voice+\"叫！\"; &#125;&#125;;alert(obj.CAT()); 3.应用函数表达式 1234567//将匿名函数赋值给变量catvar cat=function()&#123; return \"喵喵喵~~\"&#125;//调用方式与调用普通函数一样alert(cat()); 4、回调函数的应用 1234setInterval(function()&#123; console.log(\"我是每5秒执行一次的回调函数\");&#125;,5000); 5、返回值 123456789101112function cat()&#123; //返回匿名函数 return function()&#123; return \"喵喵喵~~\"; &#125;&#125;//调用匿名函数alert(cat()());//或var mao=cat();alert(mao()); 6.链式调用 1234567(function(animal) &#123; alert(animal); return arguments.callee; &#125;)('cat')('dog')('pig'); END","updated":"2020-07-23T07:21:55.833Z","categories":[{"name":"JavaWeb","slug":"JavaWeb","permalink":"http://yoursite.com/categories/JavaWeb/"}],"tags":[{"name":"JavaWeb","slug":"JavaWeb","permalink":"http://yoursite.com/tags/JavaWeb/"},{"name":"js","slug":"js","permalink":"http://yoursite.com/tags/js/"}]},{"title":"聚光灯效果（css+html）","date":"2020-07-23T04:09:53.000Z","path":"2020/07/23/聚光灯效果（css-html）/","text":"Hello World! 最终效果： 实现code: 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657&lt;!DOCTYPE html&gt;&lt;html&gt; &lt;head&gt; &lt;meta charset=\"utf-8\"&gt; &lt;title&gt;聚光灯效果&lt;/title&gt; &lt;style&gt; *&#123; margin:0; padding:0; &#125; body&#123; background: #222; display: flex; justify-content: center; align-items: center; min-height: 100vh; &#125; h1&#123; color: #333; font-size: 8rem; position: relative; &#125; h1:after&#123; content: \"Hello JavaScript\"; color: transparent; position: absolute; left: 0; top: 0; background: -webkit-linear-gradient(left,#c23616,#192a56,#00d2d3,yellow,#6D214F,#2e86de,#4cd137,#e84118); background-clip: text; -webkit-background-clip:text; clip-path: circle(100px at 0% 50%); -webkit-clip-path: circle(100px at 0% 50%); animation: light 5s infinite; &#125; @keyframes light&#123; 0%&#123; clip-path: circle(100px at 0% 50%); -webkit-clip-path: circle(100px at 0% 50%); &#125; 50%&#123; clip-path: circle(100px at 100% 50%); -webkit-clip-path: circle(100px at 100% 50%); &#125; 100%&#123; clip-path: circle(100px at 0% 50%); -webkit-clip-path: circle(100px at 0% 50%); &#125; &#125; &lt;/style&gt; &lt;/head&gt; &lt;body&gt; &lt;div&gt;&lt;h1&gt;Hello JavaScript&lt;/h1&gt;&lt;/div&gt; &lt;/body&gt;&lt;/html&gt; END","updated":"2020-07-23T07:21:37.401Z","categories":[],"tags":[{"name":"JavaWeb","slug":"JavaWeb","permalink":"http://yoursite.com/tags/JavaWeb/"},{"name":"HTML","slug":"HTML","permalink":"http://yoursite.com/tags/HTML/"}]},{"title":"界面开发工具之HTML色彩表格工具","date":"2020-07-23T04:09:01.000Z","path":"2020/07/23/界面开发工具之HTML色彩表格工具-1/","text":"Hello World! 网址链接： HTML色彩表格工具 HTML色彩代码理论HTML代码格式：每一个HTML代码包含有“#”符号以及6个字幕和数字。这些数字都是十六进制的。比如“FF”在十六进制中代表十进制的数字255。 符号意义：HTML色彩代码中前两个符号表示红色的浓度。00指的是颜色最淡而FF则指的是颜色最浓。第三个和第四个符号表示绿色的浓度，第五个和第六个符号表示蓝色的浓度。由此，将各种浓度的红、绿、蓝三种颜色进行组合，我们可以调配出任何所需色彩 示例：#FF0000 - 利用这个HTML代码，我们让浏览器显示不掺杂任何绿色和蓝色成分的最鲜艳的红色。其结果当然就是纯红: #00FF00 - 这个HTML代码表示只有绿色且不掺杂任何红色和蓝色。其结果是: #0000FF - 这个HTML代码表示只有蓝色且不掺杂任何红色和绿色。其结果是: #FFFF00 - 红绿组合生成黄色: #CCEEFF - 一些红色、一点绿色以及最高浓度的蓝色，组合成天蓝色: END","updated":"2020-07-23T07:21:44.329Z","categories":[],"tags":[{"name":"JavaWeb","slug":"JavaWeb","permalink":"http://yoursite.com/tags/JavaWeb/"},{"name":"工具","slug":"工具","permalink":"http://yoursite.com/tags/%E5%B7%A5%E5%85%B7/"},{"name":"HTML","slug":"HTML","permalink":"http://yoursite.com/tags/HTML/"}]},{"title":"自动生成注释作者名字和日期等信息（IDEA Java类）","date":"2020-07-23T04:08:59.000Z","path":"2020/07/23/自动生成注释作者名字和日期等信息（IDEA-Java类）/","text":"Hello World! My Environment IDEA2018.3 JDK1.8 最终效果在创建java类后，自动生成定制的注释： 设置过程点击File-&gt;Settings-&gt;Editor-&gt;File and Code Templates在File Header中输入想要设置的信息如： 123456/**文件名: $&#123;NAME&#125;*创建者: your name*创建时间:$&#123;DATE&#125; $&#123;TIME&#125;*描述: 这是一个示例*/ 当然也可以参考下方的Description选择自己想要设置的完成创建时自动注释。|注释设置| 描述 ||–|–|| ${PACKAGE_NAME} | name of the package in which the new file is created || ${USER} | 创建者名称 || ${DATE} |当前日期 ||${TIME} | 当前时间 || ${YEAR} | 年 ||${MONTH} 月| || ${MONTH_NAME_SHORT} | 月缩写 || ${MONTH_NAME_FULL} |月全称 || ${DAY} | 天 || ${HOUR} | 时 || ${MINUTE} |分 || ${PROJECT_NAME} | 工程名 | END","updated":"2020-07-23T07:21:30.382Z","categories":[{"name":"JavaWeb","slug":"JavaWeb","permalink":"http://yoursite.com/categories/JavaWeb/"}],"tags":[{"name":"JavaWeb","slug":"JavaWeb","permalink":"http://yoursite.com/tags/JavaWeb/"},{"name":"Java","slug":"Java","permalink":"http://yoursite.com/tags/Java/"}]},{"title":"JavaWeb开发免费后台Html样式模板","date":"2020-07-23T04:08:57.000Z","path":"2020/07/23/JavaWeb开发免费后台Html样式模板/","text":"Hello World! 后台Html样式模板免费模板网（www.freemoban.com）提供大量的免费网站HTML网页模板,企业/响应式/自适应等免费网站模板源码，可以任意下载安装测试使用。链接: 免费模板 END","updated":"2020-07-23T07:21:21.894Z","categories":[{"name":"JavaWeb","slug":"JavaWeb","permalink":"http://yoursite.com/categories/JavaWeb/"}],"tags":[{"name":"JavaWeb","slug":"JavaWeb","permalink":"http://yoursite.com/tags/JavaWeb/"},{"name":"工具","slug":"工具","permalink":"http://yoursite.com/tags/%E5%B7%A5%E5%85%B7/"}]},{"title":"setInterval()方法实现周期调用函数来完成进度条等功能设计","date":"2020-07-23T04:08:22.000Z","path":"2020/07/23/setInterval-方法实现周期调用函数来完成进度条等功能设计/","text":"Hello World! setInterval() 方法setInterval() 方法可按照指定的周期（以毫秒计）来调用函数或计算表达式。一般与clearInterval()配合使用。 setInterval() 方法会不停地调用函数，直到==clearInterval() 被调用或窗口被关闭==。由 setInterval() 返回的 ID 值可用作 clearInterval() 方法的参数。提示： 1000 毫秒= 1 秒；如果你只想执行一次可以使用 setTimeout() 方法。 语法描述： 12setInterval(code, milliseconds);setInterval(function, milliseconds, param1, param2, ...) setInterval() 方法参数 描述 code/function 必要部分，要调用一个代码串，也可以是一个函数 milliseconds 必要部分，周期性执行或调用 code/function 之间的时间间隔，以毫秒计 param1, param2, … 非必要部分，传给执行函数的其他参数（IE9 及其更早版本不支持该参数） return:返回一个 ID（数字），可以将这个ID传递给clearInterval()，clearTimeout() 来取消执行setInterval() 。 clearInterval() 方法clearInterval() 方法可取消由 setInterval() 函数设定的定时执行操作。 clearInterval() 方法的参数必须是由 setInterval() 返回的 ID 值。注意: 要使用 clearInterval() 方法, 在创建执行定时操作时要使用==全局变量== 语法描述：|clearInterval() 方法| 描述 ||–|–||id_of_setinterval |必要部分，调用 setInterval() 函数时所获得的返回值，使用该返回标识符作为参数，可以取消该 setInterval() 所设定的定时执行操作 |return: return 0 方法应用实例1.显示当前时间( setInterval() 方法会每秒执行一次函数，类似手表功能) 12345678# 显示当前时间( setInterval() 方法会每秒执行一次函数，类似手表功能):var myVar = setInterval(function()&#123; myTimer() &#125;, 1000); function myTimer() &#123; var d = new Date(); var t = d.toLocaleTimeString(); document.getElementById(\"demo\").innerHTML = t;&#125; 2.使用 clearInterval() 来停止 setInterval 的执行 1234567891011var myVar = setInterval(function()&#123; myTimer() &#125;, 1000);function myTimer() &#123; var d = new Date(); var t = d.toLocaleTimeString(); document.getElementById(\"demo\").innerHTML = t;&#125;function myStopFunction() &#123; clearInterval(myVar);&#125; 3.使用 setInterval() 和 clearInterval()来创建动态进度条在javaweb中通过AJAX的get()方法和windows对象的setInterval()方法不断读取当前进度值来实现页面进度值的实时显示。 12345678910111213function move() &#123; var elem = document.getElementById(\"myBar\"); var width = 0; var myvar = setInterval(frame, 10); function frame() &#123; if (width == 100) &#123; clearInterval(myvar); &#125; else &#123; width++; elem.style.width = width + '%'; &#125; &#125;&#125; 4.每 5000 毫秒切换背景颜色 12345678910var myVar = setInterval(function()&#123; setColor() &#125;, 5000); function setColor() &#123; var x = document.body; x.style.backgroundColor = x.style.backgroundColor == \"red\" ? \"green\" : \"red\"; //x.style.backgroundColor = white&#125; function stopColor() &#123; clearInterval(myVar);&#125; ? : 是一个条件运算符,是一个整体,作用类似于if else 语句5.传递参数给 Animal 函数 12345678910111213141516171819var myVar;function myStartFunction() &#123; // IE9 及其更早版本不支持 myVar = setInterval(Animal, 2000, \"Cat\", \"Dog\"); //使用匿名函数，则所有浏览器都支持 myVar = setInterval(function()&#123; Animal(\"Cat\", \"Dog\"); &#125;, 2000);&#125;function Animal(param1, param2) &#123; document.getElementById(\"demo\").innerHTML += \"Animal \"; document.getElementById(\"demo2\").innerHTML = \"传递给 Animal() 的参数: &lt;br&gt;\" + param1 + \"&lt;br&gt;\" + param2 + \"&lt;br&gt;\";&#125;function myStopFunction() &#123; clearInterval(myVar);&#125; END","updated":"2020-07-23T07:22:01.946Z","categories":[{"name":"JavaWeb","slug":"JavaWeb","permalink":"http://yoursite.com/categories/JavaWeb/"}],"tags":[{"name":"JavaWeb","slug":"JavaWeb","permalink":"http://yoursite.com/tags/JavaWeb/"},{"name":"js","slug":"js","permalink":"http://yoursite.com/tags/js/"}]},{"title":"js中confirm弹框的确定按钮失效或无法传值解决办法","date":"2020-07-23T04:08:20.000Z","path":"2020/07/23/js中confirm弹框的确定按钮失效或无法传值解决办法/","text":"Hello World! 1.在项目中出现confirm弹框按钮失效，无法传布尔值，如果正常的话，使用以下代码即可完成传值： 1234567var result = window.confirm('是否XXXX?'); if (result == true)&#123; alert('终止操作！'); result = false; &#125;else&#123; alert('终止操作取消！'); result = false;&#125; 2.但是这个弹框中的按钮失效了，只能基于bootstrap重新创建一下，可以参考以下这种，直接在js中插入这段代码(亲测有效）： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150$(function () &#123;window.Ewin = function () &#123; var html = '&lt;div id=\"[Id]\" class=\"modal fade\" role=\"dialog\" aria-labelledby=\"modalLabel\"&gt;' + '&lt;div class=\"modal-dialog modal-sm\"&gt;' + '&lt;div class=\"modal-content\"&gt;' + '&lt;div class=\"modal-header\"&gt;' + '&lt;button type=\"button\" class=\"close\" data-dismiss=\"modal\"&gt;&lt;span aria-hidden=\"true\"&gt;×&lt;/span&gt;&lt;span class=\"sr-only\"&gt;Close&lt;/span&gt;&lt;/button&gt;' + '&lt;h4 class=\"modal-title\" id=\"modalLabel\"&gt;[Title]&lt;/h4&gt;' + '&lt;/div&gt;' + '&lt;div class=\"modal-body\"&gt;' + '&lt;p&gt;[Message]&lt;/p&gt;' + '&lt;/div&gt;' + '&lt;div class=\"modal-footer\"&gt;' + '&lt;button type=\"button\" class=\"btn btn-default cancel\" data-dismiss=\"modal\"&gt;[BtnCancel]&lt;/button&gt;' + '&lt;button type=\"button\" class=\"btn btn-primary ok\" data-dismiss=\"modal\"&gt;[BtnOk]&lt;/button&gt;' + '&lt;/div&gt;' + '&lt;/div&gt;' + '&lt;/div&gt;' + '&lt;/div&gt;'; var dialogdHtml = '&lt;div id=\"[Id]\" class=\"modal fade\" role=\"dialog\" aria-labelledby=\"modalLabel\"&gt;' + '&lt;div class=\"modal-dialog\"&gt;' + '&lt;div class=\"modal-content\"&gt;' + '&lt;div class=\"modal-header\"&gt;' + '&lt;button type=\"button\" class=\"close\" data-dismiss=\"modal\"&gt;&lt;span aria-hidden=\"true\"&gt;×&lt;/span&gt;&lt;span class=\"sr-only\"&gt;Close&lt;/span&gt;&lt;/button&gt;' + '&lt;h4 class=\"modal-title\" id=\"modalLabel\"&gt;[Title]&lt;/h4&gt;' + '&lt;/div&gt;' + '&lt;div class=\"modal-body\"&gt;' + '&lt;/div&gt;' + '&lt;/div&gt;' + '&lt;/div&gt;' + '&lt;/div&gt;'; var reg = new RegExp(\"\\\\[([^\\\\[\\\\]]*?)\\\\]\", 'igm'); var generateId = function () &#123; var date = new Date(); return 'mdl' + date.valueOf(); &#125; var init = function (options) &#123; options = $.extend(&#123;&#125;, &#123; title: \"操作提示\", message: \"提示内容\", btnok: \"确定\", btncl: \"取消\", width: 200, auto: false &#125;, options || &#123;&#125;); var modalId = generateId(); var content = html.replace(reg, function (node, key) &#123; return &#123; Id: modalId, Title: options.title, Message: options.message, BtnOk: options.btnok, BtnCancel: options.btncl &#125;[key]; &#125;); $('body').append(content); $('#' + modalId).modal(&#123; width: options.width, backdrop: 'static' &#125;); $('#' + modalId).on('hide.bs.modal', function (e) &#123; $('body').find('#' + modalId).remove(); &#125;); return modalId; &#125; return &#123; alert: function (options) &#123; if (typeof options == 'string') &#123; options = &#123; message: options &#125;; &#125; var id = init(options); var modal = $('#' + id); modal.find('.ok').removeClass('btn-success').addClass('btn-primary'); modal.find('.cancel').hide(); return &#123; id: id, on: function (callback) &#123; if (callback &amp;&amp; callback instanceof Function) &#123; modal.find('.ok').click(function () &#123; callback(true); &#125;); &#125; &#125;, hide: function (callback) &#123; if (callback &amp;&amp; callback instanceof Function) &#123; modal.on('hide.bs.modal', function (e) &#123; callback(e); &#125;); &#125; &#125; &#125;; &#125;, confirm: function (options) &#123; var id = init(options); var modal = $('#' + id); modal.find('.ok').removeClass('btn-primary').addClass('btn-success'); modal.find('.cancel').show(); return &#123; id: id, on: function (callback) &#123; if (callback &amp;&amp; callback instanceof Function) &#123; modal.find('.ok').click(function () &#123; callback(true); &#125;); modal.find('.cancel').click(function () &#123; callback(false); &#125;); &#125; &#125;, hide: function (callback) &#123; if (callback &amp;&amp; callback instanceof Function) &#123; modal.on('hide.bs.modal', function (e) &#123; callback(e); &#125;); &#125; &#125; &#125;; &#125;, dialog: function (options) &#123; options = $.extend(&#123;&#125;, &#123; title: 'title', url: '', width: 800, height: 550, onReady: function () &#123; &#125;, onShown: function (e) &#123; &#125; &#125;, options || &#123;&#125;); var modalId = generateId(); var content = dialogdHtml.replace(reg, function (node, key) &#123; return &#123; Id: modalId, Title: options.title &#125;[key]; &#125;); $('body').append(content); var target = $('#' + modalId); target.find('.modal-body').load(options.url); if (options.onReady()) options.onReady.call(target); target.modal(); target.on('shown.bs.modal', function (e) &#123; if (options.onReady(e)) options.onReady.call(target, e); &#125;); target.on('hide.bs.modal', function (e) &#123; $('body').find(target).remove(); &#125;); &#125; &#125; &#125;();&#125; 调用的话，在当前js中需要应用的按钮绑定的功能函数中进行调用： 1234567//e为布尔值Ewin.confirm(&#123; message: \"是否确认XXX？\" &#125;).on(function (e) &#123;if (e) &#123;alert('终止操作！'); //e=true&#125;else&#123;alert('终止操作取消！');&#125; //e!=true&#125;); 效果图（且对页面内容有遮罩层）： 1Ewin.alert(\"操作成功！\"); balabala… END","updated":"2020-07-23T07:21:50.032Z","categories":[{"name":"JavaWeb","slug":"JavaWeb","permalink":"http://yoursite.com/categories/JavaWeb/"}],"tags":[{"name":"JavaWeb","slug":"JavaWeb","permalink":"http://yoursite.com/tags/JavaWeb/"},{"name":"js","slug":"js","permalink":"http://yoursite.com/tags/js/"}]},{"title":"界面开发工具之HTML色彩表格工具","date":"2020-07-23T04:08:16.000Z","path":"2020/07/23/界面开发工具之HTML色彩表格工具/","text":"Hello World! 网址链接： HTML色彩表格工具 HTML色彩代码理论HTML代码格式：每一个HTML代码包含有“#”符号以及6个字幕和数字。这些数字都是十六进制的。比如“FF”在十六进制中代表十进制的数字255。 符号意义：HTML色彩代码中前两个符号表示红色的浓度。00指的是颜色最淡而FF则指的是颜色最浓。第三个和第四个符号表示绿色的浓度，第五个和第六个符号表示蓝色的浓度。由此，将各种浓度的红、绿、蓝三种颜色进行组合，我们可以调配出任何所需色彩 示例：#FF0000 - 利用这个HTML代码，我们让浏览器显示不掺杂任何绿色和蓝色成分的最鲜艳的红色。其结果当然就是纯红: #00FF00 - 这个HTML代码表示只有绿色且不掺杂任何红色和蓝色。其结果是: #0000FF - 这个HTML代码表示只有蓝色且不掺杂任何红色和绿色。其结果是: #FFFF00 - 红绿组合生成黄色: #CCEEFF - 一些红色、一点绿色以及最高浓度的蓝色，组合成天蓝色: END","updated":"2020-07-23T07:21:09.281Z","categories":[],"tags":[]},{"title":"PageHelper分页插件的整合与项目应用","date":"2020-07-22T11:31:56.000Z","path":"2020/07/22/PageHelper分页插件的整合与项目应用/","text":"Hello World! MyBatis 分页插件 PageHelper链接: PageHelper官网.分页插件支持任何复杂的单表、多表分页； 分页结果（结合了一点BootStrap）： My Environment IDEA2018.3 JDK1.8 SpringBoot2.3.0 360浏览器 Springboot整合PageHelper插件1. pom.xml引入PageHelper依赖123456&lt;!--引入pagehelper分页插件--&gt; &lt;dependency&gt; &lt;groupId&gt;com.github.pagehelper&lt;/groupId&gt; &lt;artifactId&gt;pagehelper-spring-boot-starter&lt;/artifactId&gt; &lt;version&gt;1.2.10&lt;/version&gt; &lt;/dependency&gt; 2. 配置application.properties/application.ymlapplication.properties: 12345# pagehelper分页插件配置pagehelper.helperDialect=mysqlpagehelper.reasonable=truepagehelper.supportMethodsArguments=truepagehelper.params=count=countSql application.yml: 123456# pagehelper分页插件配置pagehelper: helperDialect: mysql reasonable: true supportMethodsArguments: true pageSizeZero: false #pageSize=0 有关分页插件的基本配置就完成了（当然其他必要的基本配置也需要提前配置好）;也可以直接参考官网链接: 使用文档. SpringBoot结合Thymeleaf实现分页首先我们需要写一个查询数据库然后展示到前端界面的各层代码：Entity类： 12345678910111213141516171819202122232425package com.cjw.entity;import lombok.AllArgsConstructor;import lombok.NoArgsConstructor;import lombok.ToString;import lombok.Data;import lombok.experimental.Accessors;import java.util.Date;@Data@ToString@AllArgsConstructor@NoArgsConstructor@Accessors(chain = true) //链式调用public class Emp &#123; private String id; private String name; private Double salary; private Integer age; private Date bir;&#125; Dao层接口： 12345678910111213package com.cjw.dao;import com.cjw.entity.Emp;import org.springframework.stereotype.Repository;import java.util.List;@Repositorypublic interface EmpDao &#123; List&lt;Emp&gt; findAll();&#125; 数据库Mapper.xml文件： 1234567891011&lt;?xml version=\"1.0\" encoding=\"UTF-8\" ?&gt;&lt;!DOCTYPE mapper PUBLIC \"-//mybatis.org//DTD Mapper 3.0//EN\" \"http://mybatis.org/dtd/mybatis-3-mapper.dtd\"&gt;&lt;mapper namespace=\"com.cjw.dao.EmpDao\"&gt; &lt;!--查询所有--&gt; &lt;select id=\"findAll\" resultType=\"Emp\"&gt; select id,name,salary,age,bir from t_emp &lt;/select&gt;&lt;/mapper&gt; 服务层及其实现层： 123456789package com.cjw.service;import com.cjw.entity.Emp;import java.util.List;public interface EmpService &#123; List&lt;Emp&gt; findAll();&#125; 1234567891011121314151617181920212223package com.cjw.service.Impl;import com.cjw.dao.EmpDao;import com.cjw.entity.Emp;import com.cjw.service.EmpService;import org.springframework.beans.factory.annotation.Autowired;import org.springframework.stereotype.Service;import java.util.List;import java.util.UUID;@Servicepublic class EmpServiceImpl implements EmpService &#123; @Autowired private EmpDao empDao; @Override public List&lt;Emp&gt; findAll() &#123; return empDao.findAll(); &#125;&#125; 然后只需要在控制层中使用分页插件进行替换，并用model返回至前端：控制层： 12345678910111213141516171819@Controllerpublic class EmpController &#123; @Autowired private EmpService empService; @GetMapping(\"emp/findAll\") public String findAll(@RequestParam(defaultValue = \"1\") int pageNum, @RequestParam(defaultValue = \"5\") int pageSize, Model model)&#123; PageHelper.startPage(pageNum,pageSize);//关键 PageInfo&lt;Emp&gt; pageInfo = new PageInfo&lt;&gt;(empService.findAll()); model.addAttribute(\"pageInfo\",pageInfo);// List&lt;Emp&gt; emps = empService.findAll();// model.addAttribute(\"emps\",emps); return \"ems/emplist\"; &#125; 前端Html: 123456789101112131415161718192021222324252627282930313233343536373839404142434445&lt;table class=\"table\"&gt; &lt;tr class=\"table_header\"&gt; &lt;td&gt; ID &lt;/td&gt; &lt;td&gt; 用户名 &lt;/td&gt; &lt;td&gt; 收入 &lt;/td&gt; &lt;td&gt; 年龄 &lt;/td&gt; &lt;td&gt; 生日 &lt;/td&gt; &lt;td&gt; 操作 &lt;/td&gt; &lt;/tr&gt;&lt;tr th:class=\"$&#123;rowstate.odd&#125;?'row1':'row2'\" th:each=\"emp,rowstate:$&#123;pageInfo.list&#125;\" &gt; &lt;td&gt; &lt;span th:text=\"$&#123;emp.id&#125;\"&gt;&lt;/span&gt; &lt;/td&gt; &lt;td&gt; &lt;span th:text=\"$&#123;emp.name&#125;\"&gt;&lt;/span&gt; &lt;/td&gt; &lt;td&gt; &lt;span th:text=\"$&#123;emp.salary&#125;\"&gt;&lt;/span&gt; &lt;/td&gt; &lt;td&gt; &lt;span th:text=\"$&#123;emp.age&#125;\"&gt;&lt;/span&gt; &lt;/td&gt; &lt;td&gt; &lt;span th:text=\"$&#123;#dates.format(emp.bir,'yyyy-MM-dd')&#125;\"&gt;&lt;/span&gt; &lt;/td&gt; &lt;td&gt; &lt;!--&lt;a th:href=\"@&#123;/toSave&#125;\"&gt;新增&lt;/a&gt;&amp;nbsp;--&gt; &lt;a th:href=\"@&#123;/emp/update(id=$&#123;emp.id&#125;)&#125;\"&gt;更改&lt;/a&gt;&amp;nbsp; &lt;a th:href=\"@&#123;/emp/delete(id=$&#123;emp.id&#125;)&#125;\"&gt;删除&lt;/a&gt; &lt;/td&gt; &lt;/tr&gt; &lt;/table&gt; 分页部分： 12345678910111213&lt;div class=\"modal-footer no-margin-top\"&gt; &lt;ul class=\"pagination pagination-lg\"&gt; &lt;li class=\"page-item\"&gt;&lt;a class=\"page-link\"&gt;&lt;span&gt;当前页为：&lt;/span&gt;&lt;span th:text=\"第+$&#123;pageInfo.pageNum&#125;+页\"&gt;&lt;/span&gt;&lt;/a&gt;&lt;/li&gt; &lt;!--&lt;li class=\"page-item\"&gt;&lt;a class=\"page-link\" th:href=\"@&#123;/emp/findAll&#125;\"&gt;首页&lt;/a&gt;&lt;/li&gt;--&gt; &lt;li&gt;&lt;a th:href=\"@&#123;/emp/findAll?pageNum=0&#125;\"&gt;首页&lt;/a&gt;&lt;/li&gt; &lt;li class=\"page-item\"&gt;&lt;a class=\"page-link\" th:href=\"@&#123;/emp/findAll(pageNum=1)&#125;\"&gt;1&lt;/a&gt;&lt;/li&gt; &lt;li class=\"page-item\"&gt;&lt;a class=\"page-link\" th:href=\"@&#123;/emp/findAll(pageNum=2)&#125;\"&gt;2&lt;/a&gt;&lt;/li&gt; &lt;li class=\"page-item\"&gt;&lt;a class=\"page-link\" th:href=\"@&#123;/emp/findAll(pageNum=3)&#125;\"&gt;3&lt;/a&gt;&lt;/li&gt; &lt;li class=\"page-item\"&gt;&lt;a class=\"page-link\" th:href=\"@&#123;/emp/findAll(pageNum=$&#123;pageInfo.getNextPage()&#125;)&#125;\"&gt;下一页&lt;/a&gt;&lt;/li&gt; &lt;li class=\"page-item\"&gt;&lt;a class=\"page-link\"&gt;&lt;span th:text=\"共+$&#123;pageInfo.pageSize&#125;+页\"&gt;&lt;/span&gt;&lt;/a&gt;&lt;/li&gt; &lt;/ul&gt; &lt;/div&gt; END","updated":"2020-07-23T07:20:59.794Z","categories":[{"name":"SpringBoot","slug":"SpringBoot","permalink":"http://yoursite.com/categories/SpringBoot/"}],"tags":[{"name":"SpringBoot","slug":"SpringBoot","permalink":"http://yoursite.com/tags/SpringBoot/"},{"name":"PageHelper","slug":"PageHelper","permalink":"http://yoursite.com/tags/PageHelper/"}]},{"title":"SpringBoot项目热部署生效方法","date":"2020-07-22T11:31:36.000Z","path":"2020/07/22/SpringBoot项目热部署生效方法/","text":"Hello World! My Environment IDEA2018.3 JDK1.8 SpringBoot2.3.0 360浏览器 Springboot提供了热部署的方式，当发现有任何类发生了改变，马上通过JVM类加载的方式，加载最新的类到虚拟机中。 这样就不必重启也能看到改动后的效果了，只需在浏览器刷新页面即可更新显示内容，不需要再重启整个项目工程，提高了开发效率。 如果前端使用了thymeleaf，那么在properties或yml中配置关闭thymeleaf缓存： 1spring.thymeleaf.cache=false 如果修改的只是页面会自动刷新，如果是java类文件需要手动点击工具栏的build–&gt;Build-&gt;Modules ‘myProject’. Springboot版本也有可能导致热部署配置失败 1. pom.xml在pom文件中，引入如下依赖： 123456&lt;!--热部署插件--&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-devtools&lt;/artifactId&gt; &lt;scope&gt;runtime&lt;/scope&gt; &lt;/dependency&gt; 后，在插件中配置按如下配置： 12345678910111213&lt;build&gt; &lt;plugins&gt; &lt;plugin&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-maven-plugin&lt;/artifactId&gt; &lt;configuration&gt; &lt;!--fork : 必须配置，否则热部署不会生效，应用不会重置 --&gt; &lt;fork&gt;true&lt;/fork&gt; &lt;addResources&gt;true&lt;/addResources&gt; &lt;/configuration&gt; &lt;/plugin&gt; &lt;/plugins&gt; &lt;/build&gt; 或者直接在依赖中配置： 12345&lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-devtools&lt;/artifactId&gt; &lt;optional&gt;true&lt;/optional&gt; &lt;!--true时热部署生效 --&gt;&lt;/dependency&gt; 打开maven仓库查看配置和依赖是否引入完成。 2. IDEA中配置File中Settings打开顶部工具栏 File -&gt; Settings -&gt; Default Settings -&gt; Build -&gt; Compiler 然后勾选 Build project automatically 如下图所示：后点击Help中的Find Action —&gt;（Ctrl + Shift + A）后在搜索栏中输入Registry查找：点击确定后，勾选 Compiler autoMake allow when app running后保存设置： 3. 浏览器中配置打开浏览器按Fn + F12进入审查元素，选择Network后勾选【✅】Disable cache ： 确保以上均已完成配置，那么===================================================项目热部署配置完成，重新编译启动工程修改IDEA工程代码后刷新浏览器，不用再重新启动工程了! END","updated":"2020-07-23T07:18:55.927Z","categories":[{"name":"SpringBoot","slug":"SpringBoot","permalink":"http://yoursite.com/categories/SpringBoot/"}],"tags":[{"name":"热部署","slug":"热部署","permalink":"http://yoursite.com/tags/%E7%83%AD%E9%83%A8%E7%BD%B2/"}]},{"title":"Maven仓库导包慢的解决办法","date":"2020-07-22T11:31:15.000Z","path":"2020/07/22/Maven仓库导包慢的解决办法/","text":"Hello World! 故障原因原因：默认安装的maven使用官网地址下载依赖包，在国内访问比较慢。方法：将maven配置文件中下载依赖包地址修改成国内地址，一般都使用阿里的地址。 解决方法1，右键项目名，选择maven替换setting.xml文件中的这部分为如下样式： 1234567891011121314151617181920212223242526272829303132333435&lt;mirrors&gt; &lt;!-- mirror | Specifies a repository mirror site to use instead of a given repository. The repository that | this mirror serves has an ID that matches the mirrorOf element of this mirror. IDs are used | for inheritance and direct lookup purposes, and must be unique across the set of mirrors. | &lt;mirror&gt; &lt;id&gt;mirrorId&lt;/id&gt; &lt;mirrorOf&gt;repositoryId&lt;/mirrorOf&gt; &lt;name&gt;Human Readable Name for this Mirror.&lt;/name&gt; &lt;url&gt;http://my.repository.com/repo/path&lt;/url&gt; &lt;/mirror&gt; --&gt; &lt;!-- &lt;mirror&gt; --&gt; &lt;!-- &lt;id&gt;repo2&lt;/id&gt; --&gt; &lt;!-- &lt;mirrorOf&gt;central&lt;/mirrorOf&gt; --&gt; &lt;!-- &lt;name&gt;Human Readable Name for this Mirror.&lt;/name&gt; --&gt; &lt;!-- &lt;url&gt;http://repo2.maven.org/maven2/&lt;/url&gt; --&gt; &lt;!-- &lt;/mirror&gt; --&gt; &lt;mirror&gt; &lt;!--This sends everything else to /public --&gt; &lt;id&gt;nexus&lt;/id&gt; &lt;mirrorOf&gt;*&lt;/mirrorOf&gt; &lt;url&gt;http://maven.aliyun.com/nexus/content/groups/public/&lt;/url&gt; &lt;/mirror&gt; &lt;mirror&gt; &lt;!--This is used to direct the public snapshots repo in the profile below over to a different nexus group --&gt; &lt;id&gt;nexus-public-snapshots&lt;/id&gt; &lt;mirrorOf&gt;public-snapshots&lt;/mirrorOf&gt; &lt;url&gt;http://maven.aliyun.com/nexus/content/repositories/snapshots/&lt;/url&gt; &lt;/mirror&gt; &lt;/mirrors&gt; 2.打开本地maven位置，选择setting.xml文件，修改同上位置打开.xml文件后替换红框部分：重启idea后更新maven仓库，下载飞快。 END","updated":"2020-07-23T07:18:55.876Z","categories":[{"name":"JavaWeb","slug":"JavaWeb","permalink":"http://yoursite.com/categories/JavaWeb/"}],"tags":[{"name":"Maven","slug":"Maven","permalink":"http://yoursite.com/tags/Maven/"},{"name":"SpringBoot","slug":"SpringBoot","permalink":"http://yoursite.com/tags/SpringBoot/"}]},{"title":"SpringBoot的启动图案修改","date":"2020-07-22T11:30:53.000Z","path":"2020/07/22/SpringBoot的启动图案修改/","text":"Hello World! Springboot项目启动时，会出现大大的SpringBoot的图案：修改：首先创建springboot项目，首先在resources/目录下创建名为banner.txt的文件：点击链接：SpringBoot的启动图案修改 启动项目：无聊…..END","updated":"2020-07-23T07:18:56.052Z","categories":[{"name":"SpringBoot","slug":"SpringBoot","permalink":"http://yoursite.com/categories/SpringBoot/"}],"tags":[{"name":"启动图案修改","slug":"启动图案修改","permalink":"http://yoursite.com/tags/%E5%90%AF%E5%8A%A8%E5%9B%BE%E6%A1%88%E4%BF%AE%E6%94%B9/"}]},{"title":"Java Web之环境搭建（测试用）","date":"2020-07-22T11:19:02.000Z","path":"2020/07/22/Java-Web之环境搭建（测试用）/","text":"Hello World! Java Web之环境搭建1. Java Web介绍Java Web是用Java技术来解决web领域的技术，需要运行在特定的web服务器上，Java Web是跨平台的，可以在不同的平台上进行部署运行。需要掌握的技术1.前端方面的相关技术如：html、css、js等2.服务端先关技术如：java，jsp，服务器，ssh、ssm框架，等3.数据库相关：MySQL，Oracle等 2. 开发环境准备编辑器：Eclipse或Idea等java环境：JDK1.8服务器：Tomcat环境搭建完毕之后，就可以创建项目开始开发了。 环境搭建参考：Java Web之环境搭建.","updated":"2020-07-23T07:22:33.490Z","categories":[{"name":"JavaWeb","slug":"JavaWeb","permalink":"http://yoursite.com/categories/JavaWeb/"}],"tags":[{"name":"JavaWeb","slug":"JavaWeb","permalink":"http://yoursite.com/tags/JavaWeb/"}]},{"title":"springboot application.properties 配置及参数配置详情介绍","date":"2020-07-22T11:18:28.000Z","path":"2020/07/22/springboot-application-properties-配置及参数配置详情介绍/","text":"Hello World! application.properties： 12345678910111213141516171819#server.port=8080#server.servlet.context-path=/index #访问路径设置spring.datasource.url = jdbc:mysql://localhost:3306/ems?characterEncoding=UTF-8&amp;useSSL=true&amp;serverTimezone=UTCspring.datasource.username = rootspring.datasource.password = 123456spring.datasource.driverClassName = com.mysql.cj.jdbc.Driverspring.datasource.type = com.alibaba.druid.pool.DruidDataSourcemybatis.mapper-locations = classpath:mapper/*.xmlmybatis.type-aliases-package = com.dvms.entityspring.resources.static-locations = classpath:/templates/,classpath:/static/#pagehelper分页插件配置pagehelper.helperDialect=mysqlpagehelper.reasonable=truepagehelper.supportMethodsArguments=truepagehelper.params=count=countSql 查看参数配置：spring boot application.properties 配置参数详情： multipartmultipart.enabled 开启上传支持（默认：true） multipart.file-size-threshold: 大于该值的文件会被写到磁盘上 multipart.location 上传文件存放位置 multipart.max-file-size最大文件大小 multipart.max-request-size 最大请求大小 serverserver.address 服务器地址 server.port 服务器端口 server.context-parameters.[param name] 设置 servlet 上下文参数 server.context-path 应用上下文路径 Jsp-serveltserver.jsp-servelt.class-name 针对jsp 使用的 Servlet 类名（默认：org.apache.jasper.servlet.JspServlet） server.jsp-servlet.registered JspServelt 是否要注册到内嵌的 Servlet 容器里（默认 true） server.jsp-servlet.init-parameters[param name] 设置 Jsp Servlet 初始化参数 server.servlet-path主分发器 Servlet 的路径（默认：/） Sessionserver.session.cookie.domain 回话 Cookie 的域 server.session.cookie.comment Cookie 注释 server.session.cookie.max-age Cookie 最大保存时间（单位 s） server.session.cookie.name Cookie 名称 server.session.cookie.timeout 超时时间 tomcatserver.tomcat.accesslog.directory 创建日志文件的目录 server.tomcat.accesslog.enabled 是否开启访问日志（默认：false） server.tomcat.accesslog.pattern 访问日志的格式（默认：common） server.tomcat.accesslog.prefix日志名前缀（默认：access_log） server.tomcat.accesslog.suffix 日志名后缀（默认：.log） server.tomcat.max-http-header-sizeHttp 消息头最大字节数（默认：0） server.tomcat.uri-encoding 用来解码 URI 的字符编码 Cachespring.cache.cache-names 如果底层缓存管理器支持缓存名的话，可以在这里指定要创建的缓存名列表，用逗号分 隔。通常这会禁用运行时创建其他额外缓存的能力。 spring.cache.config 用来初始化 EhCache 的配置文件位置 spring.cache.guava.spec 用来创建缓存 Spec spring.cache.hazelcast.config 用来初始化 Hazeleast 的配置文件位置 spring.cache.infinispan.config 用来初始化 Infinispan 配置文件位置 spring.cache.jcache.config用来初始化缓存管理器的配置文件的位置，配置文件依赖于底层的缓存实现 spring.cache.jcache.provider CachingProvider 实现的全限定类名，用来获取 JSR-107 兼容的缓存管理器，仅在 Classpath 里有不只一个 JSR-107 实现时才需要这个属性。 spring.cache.type 缓存类型，默认根据环境自动检测 Dataspring.data.jpa.repositories.enabled 开启 JPA 仓库（默认：true） spring.data.mongodb.authentication-database 身份认证数据库名 spring.data.mongodb.database 数据库名 spring.data.mongodb.field-naming-strategy 要使用的 FieldNamingStrategy 的全限定名。 spring.data.mongodb.grid.fs.database GridFS 数据库名称 spring.data.mongodb.host MongoDB 服务器地址 spring.data.mongodb.username MongoDB 账号 spring.data.mongodb.passwordMongoDB 密码 spring.data.mongodb.port 端口号 spring.data.mongodb.repositories.enabled 开启 Mongo 仓库（默认值：true） spring.data.mongodb.uri Mongo 数据库 URI。设置了该属性后就主机和端口号会被忽略。（默认值： mongodb:// localhost/test） spring.data.rest.base-path 用于发布仓库资源的基本路径 spring.data.rest.default-page-size 分页数据的默认页大小（默认：20） spring.data.rest.limit-param-name用于标识一次返回多少记录的 URL 查询字符串参数名。（默认值： size ） spring.data.rest.max-page-sieze: 最大分页大小（默认：1000） spring.data.rest.page-param-name URL 查询字符串参数的名称，用来标识返回哪一页。（默认值： page ） spring.data.rest.return-body-on-create 在创建实体后是否返回一个响应体（默认：false） spring.data.rest.return-body-on-update 在更新实体后是否返回一个响应体（默认：false） spring.data.rest.sort-param-name URL 查询字符串参数的名称，用来表示结果排序的方向（默认：name） spring.data.solr.host Solr 的主机地址。如果设置了 zk-host 则忽略该属性。（默认值： http://127.0.0.1: 8983/solr ） spring.data.solr.repositories.enabled 开启 solr 仓库（默认：true） spring.data.solr.zk-host zk 主机地址，格式为 “主机 - 端口” spring.datasource.allow-pool-suspension 是否允许池暂停（pool suspension）。在开启池暂停后会有性能会受到一定影响，除非你 真的需要这个功能（例如在冗余的系统下），否则不要开启它。该属性只在使用 Hikari 数 据库连接池时有用。（默认值： false 。） DataSourcespring.datasource.name 数据源的名称。 spring.datasource.username 数据库的登录用户名。 spring.datasource.password 数据库的登录密码。 spring.datasource.url 数据库的 JDBC URL。 spring.datasource.jdbc-url 用来创建连接的 JDBC URL。 spring.datasource.driver-class-name JDBC 驱动的全限定类名。默认根据 URL 自动检测。 spring.datasource.pool-name 连接池名称。 spring.datasource.max-active 连接池中的最大活跃连接数。 spring.datasource.connection-timeout连接超时（单位毫秒） spring.datasource.max-age 连接池中连接的最长寿命。 spring.datasource.max-idle 连接池中的最大空闲连接数。 spring.datasource.max-lifetime 连接池中连接的最长寿命（单位为毫秒）。 spring.datasource.max-open-prepared-statements 开启状态的 PreparedStatement 的数量上限。 spring.datasource.max-wait 连接池在等待返回连接时，最长等待多少毫秒再抛出异常。 spring.datasource.maximum-pool-size 连接池能达到的最大规模，包含空闲连接的数量和使用中的连接数量。 spring.datasource.min-evictable-idle-time-millis 一个空闲连接被空闲连接释放器（如果存在的话）优雅地释放前，最短会在连接池里停 留多少时间。 spring.datasource.min-idle 连接池里始终应该保持的最小连接数。（用于 DBCP 和 Tomcat 连接池。） spring.datasource.minimum-idle: HikariCP 试图在连接池里维持的最小空闲连接数。 spring.datasource.alternate-username-allowed 是否允许其它用户名 spring.datasource.auto-commit 更新操作是否自动提交 spring.datasource.abandon-when-percentage-full 一个百分比形势的阈值，超过该阈值则关闭并报告被弃用的连接 spring.datasource.catalog 默认的 Catalog 名称 spring.datasource.commit-on-return 在连接归还时，连接池是否要提交挂起的事务 spring.datasource.connection-init-sql 在所有新连接创建时都会执行的 SQL 语句，该语句会在连接加入连接池前执行。 spring.datasource.connection-init-sqls 在物理连接第一次创建时执行的 SQL 语句列表。（用于 DBCP 连接池。） spring.datasource.connection-properties.[key] 设置创建连接时使用的属性。（用于 DBCP 连接池。） spring.datasource.continue-on-error 初始化数据库时发生错误不要终止。（默认值： false） spring.datasource.data 指向数据（数据库操纵语言，Data Manipulation Language，DML）脚本资源的引用。 spring.datasource.data-source-class-name 用于获取连接的数据源的全限定类名。 spring.datasource.data-source-jndi 用于获取连接的数据源的 JNDI 位置。 spring.datasource.data-source-properties.[key] 设置创建数据源时使用的属性。（用于 Hikari 连接池。） spring.datasource.db-properties 设置创建数据源时使用的属性。（用于 Tomcat 连接池。） spring.datasource.default-auto-commit 连接上的操作是否自动提交。 spring.datasource.default-catalog 连接的默认 Catalog。 spring.datasource.default-read-only 连接的默认只读状态。 spring.datasource.default-transaction-isolation 连接的默认事务隔离级别。 spring.datasource.fair-queue 是否以 FIFO 方式返回连接。 spring.datasource.health-check-properties.[key] 设置要纳入健康检查的属性。（用于 Hikari 连接池。） spring.datasource.idle-timeout 连接池中的连接能保持闲置状态的最长时间，单位为毫秒。（默认值： 10 。） spring.datasource.ignore-exception-on-pre-load 初始化数据库连接池时是否要忽略连接。 spring.datasource.init-sql在连接第一次创建时运行的自定义查询。 spring.datasource.initial-size 在连接池启动时要建立的连接数。 spring.datasource.initialization-fail-fast 在连接池创建时，如果达不到最小连接数是否要抛出异常。（默认值： true 。） spring.datasource.initialize 使用 data.sql 初始化数据库。（默认值： true 。） spring.datasource.isolate-internal-queries 是否要隔离内部请求。（默认值： false 。） spring.datasource.jdbc-interceptors 一个分号分隔的类名列表，这些类都扩展了 JdbcInterceptor 类。这些拦截器会插入 java.sql.Connection 对象的操作链里。（用于 Tomcat 连接池。） spring.datasource.jmx-enabled 开启 JMX 支持（如果底层连接池提供该功能的话）。（默认值： false 。） spring.datasource.jndi-name 数据源的 JNDI 位置。设置了该属性则忽略类、URL、用户名和密码属性。 spring.datasource.leak-detection-threshold 用来检测 Hikari 连接池连接泄露的阈值，单位为毫秒。 spring.datasource.log-abandoned 是否针对弃用语句或连接的应用程序代码记录下跟踪栈。用于 DBCP 连接池。（默认值： false 。） spring.datasource.log-validation-errors 在使用 Tomcat 连接池时是否要记录验证错误。 spring.datasource.login-timeout 连接数据库的超时时间（单位为秒）。 spring.datasource.num-tests-per-eviction-run 空闲对象释放器线程（如果存在的话）每次运行时要检查的对象数。 spring.datasource.platform 在 Schema 资源（schema-${platform}.sql）里要使用的平台。（默认值： all 。） spring.datasource.pool-prepared-statements 是否要将 Statement 放在池里。 spring.datasource.propagate-interrupt-state 对于等待连接的中断线程，是否要传播中断状态。 spring.datasource.read-only 在使用 Hikari 连接池时将数据源设置为只读。 spring.datasource.register-mbeans Hikari 连接池是否要注册 JMX MBean。 spring.datasource.remove-abandoned 被弃用的连接在到达弃用超时后是否应该被移除。 spring.datasource.remove-abandoned-timeout 连接在多少秒后应该考虑弃用。 spring.datasource.rollback-on-return 在连接归还连接池时，是否要回滚挂起的事务。 spring.datasource.schema Schema（数据定义语言，Data Definition Language，DDL）脚本资源的引用。 spring.datasource.separator SQL 初始化脚本里的语句分割符。（默认值： ; 。） spring.datasource.sql-script-encoding SQL 脚本的编码。 spring.datasource.suspect-timeout 在记录一个疑似弃用连接前要等待多少秒。 spring.datasource.test-on-borrow 从连接池中借用连接时是否要进行测试。 spring.datasource.test-on-connect 在建立连接时是否要进行测试。 spring.datasource.test-on-return 在将连接归还到连接池时是否要进行测试。 spring.datasource.test-while-idle 在连接空闲时是否要进行测试。 spring.datasource.time-between-eviction-runs-millis 在两次空闲连接验证、弃用连接清理和空闲池大小调整之间睡眠的毫秒数。 spring.datasource.transaction-isolation 在使用 Hikari 连接池时设置默认事务隔离级别。 spring.datasource.use-disposable-connection-facade 连接是否要用一个门面（facade）封装起来，在调用了 Connection.close() 后就不能 再使用这个连接了。 spring.datasource.use-equals 在比较方法名时是否使用 String.equals() 来代替 == 。 spring.datasource.use-lock 在操作连接对象时是否要加锁。 spring.datasource.validation-interval 执行连接验证的间隔时间，单位为毫秒。 spring.datasource.validation-query 在连接池里的连接返回给调用者或连接池时，要执行的验证 SQL 查询。 spring.datasource.validation-query-timeout 在连接验证查询执行失败前等待的超时时间，单位为秒。 spring.datasource.validation-timeout 在连接验证失败前等待的超时时间，单位为秒。（用于 Hikari 连接池。） spring.datasource.validator-class-name 可选验证器类的全限定类名，用于执行测试查询。 spring.datasource.xa.data-source-class-name XA 数据源的全限定类名。 spring.datasource.xa.properties 要传递给 XA 数据源的属性。 FreeMarkerspring.freemarker.allow-request-override HttpServletRequest 的属性是否允许覆盖（隐藏）控制器生成的同名模型属性。 spring.freemarker.allow-session-override HttpSession 的属性是否允许覆盖（隐藏）控制器生成的同名模型属性。 spring.freemarker.cache 开启模板缓存。 spring.freemarker.charset 模板编码。 spring.freemarker.check-template-location 检查模板位置是否存在。 spring.freemarker.content-type Content-Type 的值。 spring.freemarker.enabled 开启 FreeMarker 的 MVC 视图解析。 spring.freemarker.expose-request-attributes 在模型合并到模板前，是否要把所有的请求属性添加到模型里。 spring.freemarker.expose-session-attributes 在模型合并到模板前，是否要把所有的 HttpSession 属性添加到模型里。 spring.freemarker.expose-spring-macro-helpers 是否发布供 Spring 宏程序库使用的 RequestContext ，并将命其名为 springMacro- RequestContext spring.freemarker.prefer-file-system-access 加载模板时优先通过文件系统访问。文件系统访问能够实时检测到模板变更。（默认值： true 。） spring.freemarker.prefix 在构建 URL 时添加到视图名称前的前缀。 spring.freemarker.request-context-attribute 在所有视图里使用的 RequestContext 属性的名称。 spring.freemarker.settings 要传递给 FreeMarker 配置的各种键。 spring.freemarker.suffix 在构建 URL 时添加到视图名称后的后缀。 spring.freemarker.template-loader-path 模板路径列表，用逗号分隔。（默认值： [“classpath:/templates/”] 。） spring.freemarker.view-names 可解析的视图名称的白名单。 Groovyspring.groovy.template.allow-request-override HttpServletRequest 的属性是否允许覆盖（隐藏）控制器生成的同名模型属性。 spring.groovy.template.allow-session-override HttpSession 的属性是否允许覆盖（隐藏）控制器生成的同名模型属性。 spring.groovy.template.cache 开启模板缓存。 spring.groovy.template.charset 模板编码。 spring.groovy.template.check-template-location 检查模板位置是否存在。 spring.groovy.template.configuration.auto-escape 模型变量在模板里呈现时是否要做转义。（默认值： false 。） spring.groovy.template.configuration.auto-indent 模板是否要自动呈现缩进。（默认值： false 。） spring.groovy.template.configuration.auto-indent-string 开启自动缩进时用于缩进的字符串，可以是 SPACES ，也可以是 TAB 。（默认值： SPACES 。） spring.groovy.template.configuration.auto-new-line 模板里是否要呈现新的空行。（默认值： false 。） spring.groovy.template.configuration.base-template-class 模板基类。 spring.groovy.template.configuration.cache-templates 模板是否应该缓存。（默认值： true 。） spring.groovy.template.configuration.declaration-encoding 用来写声明头的编码。 spring.groovy.template.configuration.expand-empty-elements 没有正文的元素该用短形式（例如， ）还是扩展形式（例如， ）来书 写。（默认值： false） spring.groovy.template.configuration.locale 设置模板地域。 spring.groovy.template.configuration.new-line-string 在自动空行开启后用来呈现空行的字符串。（默认为系统的 line.separator 属性值。） spring.groovy.template.configuration.resource-loader-path Groovy 模板的路径。（默认值： classpath:/templates/ 。） spring.groovy.template.configuration.use-double-quotes 属性是该用双引号还是单引号。（默认值： false 。） spring.groovy.template.content-type Content-Type 的值。 spring.groovy.template.enabled 开启 Groovy 模板的 MVC 视图解析。 spring.groovy.template.expose-request-attributes 在模型合并到模板前，是否要把所有的请求属性添加到模型里。 spring.groovy.template.expose-session-attributes 在模型合并到模板前，是否要把所有的 HttpSession 属性添加到模型里。 spring.groovy.template.expose-spring-macro-helpers 是否发布供 Spring 宏程序库使用的 RequestContext ，并将其命名为 springMacro- RequestContext spring.groovy.template.prefix 在构建 URL 时，添加到视图名称前的前缀。 spring.groovy.template.request-context-attribute 所有视图里使用的 RequestContext 属性的名称。 spring.groovy.template.resource-loader-path 模板路径（默认值： classpath:/ templates/ 。） spring.groovy.template.suffix 在构建 URL 时，添加到视图名称后的后缀。 spring.groovy.template.view-names 可解析的视图名称白名单。 H2spring.h2.console.enabled 开启控制台。（默认值： false 。） spring.h2.console.path 可以找到控制台的路径。（默认值： /h2-console 。） Hornetq spring.hornetq.embedded.cluster-password 集群密码。默认在启动时随机生成。 spring.hornetq.embedded.data-directory 日志文件目录。如果关闭了持久化功能则不需要该属性。 spring.hornetq.embedded.enabled 如果有 HornetQ 服务器 API，则开启嵌入模式。（默认值： true 。） spring.hornetq.embedded.persistent 开启持久化存储。（默认值： false 。） spring.hornetq.embedded.queues 启动时要创建的队列列表，用逗号分隔。（默认值： [] 。） spring.hornetq.embedded.server-id 服务器 ID。默认使用自增长计数器。（默认值： 0 。） spring.hornetq.embedded.topics 启动时要创建的主题列表，用逗号分隔。（默认值： [] 。） spring.hornetq.host HornetQ 的主机。（默认值： localhost 。） spring.hornetq.mode HornetQ 的部署模式，默认为自动检测。可以显式地设置为 native 或 embedded 。 spring.hornetq.port HornetQ 的端口。（默认值： 5445 。） Httpspring.http.converters.preferred-json-mapper HTTP 消息转换时优先使用 JSON 映射器。 spring.http.encoding.charset HTTP 请求和响应的字符集。如果没有显式地指定 Content-Type 头，则将该属性值作为 这个头的值。（默认值： UTF-8 。） spring.http.encoding.enabled 开启 HTTP 编码支持。（默认值： true 。） spring.http.encoding.force 强制将 HTTP 请求和响应编码为所配置的字符集。（默认值： true 。） Jacksonspring.jackson.date-format 日期格式字符串（yyyy-MM-dd HH:mm:ss）或日期格式类的全限定类名。 spring.jackson.deserialization 影响 Java 对象反序列化的 Jackson on/off 特性。 spring.jackson.generator 用于生成器的 Jackson on/off 特性。 spring.jackson.joda-date-time-format Joda 日期时间格式字符串（yyyy-MM-dd HH:mm:ss）。如果没有配置，而 date-format 又配置了一个格式字符串的话，会将它作为降级配置。 spring.jackson.locale 用于格式化的地域值。 spring.jackson.mapper Jackson 的通用 on/off 特性。 spring.jackson.parser 用于解析器的 Jackson on/off 特性。 spring.jackson.property-naming-strategy Jackson 的 PropertyNamingStrategy 中的一个常量（ CAMEL_CASE_TO_LOWERCASE WITH_UNDERSCORES ）。也可以设置 PropertyNamingStrategy 的子类的全限定类名。 spring.jackson.serialization 影响 Java 对象序列化的 Jackson on/off 特性。 spring.jackson.serialization-inclusion 控制序列化时要包含哪些属性。可选择 Jackson 的 JsonInclude.Include 枚举里的某个值。 spring.jackson.time-zone 格式化日期时使用的时区。可以配置各种可识别的时区标识符，比如 America/Los_ Angeles 或者 GMT+10 。 Jerseyspring.jersey.filter.order Jersey 过滤器链的顺序。（默认值： 0 。） spring.jersey.init 通过 Servlet 或过滤器传递给 Jersey 的初始化参数。 spring.jersey.type Jersey 集成类型。可以是 servlet 或者 filter 。 Jmsspring.jms.jndi-name 连接工厂的 JNDI 名字。设置了该属性，则优先于其他自动配置的连接工厂。 spring.jms.listener.acknowledge-mode 容器的应答模式（acknowledgment mode）。默认情况下，监听器使用自动应答。 spring.jms.listener.auto-startup 启动时自动启动容器。（默认值： true 。） spring.jms.listener.concurrency 并发消费者的数量下限。 spring.jms.listener.max-concurrency 并发消费者的数量上限。 spring.jms.pub-sub-domain 如果是主题而非队列，指明默认的目的地类型是否支持 Pub/Sub。（默认值： false 。） Jmxspring.jmx.default-domain JMX 域名。 spring.jmx.enabled 将管理 Bean 发布到 JMX 域里。（默认值： true 。） spring.jmx.server MBeanServer 的 Bean 名称。（默认值： mbeanServer 。） Jpaspring.jpa.database 要操作的目标数据库，默认自动检测。也可以通过 databasePlatform 属性进行设置。 spring.jpa.database-platform 要操作的目标数据库，默认自动检测。也可以通过 Database 枚举来设置。 spring.jpa.generate-ddl 启动时要初始化 Schema。（默认值： false 。） spring.jpa.hibernate.ddl-auto DDL 模式（ none 、 validate 、 update 、 create 和 create-drop ）。这是 hibernate. hbm2ddl.auto 属性的一个快捷方式。在使用嵌入式数据库时，默认为 create-drop , 其他情况下默认为 none 。 spring.jpa.hibernate.naming-strategy Hibernate 命名策略的全限定类名。 spring.jpa.open-in-view 注册 OpenEntityManagerInViewInterceptor ，在请求的整个处理过程中，将一个 JPA EntityManager 绑定到线程上。（默认值： true） spring.jpa.propertiesJPA 提供方要设置的额外原生属性。 spring.jpa.show-sql 在使用 Bitronix Transaction Manager 时打开 SQL 语句日志。（默认值： false 。） Jtaspring.jta.allow-multiple-lrc 在使用 Bitronix Transaction Manager 时，事务管理器是否应该允许一个事务涉及多个 LRC 资源。（默认值： false） spring.jta.asynchronous2-pc 在使用 Bitronix Transaction Manager 时，是否异步执行两阶段提交。（默认值： false 。） spring.jta.background-recovery-interval在使用 Bitronix Transaction Manager 时，多久运行一次恢复过程，单位为分钟。（默认值： 1 ） spring.jta.background-recovery-interval-seconds 在使用 Bitronix Transaction Manager 时，多久运行一次恢复过程，单位为秒。（默认值： 60 ） spring.jta.current-node-only-recovery 在使用 Bitronix Transaction Manager 时，恢复是否要滤除不包含本 JVM 唯一 ID 的 XID。（默认值： true ） spring.jta.debug-zero-resource-transaction 在使用 Bitronix Transaction Manager 时，对于没有涉及任何资源的事务，是否要跟踪并记 录它们的创建和提交调用栈。（默认值： false） spring.jta.default-transaction-timeout 在使用 Bitronix Transaction Manager 时，默认的事务超时时间，单位为秒。（默认值： 60 。） spring.jta.disable-jmx 在使用 Bitronix Transaction Manager 时，是否要禁止注册 JMX MBean。（默认值： false 。） spring.jta.enabled 开启 JTA 支持。（默认值： true 。） spring.jta.exception-analyzer 在使用 Bitronix Transaction Manager 时用到的异常分析器。设置为 null 时使用默认异常分析器，也可以设置自定义异常分析器的全限定类名。 spring.jta.filter-log-status 在使用 Bitronix Transaction Manager 时，是否只记录必要的日志。开启该参数时能减少分 段（fragment）空间用量，但调试更复杂了。（默认值： false） spring.jta.force-batching-enabled 在使用 Bitronix Transaction Manager 时，是否批量输出至磁盘。禁用批处理会严重降低事 务管理器的吞吐量。（默认值： true 。） spring.jta.forced-write-enabled 在使用 Bitronix Transaction Manager 时，日志是否强制写到磁盘上。在生产环境里不要设 置为 false ，因为不强制写到磁盘上无法保证完整性。（默认值： true） spring.jta.graceful-shutdown-interval 在使用 Bitronix Transaction Manager 时，要关闭的话，事务管理器在放弃事务前最多等它 多少秒。（默认值： 60） spring.jta.jndi-transaction-synchronization-registry-name 在使用 Bitronix Transaction Manager 时，事务同步注册表应该绑定到哪个 JNDI 下。（默认 值： java:comp/TransactionSynchronizationRegistry） spring.jta.jndi-user-transaction-name 在使用 Bitronix Transaction Manager 时，用户事务应该绑定到哪个 JNDI 下。（默认值： java:comp/UserTransaction 。） spring.jta.journal 在使用 Bitronix Transaction Manager 时，要用的日志名。可以是 disk 、 null 或者全限定类 名。（默认值： disk 。） spring.jta.log-dir 事务日志目录。 spring.jta.log-part1-filename 日志分段文件 1 的名称。（默认值： btm1.tlog 。） spring.jta.log-part2-filename 日志分段文件 2 的名称。（默认值： btm2.tlog 。） spring.jta.max-log-size-in-mb 在使用 Bitronix Transaction Manager 时，日志分段文件的最大兆数。日志越大，事务就被 允许在未终结状态停留越长时间。但是，如果文件大小限制得太小，事务管理器在分段 满了的时候就会暂停更长时间。（默认值： 2 。） spring.jta.resource-configuration-filename Bitronix Transaction Manager 的配置文件名。 spring.jta.server-id 唯一标识 Bitronix Transaction Manager 实例的 ID。 spring.jta.skip-corrupted-logs 是否跳过损坏的日志文件。（默认值： false 。） spring.jta.transaction-manager-id 事务管理器的唯一标识符。 spring.jta.warn-about-zero-resource-transaction 在使用 Bitronix Transaction Manager 时，是否要对执行时没有涉及任何资源的事务作出告 警。（默认值： true 。） Mailspring.mail.default-encoding 默认的 MimeMessage 编码。（默认值： UTF-8 。） spring.mail.host SMTP 服务器主机地址。 spring.mail.jndi-name会话的 JNDI 名称。设置之后，该属性的优先级要高于其他邮件设置。 spring.mail.password SMTP 服务器的登录密码。 spring.mail.port SMTP 服务器的端口号。 spring.mail.properties 附加的 JavaMail 会话属性。 spring.mail.protocol SMTP 服务器用到的协议。（默认值： smtp 。） spring.mail.test-connection 在启动时测试邮件服务器是否可用。（默认值： false 。） spring.mail.username SMTP 服务器的登录用户名。 Messagesspring.messages.basename 逗号分隔的基本名称列表，都遵循 ResourceBundle 的惯例。本质上这就是一个全限定 的 Classpath 位置，如果不包含包限定符（比如 org.mypackage ），就会从 Classpath 的根部开始解析。（默认值： messages 。） spring.messages.cache-seconds 加载的资源包文件的缓存失效时间，单位为秒。在设置为 -1 时，包会永远缓存。（默认值： -1 。） spring.messages.encoding消息包的编码。（默认值： UTF-8 。） Mobilespring.mobile.devicedelegatingviewresolver.enable-fallback 开启降级解析支持。（默认值： false 。） spring.mobile.devicedelegatingviewresolver.enabled 开启设备视图解析器。（默认值： false 。） spring.mobile.devicedelegatingviewresolver.mobile-prefix 添加到移动设备视图名前的前缀。（默认值： mobile/ 。） spring.mobile.devicedelegatingviewresolver.mobile-suffix 添加到移动设备视图名后的后缀。 spring.mobile.devicedelegatingviewresolver.normal-prefix 添加到普通设备视图名前的前缀。 spring.mobile.devicedelegatingviewresolver.normal-suffix 添加到普通设备视图名后的后缀。 spring.mobile.devicedelegatingviewresolver.tablet-prefix添加到平板设备视图名前的前缀。（默认值： tablet/ 。） spring.mobile.devicedelegatingviewresolver.tablet-suffix 添加到平板设备视图名后的后缀。 spring.mobile.sitepreference.enabled 开启 SitePreferenceHandler 。（默认值： true 。） Mongodbspring.mongodb.embedded.features要开启的特性列表，用逗号分隔。 spring.mongodb.embedded.version 要使用的 Mongo 版本。（默认值： 2.6.10 。） Mustachespring.mustache.cache 开启模板缓存。 spring.mustache.charset 模板编码。 spring.mustache.check-template-location 检查模板位置是否存在。 spring.mustache.content-type Content-Type 的值。 spring.mustache.enabled 开启 Mustache 的 MVC 视图解析。 spring.mustache.prefix添加到模板名前的前缀。（默认值： classpath:/ templates/ 。） spring.mustache.suffix 添加到模板名后的后缀。（默认值： .html 。） spring.mustache.view-names 可解析的视图名称的白名单。 Mvcspring.mvc.async.request-timeout 异步请求处理超时前的等待时间（单位为毫秒）。如果没有设置该属性，则使用底层实现 的默认超时时间，比如，Tomcat 上使用 Servlet 3 时超时时间为 10 秒。 spring.mvc.date-format 要使用的日期格式（比如 dd/MM/yyyy ）。 spring.mvc.favicon.enabled 开启 favicon.ico 的解析。（默认值： true 。） spring.mvc.ignore-default-model-on-redirect 在重定向的场景下，是否要忽略“默认”模型对象的内容。（默认值： true 。） spring.mvc.locale 要使用的地域配置。 spring.mvc.message-codes-resolver-format 消息代码格式（ PREFIX_ERROR_CODE 、 POSTFIX_ERROR_CODE ）。 spring.mvc.view.prefix Spring MVC 视图前缀。 spring.mvc.view.suffix Spring MVC 视图后缀。 Mybatismybatis.mapper-locations mybatis 映射文件位置。mybatis.type-aliases-package 别名包位置。 Rabbitmqspring.rabbitmq.addresses 客户端应该连接的地址列表，用逗号分隔。 spring.rabbitmq.dynamic 创建一个 AmqpAdmin Bean。（默认值： true 。） spring.rabbitmq.host RabbitMQ 主机地址。（默认值： localhost 。） spring.rabbitmq.listener.acknowledge-mode 容器的应答模式。 spring.rabbitmq.listener.auto-startup 启动时自动开启容器。（默认值： true 。） spring.rabbitmq.listener.concurrency 消费者的数量下限。 spring.rabbitmq.listener.max-concurrency 消费者的数量上限。 spring.rabbitmq.listener.prefetch 单个请求里要处理的消息数。该数值不应小于事务数（如果用到的话）。 spring.rabbitmq.listener.transaction-size 一个事务里要处理的消息数。为了保证效果，应该不大于预先获取的数量。 spring.rabbitmq.password进行身份验证的密码。 spring.rabbitmq.port RabbitMQ 端口。（默认值： 5672 。） spring.rabbitmq.requested-heartbeat 请求心跳超时，单位为秒； 0 表示不启用心跳。 spring.rabbitmq.ssl.enabled 开启 SSL 支持。（默认值： false 。） spring.rabbitmq.ssl.key-store 持有 SSL 证书的 KeyStore 路径。 spring.rabbitmq.ssl.key-store-password 访问 KeyStore 的密码。 spring.rabbitmq.ssl.trust-store 持有 SSL 证书的 TrustStore。 spring.rabbitmq.ssl.trust-store-password 访问 TrustStore 的密码。 spring.rabbitmq.username 进行身份验证的用户名。 spring.rabbitmq.virtual-host 在连接 RabbitMQ 时的虚拟主机。 Redisspring.redis.database 连接工厂使用的数据库索引。（默认值： 0 。） spring.redis.host Redis 服务器主机地址。（默认值： localhost 。） spring.redis.passwordRedis 服务器的登录密码。 spring.redis.pool.max-active连接池在指定时间里能分配的最大连接数。负数表示无限制。（默认值： 8 。） spring.redis.pool.max-idle 连接池里的最大空闲连接数。负数表示空闲连接数可以是无限大。（默认值： 8 。） spring.redis.pool.max-wait当连接池被耗尽时，分配连接的请求应该在抛出异常前被阻塞多长时间（单位为秒）。负 数表示一直阻塞。（默认值： -1 。） spring.redis.pool.min-idle 连接池里要维持的最小空闲连接数。该属性只有在设置为正数时才有效。（默认值： 0 。） spring.redis.port Redis 服务器端口。（默认值： 6379 。） spring.redis.sentinel.master Redis 服务器的名字。 spring.redis.sentinel.nodes形如“主机: 端口”配对的列表，用逗号分隔。 spring.redis.timeout 连接超时时间，单位为秒。（默认值： 0 。） Resourcesspring.resources.add-mappings 开启默认资源处理。（默认值： true 。） spring.resources.cache-period 资源处理器对资源的缓存周期，单位为秒。 spring.resources.chain.cache 对资源链开启缓存。（默认值： true 。） spring.resources.chain.enabled 开启 Spring 资源处理链。（默认关闭的，除非至少开启了一个策略。） spring.resources.chain.html-application-cache 开启 HTML5 应用程序缓存证明重写。（默认值： false 。） spring.resources.chain.strategy.content.enabled 开启内容版本策略。（默认值： false 。） spring.resources.chain.strategy.content.paths 要运用于版本策略的模式列表，用逗号分隔。（默认值： [/**] 。） spring.resources.chain.strategy.fixed.enabled开启固定版本策略。（默认值： false 。） spring.resources.chain.strategy.fixed.paths要运用于固定版本策略的模式列表，用逗号分隔。 spring.resources.chain.strategy.fixed.version 用于固定版本策略的版本字符串。 spring.resources.static-locations 静态资源位置。默认为 classpath: [/META-INF/resources/, /resources/, /static/, /public/] 加上 context:/（Servlet 上下文的根目录）。 SendGridspring.sendgrid.password SendGrid 密码。 spring.sendgrid.proxy.host SendGrid 代理主机地址。 spring.sendgrid.proxy.port SendGrid 代理端口。 spring.sendgrid.username SendGrid 用户名。 Socialspring.social.auto-connection-views 针对所支持的提供方开启连接状态视图。（默认值： false 。） spring.social.facebook.app-id 应用程序 ID。 spring.social.facebook.app-secret 应用程序的密钥。 spring.social.linkedin.app-id 应用程序 ID。 spring.social.linkedin.app-secret 应用程序的密钥。 spring.social.twitter.app-id 应用程序 ID。 spring.social.twitter.app-secret 应用程序的密钥。 Thymeleafspring.thymeleaf.cache开启模板缓存。（默认值： true 。） spring.thymeleaf.check-template-location 检查模板位置是否存在。（默认值： true 。） spring.thymeleaf.content-type Content-Type 的值。（默认值： text/html 。） spring.thymeleaf.enabled 开启 MVC Thymeleaf 视图解析。（默认值： true 。） spring.thymeleaf.encoding模板编码。（默认值： UTF-8 。） spring.thymeleaf.excluded-view-names 要被排除在解析之外的视图名称列表，用逗号分隔。 spring.thymeleaf.mode 要运用于模板之上的模板模式。另见 StandardTemplate- ModeHandlers 。（默认值： HTML5 。） spring.thymeleaf.prefix 在构建 URL 时添加到视图名称前的前缀。（默认值： classpath:/templates/ 。） spring.thymeleaf.suffix 在构建 URL 时添加到视图名称后的后缀。（默认值： .html 。） spring.thymeleaf.template-resolver-order Thymeleaf 模板解析器在解析器链中的顺序。默认情况下，它排在第一位。顺序从 1 开始只有在定义了额外的 TemplateResolver Bean 时才需要设置这个属性。 spring.thymeleaf.view-names 可解析的视图名称列表，用逗号分隔。 Velocityspring.velocity.allow-request-override HttpServletRequest 的属性是否允许覆盖（隐藏）控制器生成的同名模型属性。 spring.velocity.allow-session-override HttpSession` 的属性是否允许覆盖（隐藏）控制器生成的同名模型属性。 spring.velocity.cache 开启模板缓存。 spring.velocity.charset 模板编码。 spring.velocity.check-template-location 检查模板位置是否存在。 spring.velocity.content-type Content-Type 的值。 spring.velocity.date-tool-attribute DateTool 辅助对象在视图的 Velocity 上下文里呈现的名字。 spring.velocity.enabled 开启 Velocity 的 MVC 视图解析。 spring.velocity.expose-request-attributes 在模型合并到模板前，是否要把所有的请求属性添加到模型里。 spring.velocity.expose-session-attributes 在模型合并到模板前，是否要把所有的 HttpSession 属性添加到模型里。 spring.velocity.expose-spring-macro-helpers 是否发布供 Spring 宏程序库使用的 RequestContext ，并将其名命为 springMacro- RequestContext 。 spring.velocity.number-tool-attribute NumberTool 辅助对象在视图的 Velocity 上下文里呈现的名字。 spring.velocity.prefer-file-system-access 加载模板时优先通过文件系统访问。文件系统访问能够实时检测到模板变更。（默认值： true 。） spring.velocity.prefix在构建 URL 时添加到视图名称前的前缀。 spring.velocity.properties 额外的 Velocity 属性。 spring.velocity.request-context-attribute所有视图里使用的 Request- Context 属性的名称。 spring.velocity.resource-loader-path 模板路径。（默认值： classpath:/ templates/ 。） spring.velocity.suffix 在构建 URL 时添加到视图名称后的后缀。 spring.velocity.toolbox-config-location Velocity Toolbox 的配置位置，比如 /WEB-INF/toolbox.xml。自动加载 Velocity Tools 工具定 义文件，将所定义的全部工具发布到指定的作用域内。 spring.velocity.view-names可解析的视图名称白名单。 Viewspring.view.prefix Spring MVC 视图前缀。 spring.view.suffixSpring MVC 视图后缀。 其它spring.aop.auto 添加 @EnableAspectJAutoProxy(默认：true) spring.application.admin.enabled开启应用程序的管理功能 (默认：false) spring.artemis.embedded.cluster-password 集群密码。默认在启东市随机生成 spring.artemis.embedded.persistent开启持久化存储 (默认：false) spring.autoconfigure.exclude 要排除的自动配置类 END","updated":"2020-07-23T07:19:23.027Z","categories":[{"name":"JavaWeb","slug":"JavaWeb","permalink":"http://yoursite.com/categories/JavaWeb/"},{"name":"Springboot","slug":"JavaWeb/Springboot","permalink":"http://yoursite.com/categories/JavaWeb/Springboot/"}],"tags":[{"name":"JavaWeb","slug":"JavaWeb","permalink":"http://yoursite.com/tags/JavaWeb/"},{"name":"Springboot","slug":"Springboot","permalink":"http://yoursite.com/tags/Springboot/"},{"name":"application","slug":"application","permalink":"http://yoursite.com/tags/application/"}]},{"title":"SpringBoot项目打包为jar包","date":"2020-07-22T11:18:02.000Z","path":"2020/07/22/SpringBoot项目打包为jar包/","text":"Hello World! My Environment IDEA2018.3 JDK1.8 SpringBoot2.3.0 360浏览器项目部署一般是两种方式：一种是打包成 jar 包直接执行，另一种是打包成 war 包放到 Tomcat 服务器下，SpringBoot一般情况下默认为jar包方式。pom.xml：&lt; packaging&gt;jar&lt; /packaging&gt; （默认）&lt; packaging&gt;war&lt; /packaging&gt; 打jar包选择 File -&gt; Project Structure-&gt;Artifacts-&gt;Jar-&gt;Form modules with dependencies后点ok:根据 下图内容创建 jar。如图所示，选择项目，入口类等。最后一项 META-INF，默认放到 src\\main\\java 目录里，如果使用默认值，没有进行其他配置，生成的 jar 有可能不会包含 META-INF 目录，导致运行 jar 出错。最好放在 src\\main\\resource目录中。点击ok保存。按下图所示配置：点击ok会出现如图所示信息:生成jar包点击idea菜单栏中的build，依次选择：点Build:在保存路经中查找所打包的jar包如果存在则说明打包成功。运行jar包开始运行jar包，打开cmd进入jar所在的路径，输入java -jar xxx.jar (jar名称) ，点击回车按键。 1234567891011121314151617181920212223242526272829303132333435363738Microsoft Windows [版本 10.0.18362.959](c) 2019 Microsoft Corporation。保留所有权利。C:\\Users\\92895&gt;D:D:\\&gt;cd D:\\data_view\\out\\artifacts\\data_view_jarD:\\data_view\\out\\artifacts\\data_view_jar&gt;Java -jar data_view_jarError: Unable to access jarfile data_view_jarD:\\data_view\\out\\artifacts\\data_view_jar&gt;java -jar data_view_jarError: Unable to access jarfile data_view_jarD:\\data_view\\out\\artifacts\\data_view_jar&gt;java -jar data_view.jar_________ ____.__ __\\_ ___ \\ | / \\ / \\/ \\ \\/ | \\ \\/\\/ /\\ \\____/\\__| |\\ / \\______ /\\________| \\__/\\ / \\/ \\/2020-07-20 09:51:27.016 INFO 12564 --- [ restartedMain] com.dvms.DataViewApplication : Starting DataViewApplication on 4C501 with PID 12564 (D:\\data_view\\out\\artifacts\\data_view_jar\\data_view.jar started by 92895 in D:\\data_view\\out\\artifacts\\data_view_jar)2020-07-20 09:51:27.020 INFO 12564 --- [ restartedMain] com.dvms.DataViewApplication : No active profile set, falling back to default profiles: default2020-07-20 09:51:27.068 INFO 12564 --- [ restartedMain] .e.DevToolsPropertyDefaultsPostProcessor : Devtools property defaults active! Set 'spring.devtools.add-properties' to 'false' to disable2020-07-20 09:51:27.068 INFO 12564 --- [ restartedMain] .e.DevToolsPropertyDefaultsPostProcessor : For additional web related logging consider setting the 'logging.level.web' property to 'DEBUG'2020-07-20 09:51:28.817 INFO 12564 --- [ restartedMain] o.s.b.w.embedded.tomcat.TomcatWebServer : Tomcat initialized with port(s): 8080 (http)2020-07-20 09:51:28.831 INFO 12564 --- [ restartedMain] o.apache.catalina.core.StandardService : Starting service [Tomcat]2020-07-20 09:51:28.832 INFO 12564 --- [ restartedMain] org.apache.catalina.core.StandardEngine : Starting Servlet engine: [Apache Tomcat/9.0.35]2020-07-20 09:51:28.896 INFO 12564 --- [ restartedMain] o.a.c.c.C.[Tomcat].[localhost].[/] : Initializing Spring embedded WebApplicationContext2020-07-20 09:51:28.896 INFO 12564 --- [ restartedMain] o.s.web.context.ContextLoader : Root WebApplicationContext: initialization completed in 1827 ms2020-07-20 09:51:29.631 INFO 12564 --- [ restartedMain] o.s.s.web.DefaultSecurityFilterChain : Creating filter chain: any request, [org.springframework.security.web.context.request.async.WebAsyncManagerIntegrationFilter@56cf4f3a, org.springframework.security.web.context.SecurityContextPersistenceFilter@45e169c9, org.springframework.security.web.header.HeaderWriterFilter@26d4eefe, org.springframework.security.web.authentication.logout.LogoutFilter@f17fdd6, org.springframework.security.web.authentication.UsernamePasswordAuthenticationFilter@5f33f6b3, org.springframework.security.web.authentication.ui.DefaultLoginPageGeneratingFilter@70ffa278, org.springframework.security.web.authentication.ui.DefaultLogoutPageGeneratingFilter@109a14b8, org.springframework.security.web.savedrequest.RequestCacheAwareFilter@54857a49, org.springframework.security.web.servletapi.SecurityContextHolderAwareRequestFilter@423bad4c, org.springframework.security.web.authentication.rememberme.RememberMeAuthenticationFilter@7e8ca12a, org.springframework.security.web.authentication.AnonymousAuthenticationFilter@3ee5e690, org.springframework.security.web.session.SessionManagementFilter@7139411a, org.springframework.security.web.access.ExceptionTranslationFilter@1ec9ee0a, org.springframework.security.web.access.intercept.FilterSecurityInterceptor@bf4c490]2020-07-20 09:51:29.711 INFO 12564 --- [ restartedMain] o.s.s.concurrent.ThreadPoolTaskExecutor : Initializing ExecutorService 'applicationTaskExecutor'2020-07-20 09:51:29.929 INFO 12564 --- [ restartedMain] o.s.b.d.a.OptionalLiveReloadServer : LiveReload server is running on port 357292020-07-20 09:51:29.967 INFO 12564 --- [ restartedMain] o.s.b.w.embedded.tomcat.TomcatWebServer : Tomcat started on port(s): 8080 (http) with context path ''2020-07-20 09:51:29.976 INFO 12564 --- [ restartedMain] com.dvms.DataViewApplication : Started DataViewApplication in 3.27 seconds (JVM running for 3.828)2020-07-20 09:51:44.774 INFO 12564 --- [nio-8080-exec-1] o.a.c.c.C.[Tomcat].[localhost].[/] : Initializing Spring DispatcherServlet 'dispatcherServlet'2020-07-20 09:51:44.775 INFO 12564 --- [nio-8080-exec-1] o.s.web.servlet.DispatcherServlet : Initializing Servlet 'dispatcherServlet'2020-07-20 09:51:44.782 INFO 12564 --- [nio-8080-exec-1] o.s.web.servlet.DispatcherServlet : Completed initialization in 5 ms2020-07-20 09:51:56.052 INFO 12564 --- [nio-8080-exec-5] com.alibaba.druid.pool.DruidDataSource : &#123;dataSource-1&#125; init 浏览器输入：localhost8080:/index（根据实际项目）显示网页说明打包成功！！！","updated":"2020-07-23T07:22:18.859Z","categories":[{"name":"SpringBoot","slug":"SpringBoot","permalink":"http://yoursite.com/categories/SpringBoot/"}],"tags":[{"name":"jar包","slug":"jar包","permalink":"http://yoursite.com/tags/jar%E5%8C%85/"}]},{"title":"jar包和war包区别及理解","date":"2020-07-22T11:17:33.000Z","path":"2020/07/22/jar包和war包区别及理解/","text":"Hello World! 在开发阶段不适合使用war包，因为在开发阶段，经常需要添加或删除Web应用程序的内容，更新 Servlet类文件，而每一次改动后，重新建立war包将是一件浪费时间的事情。在产品发布阶段，使用war文件比较合适的，因为在这个时候，几乎不需要再做什么改动了。 jar包jar是类的归档文件JAR（Java Archive，Java 归档文件）是与平台无关的文件格式，它允许将许多文件组合成一个压缩文件，为 J2EE 应用程序创建的jar文件是 EAR 文件（企业 jar文件），jar文件格式以流行的 ZIP 文件格式为基础。与 ZIP 文件不同的是，jar文件不仅用于压缩和发布，而且还用于部署和封装库、组件和插件程序，并可被像编译器和 JVM 这样的工具直接使用。在 jar中包含特殊的文件，如 manifests 和部署描述符，用来指示工具如何处理特定的 jar。通常是开发时要引用通用类，打成jar包便于存放管理，当你使用某些功能时就需要这些jar包的支持，需要导入jar包。jar包就是java的类进行编译生成的class文件打包的压缩包，包里面就是一些class文件。当我们自己使用Maven写一些java程序，进行打包生成jar包。同时在可以在其他的工程下使用，但是我们在这个工程依赖的jar包，在其他工程使用该JAR包也要导入。 war包war包是一个Web应用程序一个web程序进行打包便于部署的压缩包，里面包含我们web程序需要的一些东西，其中包括web.xml的配置文件，前端的页面文件，以及依赖的jar。便于我们部署工程，直接放到tomcat的webapps目录下，直接启动tomcat即可。同时，可以使用WinRAR查看war包，直接将后缀.war改成.rar。 Web存档(war)文件包含Web应用程序的所有内容。它减少了传输文件所需要的时间。 jar包和war包区别jar是java普通项目打包，通常是开发时要引用通用类，打成jar包便于存放管理。当你使用某些功能时就需要这些jar包的支持，需要导入jar包。war是java web项目打包，web网站完成后，打成war包部署到服务器，目的是为了节省资源，提供效率。 jar文件（扩展名为. Jar，Java Application Archive）包含Java类的普通库、资源（resources）、辅助文件（auxiliary files）等。通常是开发时要引用的通用类，打成包便于存放管理。简单来说，jar包就是别人已经写好的一些类，然后对这些类进行打包。可以将这些jar包引入到你的项目中，可以直接使用这些jar包中的类和属性，这些jar包一般放在lib目录下。 war文件（扩展名为.War,Web Application Archive）包含全部Web应用程序。在这种情形下，一个Web应用程序被定义为单独的一组文件、类和资源，用户可以对jar文件进行封装，并把它作为小型服务程序（servlet）来访问。 war包是一个可以直接运行的web模块，通常用于网站，打成包部署到容器中。以Tomcat来说，将war包放置在其\\webapps\\目录下,然后启动Tomcat，这个包就会自动解压，就相当于发布了。war包是Sun提出的一种web应用程序格式，与jar类似，是很多文件的压缩包。war包中的文件按照一定目录结构来组织。根据其根目录下包含有html和jsp文件，或者包含有这两种文件的目录，另外还有WEB-INF目录。通常在WEB-INF目录下含有一个web.xml文件和一个classes目录，web.xml是这个应用的配置文件，而classes目录下则包含编译好的servlet类和jsp，或者servlet所依赖的其他类（如JavaBean）。通常这些所依赖的类也可以打包成jar包放在WEB-INF下的lib目录下。 Ear文件（扩展名为.Ear,Enterprise Application Archive）包含全部企业应用程序。在这种情形下，一个企业应用程序被定义为多个jar文件、资源、类和Web应用程序的集合。 SpringBoot项目既可以打成war包发布，也可以找成jar包发布。jar包：直接通过内置Tomcat运行，不需要额外安装Tomcat。如需修改内置Tomcat的配置，只需要在SpringBoot的配置文件中配置。内置Tomcat没有自己的日志输出，全靠jar包应用输出日志。但是比较方便，快速，比较简单。war包：传统的应用交付方式，需要安装Tomcat，然后放到wabapps目录下运行war包，可以==灵活选择Tomcat版本==，可以直接修改Tomcat的配置，有自己的Tomcat日志输出，可以灵活配置安全策略,相对打成jar包来说没那么快速方便。 END","updated":"2020-07-23T07:18:55.904Z","categories":[{"name":"JavaWeb","slug":"JavaWeb","permalink":"http://yoursite.com/categories/JavaWeb/"}],"tags":[{"name":"SpringBoot","slug":"SpringBoot","permalink":"http://yoursite.com/tags/SpringBoot/"},{"name":"jar包","slug":"jar包","permalink":"http://yoursite.com/tags/jar%E5%8C%85/"}]},{"title":"MANIFEST.MF文件属性总结理解","date":"2020-07-22T11:15:57.000Z","path":"2020/07/22/MANIFEST-MF文件属性总结理解/","text":"Hello World! MANIFEST.MF定义了与扩展和包相关的数据；打开Java的JAR文件我们经常可以看到文件中包含着一个META-INF目录， 这个目录下会有一些文件，其中必有一个MANIFEST.MF，这个文件描述了该Jar文件的很多信息。 MANIFEST.MF文件属性 一. 一般属性 Manifest-Version用来定义manifest文件的版本，例如：Manifest-Version: 1.0 Created-By声明该文件的生成者，一般该属性是由jar命令行工具生成的，例如：Created-By: Apache Ant 1.5.1 Signature-Version定义jar文件的签名版本 Class-Path应用程序或者类装载器使用该值来构建内部的类搜索路径 二. 应用程序相关属性 Main-Class定义jar文件的入口类，该类必须是一个可执行的类，一旦定义了该属性即可通过 java -jar x.jar来运行该jar文件。 三. 小程序(Applet)相关属性 Extendsion-List该属性指定了小程序需要的扩展信息列表，列表中的每个名字对应以下的属性 -Extension-Name -Specification-Version -Implementation-Version -Implementation-Vendor-Id -Implementation-URL 四. 扩展标识属性 Extension-Name该属性定义了jar文件的标识，例如Extension-Name: Struts Framework 五. 包扩展属性 Implementation-Title 定义了扩展实现的标题 Implementation-Version 定义扩展实现的版本 Implementation-Vendor 定义扩展实现的组织 Implementation-Vendor-Id 定义扩展实现的组织的标识 Implementation-URL : 定义该扩展包的下载地址(URL) Specification-Title 定义扩展规范的标题 Specification-Version 定义扩展规范的版本 Specification-Vendor 声明了维护该规范的组织 Sealed 定义jar文件是否封存，值可以是true或者false (这点我还不是很理解) 六. 签名相关属性 签名方面的属性我们可以来参照JavaMail所提供的mail.jar中的一段 Name: javax/mail/Address.classDigest-Algorithms: SHA MD5SHA-Digest: AjR7RqnN//cdYGouxbd06mSVfI4=MD5-Digest: ZnTIQ2aQAtSNIOWXI1pQpw== 这段内容定义类签名的类名、计算摘要的算法名以及对应的摘要内容(使用BASE方法进行编码) 七.自定义属性 除了前面提到的一些属性外，你也可以在MANIFEST.MF中增加自己的属性以及响应的值，例如J2ME程序jar包中就可能包含着如下信息 MicroEdition-Configuration: CLDC-1.0MIDlet-Name: J2ME_MOBBER Midlet SuiteMIDlet-Info-URL: http://www.javayou.comMIDlet-Icon: /icon.pngMIDlet-Vendor: Midlet Suite VendorMIDlet-1: mobber,/icon.png,mobberMIDlet-Version: 1.0.0MicroEdition-Profile: MIDP-1.0MIDlet-Description: Communicator其他可参考：MANIFEST.MF文件详解 END","updated":"2020-07-23T07:18:56.004Z","categories":[{"name":"JavaWeb","slug":"JavaWeb","permalink":"http://yoursite.com/categories/JavaWeb/"},{"name":"SpringBoot","slug":"JavaWeb/SpringBoot","permalink":"http://yoursite.com/categories/JavaWeb/SpringBoot/"}],"tags":[{"name":"MANIFEST.MF","slug":"MANIFEST-MF","permalink":"http://yoursite.com/tags/MANIFEST-MF/"}]},{"title":"Maven仓库安装配置教程(windows)","date":"2020-07-21T11:42:28.000Z","path":"2020/07/21/Maven仓库安装配置教程-windows/","text":"Hello World! 1. 安装本地Maven点此进入maven官网下载 2.配置环境变量系统变量:MAVEN_HOME = D:\\apache-maven-3.6.1系统变量:path = %MAVEN_HOME%\\bin 3. 验证安装然后win+R 运行cmd 输入 mvn -version，如图所示则配置成功！！！ 4. 配置settings文件在D:\\apache-maven-3.6.1\\conf下可以找到settings文件找到第52行，这里是maven默认的仓库，复制第53行/path/to/local/repo将它拿到注释外并将中间的内容改成你需要的路径:(不改也行) 1&lt;localRepository&gt;D:/repository&lt;/localRepository&gt; 这里的路径随便设置，注意这里是正斜杠因为国外的服务器下载jar包很慢所以我们改为阿里云服务器（大约在150行左右），这两个仓库只用选一个(根据大家反馈建议使用第一个，第二个在有的版本可能会出现warning) alimaven central aliyun maven http://maven.aliyun.com/nexus/content/repositories/central/ 或者 nexus-aliyun * Nexus aliyun http://maven.aliyun.com/nexus/content/groups/public 在最后配置jdk，也要夹在两个profiles标签之间（不改也没事） jdk-1.8 true 1.8 &lt;properties&gt; &lt;maven.compiler.source&gt;1.8&lt;/maven.compiler.source&gt; &lt;maven.compiler.target&gt;1.8&lt;/maven.compiler.target&gt; &lt;maven.compiler.compilerVersion&gt;1.8&lt;/maven.compiler.compilerVersion&gt; &lt;/properties&gt; 配置完成，在命令行输入mvn help:system测试，看到下载链接里面是ailiyun的链接表示配置成功： END","updated":"2020-07-23T07:22:25.946Z","categories":[{"name":"JavaWeb","slug":"JavaWeb","permalink":"http://yoursite.com/categories/JavaWeb/"},{"name":"SpringBoot","slug":"JavaWeb/SpringBoot","permalink":"http://yoursite.com/categories/JavaWeb/SpringBoot/"}],"tags":[{"name":"Maven","slug":"Maven","permalink":"http://yoursite.com/tags/Maven/"}]},{"title":"SpringBoot整合Mybatis","date":"2020-07-21T11:20:32.000Z","path":"2020/07/21/SpringBoot整合Mybatis/","text":"Hello World! My Environment IDEA2018.3 JDK1.8 SpringBoot2.3.0 360浏览器整合过程 新建一个Spring Initializr项目 创建项目的文件结构以及jdk的版本 选择项目所需要的依赖 修改项目名，点击完成 选择自动导入依赖pom,xml文件 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081&lt;?xml version=\"1.0\" encoding=\"UTF-8\"?&gt;&lt;project xmlns=\"http://maven.apache.org/POM/4.0.0\" xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\" xsi:schemaLocation=\"http://maven.apache.org/POM/4.0.0 https://maven.apache.org/xsd/maven-4.0.0.xsd\"&gt; &lt;modelVersion&gt;4.0.0&lt;/modelVersion&gt; &lt;parent&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-parent&lt;/artifactId&gt; &lt;version&gt;2.3.1.RELEASE&lt;/version&gt; &lt;relativePath/&gt; &lt;!-- lookup parent from repository --&gt; &lt;/parent&gt; &lt;groupId&gt;com.cjw&lt;/groupId&gt; &lt;artifactId&gt;demo&lt;/artifactId&gt; &lt;version&gt;0.0.1-SNAPSHOT&lt;/version&gt; &lt;name&gt;demo&lt;/name&gt; &lt;description&gt;Demo project for Spring Boot&lt;/description&gt; &lt;properties&gt; &lt;java.version&gt;1.8&lt;/java.version&gt; &lt;/properties&gt; &lt;dependencies&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-jdbc&lt;/artifactId&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-security&lt;/artifactId&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-thymeleaf&lt;/artifactId&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-web&lt;/artifactId&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.mybatis.spring.boot&lt;/groupId&gt; &lt;artifactId&gt;mybatis-spring-boot-starter&lt;/artifactId&gt; &lt;version&gt;2.1.3&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;mysql&lt;/groupId&gt; &lt;artifactId&gt;mysql-connector-java&lt;/artifactId&gt; &lt;scope&gt;runtime&lt;/scope&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.projectlombok&lt;/groupId&gt; &lt;artifactId&gt;lombok&lt;/artifactId&gt; &lt;optional&gt;true&lt;/optional&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-test&lt;/artifactId&gt; &lt;scope&gt;test&lt;/scope&gt; &lt;exclusions&gt; &lt;exclusion&gt; &lt;groupId&gt;org.junit.vintage&lt;/groupId&gt; &lt;artifactId&gt;junit-vintage-engine&lt;/artifactId&gt; &lt;/exclusion&gt; &lt;/exclusions&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.security&lt;/groupId&gt; &lt;artifactId&gt;spring-security-test&lt;/artifactId&gt; &lt;scope&gt;test&lt;/scope&gt; &lt;/dependency&gt; &lt;/dependencies&gt; &lt;build&gt; &lt;plugins&gt; &lt;plugin&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-maven-plugin&lt;/artifactId&gt; &lt;/plugin&gt; &lt;/plugins&gt; &lt;/build&gt;&lt;/project&gt; 6.修改配置文件 12345678910111213#server.port=8080#server.servlet.context-path=/index #访问路径设置spring.datasource.url = jdbc:mysql://localhost:3306/ems?characterEncoding=UTF-8&amp;useSSL=true&amp;serverTimezone=UTCspring.datasource.username = rootspring.datasource.password = 123456spring.datasource.driverClassName = com.mysql.cj.jdbc.Driverspring.datasource.type = com.alibaba.druid.pool.DruidDataSourcemybatis.mapper-locations = classpath:mapper/*.xmlmybatis.type-aliases-package = com.dvms.entityspring.resources.static-locations = classpath:/templates/,classpath:/static/ 这里使用application.properties文件，也可以使用更加简洁的application.yml文件，须要将resource文件夹下原有的application.properties文件删除，染回创建application.yml配置文件（备注：其实SpringBoot底层会把application.yml文件解析为application.properties）7.实现业务流程创建包controller、entity、mapper、service。resources下创建mapper文件夹，用于写sql语句，也可以用注解的方式直接写在mapper文件里。最终框架结构:完成以上，下面在启动类里加上注解用于给出需要扫描的dao文件路径@MapperScan(“com.dvms.dao”) //扫描dao接口,mybatis扫描路径，针对的是接口Mapper类最后启动，浏览器输入地址：http://localhost:8080/index(根据实际项目)显示出对应界面即可。END","updated":"2020-07-23T07:22:07.786Z","categories":[{"name":"SpringBoot","slug":"SpringBoot","permalink":"http://yoursite.com/categories/SpringBoot/"},{"name":"JavaWeb","slug":"SpringBoot/JavaWeb","permalink":"http://yoursite.com/categories/SpringBoot/JavaWeb/"}],"tags":[{"name":"Mybatis","slug":"Mybatis","permalink":"http://yoursite.com/tags/Mybatis/"}]},{"title":"SSM框架下各层的解释说明（Controller等）","date":"2020-07-21T11:04:12.000Z","path":"2020/07/21/SSM框架下各层的解释说明（Controller等）/","text":"Hello World! SSM框架SSM框架是spring MVC ，Spring和Mybatis框架的整合，是标准的MVC模式，将整个系统划分为表现层（web），controller层，service层，dao层四层,使用spring MVC负责请求的转发和视图管理。Spring实现业务对象管理，Mybatis作为数据对象的持久化引擎。表现层（web）：通俗讲就是展现给用户的界面，即用户在使用一个系统的时候他的所见所得。业务逻辑层（service）：针对具体问题的操作，也可以说是对数据层的操作，对数据业务逻辑处理。数据访问层（dao）：该层所做事务直接操作数据库，针对数据的增添、删除、修改、更新、查找等。DataBase ===&gt; Entity ===&gt; Mapper.xml ===&gt; Dao.Java ===&gt; Service.java ===&gt; Controller.java ===&gt; html css js（thymeleaf） 各层解释说明用IDEA创建一个maven项目结构如左图所示,在该项目中,有五个包,分别是controller、dao、entity、service和serviceimpl：|层| 描述 ||–|–|| 实体层 | 数据库在项目中的类，主要用于定义与数据库对象应的属性，提供get/set方法,tostring方法,有参无参构造函数。 ||持久层 | 与数据库交互，dao层首先会创建dao接口，接着就可以在配置文件中定义该接口的实现类；接着就可以在模块中调用dao的接口进行数据业务的处理，而不用关注此接口的具体实现类是哪一个类，dao层的数据源和数据库连接的参数都是在配置文件中进行配置的。 ||业务层 |控制业务,业务模块的逻辑应用设计，和dao层一样都是先设计接口，再创建要实现的类，然后在配置文件中进行配置其实现的关联。接下来就可以在service层调用接口进行业务逻辑应用的处理。 || 实现层 |实现service接口的所有方法，整合service和dao ||控制层 | controller层主要调用Service层里面的接口控制具体的业务流程，控制的配置也要在配置文件中进行。Controller和Service的区别是：Controller负责具体的业务模块流程的控制；Service层负责业务模块的逻辑应用设计 | entity层（model层） 实体层用于存放我们的实体类，与数据库中的属性值基本保持一致，实现set和get的方法。 1.导入lombok小辣椒驱动依赖,用来生成get/set方法依赖： 12345678910111213141516171819202122232425package com.dvms.entity;import lombok.AllArgsConstructor;import lombok.Data;import lombok.NoArgsConstructor;import lombok.ToString;import lombok.experimental.Accessors;import java.util.Date;@Data@ToString@AllArgsConstructor@NoArgsConstructor@Accessors(chain = true) //链式调用public class Emp &#123; private String id; private String name; private Double salary; private Integer age; private Date bir;&#125; 2.传统方式 123456789101112131415161718192021222324252627282930313233343536373839404142package com.umf.entity;import java.io.Serializable;public class UpdataSettingEntity implements Serializable &#123; private static final long serialVersionUID = 1L; // private Integer id = 1; // private int updataflag; /** * 设置： */ public void setId(Integer id) &#123; this.id = id; &#125; /** * 获取： */ public Integer getId() &#123; return id; &#125; /** * 设置： */ public void setUpdataflag(int updataflag) &#123; this.updataflag = updataflag; &#125; /** * 获取： */ public int getUpdataflag() &#123; return updataflag; &#125;&#125; dao层（mapper层）dao层（接口类）对数据库进行数据持久化操作，他的方法语句是直接针对数据库操作的，主要实现一些增删改查操作，在Mybatis中方法主要与与xxxDao（Mapper）.xml内相互一一映射。Mybatis可以用.xml进行数据操作，也可以在dao层用注解的方式，也可以采取xml和dao层接口组合使用的方法（常用）。 12345678910111213141516171819202122232425262728package com.dvms.dao;import com.dvms.entity.User;import org.apache.ibatis.annotations.Param;import org.springframework.stereotype.Repository;import java.util.List;@Repositorypublic interface UserDao &#123; //登录 User login(@Param(\"username\") String username, @Param(\"password\") String password);// 在mybatis中传递多个参数要做参数的绑定 //新增用户(注册) void save(User user); //查询所有用户 List&lt;User&gt; findAlluser(); //删除用户 void delete(String id); //修改用户信息（先查再改） User update(String id); void add(User user);&#125; xxxDao（Mapper）.xml：关键： &lt; mapper namespace=”com.dvms.dao.UserDao“&gt;前提：基本数据库语法 123456789101112131415161718192021222324252627282930313233&lt;?xml version=\"1.0\" encoding=\"UTF-8\" ?&gt;&lt;!DOCTYPE mapper PUBLIC \"-//mybatis.org//DTD Mapper 3.0//EN\" \"http://mybatis.org/dtd/mybatis-3-mapper.dtd\"&gt;&lt;mapper namespace=\"com.dvms.dao.UserDao\"&gt;&lt;!--注册/新增用户--&gt; &lt;insert id=\"save\" parameterType=\"User\"&gt; insert into user (id,username,password,sex,phone,email,role) values (#&#123;id&#125;,#&#123;username&#125;,#&#123;password&#125;,#&#123;sex&#125;,#&#123;phone&#125;,#&#123;email&#125;,#&#123;role&#125;) &lt;/insert&gt;&lt;!--登录验证--&gt; &lt;select id=\"login\" resultType=\"User\"&gt; select id,username,password,sex,phone,email,role from user where username =#&#123;username&#125; and password =#&#123;password&#125; &lt;/select&gt;&lt;!--查询所有用户--&gt; &lt;select id=\"findAlluser\" resultType=\"User\"&gt; select id,username,password,sex,phone,email,role from user &lt;/select&gt;&lt;!--删除用户--&gt; &lt;delete id=\"delete\" parameterType=\"String\"&gt; delete from user where id=#&#123;id&#125; &lt;/delete&gt;&lt;!--修改用户信息--&gt; &lt;!--查到要修改的用户信息--&gt; &lt;select id=\"update\" parameterType=\"String\" resultType=\"User\"&gt; select id,username,password,sex,phone,email,role from user where id=#&#123;id&#125; &lt;/select&gt; &lt;!--修改用户信息--&gt; &lt;update id=\"add\" parameterType=\"User\"&gt; update user set username=#&#123;username&#125;,password=#&#123;password&#125;,sex=#&#123;sex&#125;,phone=#&#123;phone&#125;,email=#&#123;email&#125;,role=#&#123;role&#125; where id=#&#123;id&#125; &lt;/update&gt;&lt;/mapper&gt; 在dao层用注解的方式： 12345public interface StudentDao &#123; @Select(\"select * from student where stu_id=#&#123;stuId&#125;\") public Student queryById(int stuId);&#125; service层service层（接口类）为controller层的类提供接口进行调用,一般就是自己写的方法封装起来，具体实现在serviceImpl中。service层是建立在dao层之上的，建立了dao层后才可以建立service层，而service层又是在controller层之下的，因而service层应该既调用dao层的接口，又要提供接口给Controller层的类来进行调用，它刚好处于一个中间层的位置。每个模型都有一个service接口，每个接口分别封装各自的业务处理方法。 12345678910111213141516171819202122232425package com.dvms.service;import com.dvms.entity.User;import java.util.List;public interface UserService &#123; //新增用户 void save(User user); //登录 User login(String username, String password); //查询所有用户 List&lt;User&gt; findAlluser(); //删除用户 void delete(String id); //修改用户信息 User update(String id); void add(User user);&#125; servicedmpl（实现service层，整合service和dao）（导入dao层）（接口实现类） 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253package com.dvms.service.Impl;import com.dvms.dao.UserDao;import com.dvms.entity.User;import com.dvms.service.UserService;import org.springframework.beans.factory.annotation.Autowired;import org.springframework.stereotype.Service;import java.util.List;import java.util.UUID;@Servicepublic class UserServiceImpl implements UserService &#123; @Autowired private UserDao userDao; @Override public void save(User user) &#123; user.setId(UUID.randomUUID().toString()); userDao.save(user); &#125; @Override public User login(String username, String password) &#123; return userDao.login(username,password); &#125; @Override public List&lt;User&gt; findAlluser() &#123; return userDao.findAlluser(); &#125; @Override public void delete(String id) &#123; userDao.delete(id); &#125; @Override public User update(String id) &#123; return userDao.update(id); &#125; @Override public void add(User user) &#123; userDao.add(user); &#125;&#125; Controller层（web 层）负责具体模块的业务流程控制（获取参数（前端传过来）返回响应（前端或数据库或一个指定路径）），需要调用service逻辑设计层的接口来控制业务流程（导入service层）。 1234567891011121314151617181920212223242526272829303132package com.dvms.controller;import com.dvms.entity.Emp;.....@Controllerpublic class EmpController &#123; @Autowired private EmpService empService; @GetMapping(\"emp/findAll\") public String findAll(@RequestParam(defaultValue = \"1\") int pageNum, @RequestParam(defaultValue = \"5\") int pageSize, Model model)&#123; PageHelper.startPage(pageNum,pageSize);// PageInfo&lt;Emp&gt; pageInfo = new PageInfo&lt;&gt;(empService.findAll()); model.addAttribute(\"pageInfo\",pageInfo);// List&lt;Emp&gt; emps = empService.findAll();// model.addAttribute(\"emps\",emps); return \"ems/tables\"; &#125; @RequestMapping(\"/emp/save\") public String save(Emp emp)&#123; empService.save(emp); return \"redirect:/emp/findAll\"; &#125;&#125; Controller层调用了Service层的接口方法，Service层调用Dao层的方法，其中调用的参数是使用Entity层进行传递的。View层与Controller层协同工作,主要负责界面展示。","updated":"2020-07-23T07:18:55.976Z","categories":[{"name":"JavaWeb","slug":"JavaWeb","permalink":"http://yoursite.com/categories/JavaWeb/"}],"tags":[{"name":"JavaWeb","slug":"JavaWeb","permalink":"http://yoursite.com/tags/JavaWeb/"},{"name":"SSM框架","slug":"SSM框架","permalink":"http://yoursite.com/tags/SSM%E6%A1%86%E6%9E%B6/"}]},{"title":"MyBatis映射标签resultMap与resultType、parameterMap与 parameterType","date":"2020-07-21T10:49:06.000Z","path":"2020/07/21/MyBatis映射标签resultMap与resultType、parameterMap与-parameterType/","text":"Hello World! MyBatis映射标签1234567&lt;?xml version=\"1.0\" encoding=\"UTF-8\" ?&gt;&lt;!DOCTYPE mapper PUBLIC \"-//mybatis.org//DTD Mapper 3.0//EN\" \"http://mybatis.org/dtd/mybatis-3-mapper.dtd\"&gt;&lt;mapper namespace=\"com.dvms.dao.UserDao\"&gt;....&lt;/mapper&gt; 123456789101112131415161718192021222324252627282930313233&lt;?xml version=\"1.0\" encoding=\"UTF-8\" ?&gt;&lt;!DOCTYPE mapper PUBLIC \"-//mybatis.org//DTD Mapper 3.0//EN\" \"http://mybatis.org/dtd/mybatis-3-mapper.dtd\"&gt;&lt;mapper namespace=\"com.dvms.dao.UserDao\"&gt;&lt;!--注册/新增用户--&gt; &lt;insert id=\"save\" parameterType=\"User\"&gt; insert into user (id,username,password,sex,phone,email,role) values (#&#123;id&#125;,#&#123;username&#125;,#&#123;password&#125;,#&#123;sex&#125;,#&#123;phone&#125;,#&#123;email&#125;,#&#123;role&#125;) &lt;/insert&gt;&lt;!--登录验证--&gt; &lt;select id=\"login\" resultType=\"User\"&gt; select id,username,password,sex,phone,email,role from user where username =#&#123;username&#125; and password =#&#123;password&#125; &lt;/select&gt;&lt;!--查询所有用户--&gt; &lt;select id=\"findAlluser\" resultType=\"User\"&gt; select id,username,password,sex,phone,email,role from user &lt;/select&gt;&lt;!--删除用户--&gt; &lt;delete id=\"delete\" parameterType=\"String\"&gt; delete from user where id=#&#123;id&#125; &lt;/delete&gt;&lt;!--修改用户信息--&gt; &lt;!--查到要修改的用户信息--&gt; &lt;select id=\"update\" parameterType=\"String\" resultType=\"User\"&gt; select id,username,password,sex,phone,email,role from user where id=#&#123;id&#125; &lt;/select&gt; &lt;!--修改用户信息--&gt; &lt;update id=\"add\" parameterType=\"User\"&gt; update user set username=#&#123;username&#125;,password=#&#123;password&#125;,sex=#&#123;sex&#125;,phone=#&#123;phone&#125;,email=#&#123;email&#125;,role=#&#123;role&#125; where id=#&#123;id&#125; &lt;/update&gt;&lt;/mapper&gt; 在MyBatis中，输入与输出都是相对于数据库而言，我们通过parameterType完成输入映射(指将值映射到sql语句的占位符中，值的类型与dao层响应方法的参数类型一致)，通过resultType完成输出映射(从数据库中输出，通过dao层的方法查询到的数据输出到pojo对象（实体类entity）中)。 1. 输入映射（往数据库输入）parameterMap（不常用）与 parameterType（常用） ParameterMap和resultMap类似，表示将查询结果集中列值的类型一一映射到java对象属性的类型上，在开发过程中不推荐这种方式。 一般使用parameterType直接将查询结果列值类型自动对应到java对象属性类型上，不再配置映射关系一一对应。 2. 输出映射（从数据库输出）resultMap与resultType（常用） 两者都是表示查询结果集与java对象之间的一种关系，处理查询结果集，映射到java对象。 resultMap表示将查询结果集中的列一一映射到bean对象的各个属性。映射的查询结果集中的列标签可以根据需要灵活变化，并且，在映射关系中，还可以通过typeHandler设置实现查询结果值的类型转换，比如布尔型与0/1的类型转换。 #{}和${}的使用resultMap和ParameterMap书写拼写要使用#{}，resultType 和parameterType类型使用${}，（一般是用#{}）使用例子如下： Select ID，COMMAND from Message where COMMAND=#{command} Select ID，COMMAND from Message where COMMAND=‘${command}’ 前者解析为： Select ID，COMMAND from Message where COMMAND=？具有预编译效果后者解析为： Select ID，COMMAND from Message where COMMAND=段子 不具有预编译效果 在Mybatis中传递多个参数要做参数的绑定（@Param）不写parameterType也可以运行,因为Mybatis能自动识别，但返回值类型不能不写!!Mybatis自动识别入参对象, 传入单个map或单个对象,无需写@Param注解 如@Param(“map”) Map&lt;String, Object&gt; map那么什么时候必须在mapper接口上写@Param注解呢, mapper接口中有多个参数(每个对象或参数都要加@Param注解), 或一个 String, 必须使用@Param注解,END","updated":"2020-07-23T07:22:13.135Z","categories":[{"name":"SpringBoot","slug":"SpringBoot","permalink":"http://yoursite.com/categories/SpringBoot/"},{"name":"JavaWeb","slug":"SpringBoot/JavaWeb","permalink":"http://yoursite.com/categories/SpringBoot/JavaWeb/"}],"tags":[{"name":"MyBatis","slug":"MyBatis","permalink":"http://yoursite.com/tags/MyBatis/"}]},{"title":"Spring框架常用注解","date":"2020-07-21T10:17:34.000Z","path":"2020/07/21/Spring框架常用注解/","text":"Hello World! Spring常用注解 @Controller@Controller 用来响应页面，表示当前的类为控制器。在SpringMVC 中，控制器Controller 负责处理由DispatcherServlet 分发的请求，它把用户请求的数据经过业务处理层处理之后封装成一个Model ，然后再把该Model 返回给对应的View 进行展示。在SpringMVC 中提供了一个非常简便的定义Controller 的方法，你无需继承特定的类或实现特定的接口，只需使用@Controller 标记一个类是Controller ，然后使用@RequestMapping 和@RequestParam 等一些注解用以定义URL 请求和Controller 方法之间的映射，这样的Controller 就能被外界访问到。此外Controller 不会直接依赖于HttpServletRequest 和HttpServletResponse 等HttpServlet 对象，它们可以通过Controller 的方法参数灵活的获取到。@Controller 用于标记在一个类上，使用它标记的类就是一个SpringMVC Controller 对象。分发处理器将会扫描使用了该注解的类的方法，并检测该方法是否使用了@RequestMapping 注解。@Controller 只是定义了一个控制器类，而使用@RequestMapping 注解的方法才是真正处理请求的处理器。单单使用@Controller 标记在一个类上还不能真正意义上的说它就是SpringMVC 的一个控制器类，因为这个时候Spring 还不认识它。那么要如何做Spring 才能认识它呢?这个时候就需要我们把这个控制器类交给Spring 来管理。 @RestControllerSpring4之后新加入的注解，原来返回json需要@ResponseBody和@Controller配合，表明当前类是控制器且返回的是一组数据，不是页面。@RestController是@ResponseBody和@Controller的组合注解，推荐直接使用@RestController注解来处理http请求。 12345678@RestControllerpublic class HelloController &#123; @RequestMapping(value=\"/hello\",method= RequestMethod.GET) public String sayHello()&#123; return \"hello\"; &#125;&#125; 123456789@Controller@ResponseBodypublic class HelloController &#123; @RequestMapping(value=\"/hello\",method= RequestMethod.GET) public String sayHello()&#123; return \"hello\"; &#125;&#125; @Autowired@Autowired的作用是将其他的类，接口引入，类似于之前的类的初始化等，用这个注解，类中或接口的方法就可以直接调用了。@Autowired顾名思义，就是自动装配，其作用是为了消除代码Java代码里面的getter/setter与bean属性中的property。当然，getter看个人需求，如果私有属性需要对外提供的话，应当予以保留。@Resource的作用相当于@Autowired @ResponseBody作用: 该注解用于将Controller的方法返回的对象，通过适当的HttpMessageConverter转换为指定格式后，写入到Response对象的body数据区。当返回的数据不是html标签的页面，而是其他某种格式的数据时(如json、xml等)时使用。 @RequestMapping （配置url映射）@RequestMapping如果没有指定请求方式，将接收Get,Post,Head,Options等所有的请求方式。@RequestMapping此注解即可以作用在控制器的某个方法上，也可以作用在此控制器类上。当前台界面调用Controller处理数据时候告诉控制器怎么操作有3种情形：1.当控制器在类级别上添加@RequestMapping注解时，这个注解会应用到控制器的所有处理器方法上。处理器方法上的@RequestMapping注解会对类级别上的@RequestMapping的声明进行补充。2.@RequestMapping作用在处理器方法上。3.@RequestMapping同时作用在类级别和处理器方法上。所响应的url=localhost:8080/updata_setting/updata @RequestMapping注解属性作用：简化常用的HTTP方法的映射，并更好地表达被注解方法的语义。RequestMapping注解有六个属性：1、 value， method; value: 指定请求的实际地址，指定的地址可以是URI Template 模式(后面将会说明); method: 指定请求的method类型， GET、POST、PUT、DELETE等;常用： GET、POST组合注解： @GetMapping @RequestMapping(method = RequestMethod.GET)的简写作用：对应查询，表明是一个查询URL映射 @PostMapping @RequestMapping(method =RequestMethod.POST)的简写作用：对应增加，表明是一个增加URL映射 @PutMapping@RequestMapping(method = RequestMethod.PUT)的简写作用：对应更新，表明是一个更新URL映射 @DeleteMapping @RequestMapping(method = RequestMethod.DELETE)的简写作用：对应删除，表明是一个删除URL映射 2、consumes，produces consumes: 指定处理请求的提交内容类型(Content-Type)，例如application/json, text/html; produces: 指定返回的内容类型，仅当request请求头中的(Accept)类型中包含该指定类型才返回; 3、params，headers params: 指定request中必须包含某些参数值是，才让该方法处理。 headers: 指定request中必须包含某些指定的header值，才能让该方法处理请求。 @PathVaribale通过@PathVariable注解来获取URL中的参数时的前提条件是我们知道url的格式时怎么样的。只有知道url的格式，我们才能在指定的方法上通过相同的格式获取相应位置的参数值。1.获取url中的单个参数（如id） 12345678@RestControllerpublic class HelloController &#123; @RequestMapping(value=\"/hello/&#123;id&#125;\",method= RequestMethod.GET) public String sayHello(@PathVariable(\"id\") Integer id)&#123; return \"id:\"+id; &#125;&#125; 2.获取url有多个参数 12345678@RestControllerpublic class HelloController &#123; @RequestMapping(value=\"/hello/&#123;id&#125;/&#123;name&#125;\",method= RequestMethod.GET) public String sayHello(@PathVariable(\"id\") Integer id,@PathVariable(\"name\") String name)&#123; return \"id:\"+id+\" name:\"+name; &#125;&#125; @RequestParam作用：获取请求参数的值@RequestParam注解给允许用户不输入参数时，使用默认值； @RequestBody如果传输的是单层json对象，我们后台可以直接用 @RequestParam接收。如果传输的是多层嵌套json对象，这个时候会就会出现数据丢失问题，@ResponseBody很好的解决了这个问题，它会把前台传输过来的json转化为后台对应的对象；@RequestBody接收的是一个Json对象的字符串，而不是一个Json对象。（易出错）然而在ajax请求往往传的都是Json对象，用JSON.stringify(data)的方式就能将对象变成字符串。同时ajax请求的时候也要指定dataType: “json”,contentType:”application/json” 这样就可以轻易的将一个对象或者List传到Java端，使用@RequestBody即可绑定对象或者List。 12345678910111213141516171819var vm = new Vue(&#123; el: '#updata', data: &#123; updata_setting: &#123;&#125; &#125;, methods: &#123; Save:function(ev)&#123; var url = \"../updata_setting/updata\"; $.ajax(&#123; type: \"POST\", url: url, data: JSON.stringify(vm.updata_setting), success: function(r)&#123; alert('操作成功！'); &#125; &#125;); &#125; &#125;&#125;); @Service用于标注业务层组件，位于service实现层：形如：@Service(“xxxService”) @Override@Override是伪代码,表示重写(当然不写也可以),不过写上有如下好处:1、可以当注释用,方便阅读。2、编译器可以给你验证@Override下面的方法名是否是你父类中所有的,如果没有则报错。比如你如果没写@Override而你下面的方法名又写错了,这时你的编译器是可以编译通过的(它以为这个方法是你的子类中自己增加的方法)。 @Repository@Repository用于标注数据访问组件，即dao层如果 Web 应用程序采用了经典的三层分层结构的话，最好在持久层、业务层和控制层分别采用上述注解对分层中的类进行注释。@Component泛指组件，当组件不好归类的时候，我们可以使用这个注解进行标注。 END","updated":"2020-07-23T07:18:55.952Z","categories":[{"name":"JavaWeb","slug":"JavaWeb","permalink":"http://yoursite.com/categories/JavaWeb/"}],"tags":[{"name":"Spring框架","slug":"Spring框架","permalink":"http://yoursite.com/tags/Spring%E6%A1%86%E6%9E%B6/"}]}]